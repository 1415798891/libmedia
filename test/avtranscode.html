<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>demo</title>
  <link rel="stylesheet" href="./element-ui.css" crossorigin>
</head>
<body>

  <div class="inputFormat">
    <span class="label">input format: </span>
    <div id="inputFormat" style="display: inline-block;">
      <el-radio v-model="radio" label="flv">flv</el-radio>
      <el-radio v-model="radio" label="mp4">mp4</el-radio>
      <el-radio v-model="radio" label="ts">mpegts</el-radio>
      <el-radio v-model="radio" label="mkv">matroska</el-radio>
      <el-radio v-model="radio" label="oggs">oggs</el-radio>
      <el-radio v-model="radio" label="ivf">ivf</el-radio>
      <el-radio v-model="radio" label="mp3">mp3</el-radio>
    </div>
  </div>

  <div class="outputFormat">
    <span class="label">output format: </span>
    <div id="outputFormat" style="display: inline-block;">
      <el-radio v-model="radio" label="flv">flv</el-radio>
      <el-radio v-model="radio" label="mp4">mp4</el-radio>
      <el-radio v-model="radio" label="ts">mpegts</el-radio>
      <el-radio v-model="radio" label="mkv">matroska</el-radio>
      <el-radio v-model="radio" label="oggs">oggs</el-radio>
      <el-radio v-model="radio" label="ivf">ivf</el-radio>
      <el-radio v-model="radio" label="mp3">mp3</el-radio>
    </div>
  </div>

  <button onclick="openReadFile()">打开读文件</button>
  <button onclick="openWriteFile()">打开写文件</button>

  <script src="../dist/format.js"></script>
  <script src="./vue.js" crossorigin></script>
  <script src="./element-ui.js" crossorigin></script>
  
  <script>

    let inputFormatComp;
    let outputFormatComp;

    inputFormatComp = new Vue({
      el: '#inputFormat',
      data: function () {
        return {
          radio: 'flv',
        }
      }
    })

    outputFormatComp = new Vue({
      el: '#outputFormat',
      data: function () {
        return {
          radio: 'flv',
        }
      }
    })

    function getInputFormat(format) {
      switch (format) {
        case 'flv':
          return new Format.Format.IFlvFormat()
        case 'mp4':
          return new Format.Format.IMovFormat()
        case 'ts':
          return new Format.Format.IMpegtsFormat()
        case 'ivf':
          return new Format.Format.IIvfFormat()
        case 'oggs':
          return new Format.Format.IOggsFormat()
        case 'mp3':
          return new Format.Format.IMp3Format()
        case 'mkv':
          return new Format.Format.IMatroskaFormat()
      }
    }

    function getOutputFormat(format) {
      switch (format) {
        case 'flv':
          return new Format.Format.OFlvFormat({
            hasKeyframes: true,
            live: false
          })
        case 'mp4':
          return new Format.Format.OMovFormat({
            fragmentMode: 1,
            fragment: true,
            fastOpen: false,
            movMode: 0,
            defaultBaseIsMoof: true
          })
        case 'ts':
          return new Format.Format.OMpegtsFormat({
            pesMaxSize: 0,
            patPeriod: 0,
            latm: false
          })
        case 'ivf':
          return new Format.Format.OIvfFormat()
        case 'oggs':
          return new Format.Format.OOggsFormat()
        case 'mp3':
          return new Format.Format.OMp3Format()
        case 'mkv':
         return new Format.Format.OMatroskaFormat()
      }
    }

    let openReadPromise;
    let openWritePromise;

    function process() {
      if (!openReadPromise || !openWritePromise) {
        return
      }

      const iformatContext = Format.createAVIFormatContext();
      const oformatContext = Format.createAVOFormatContext()
      const ioReader = new Format.IOReader();
      const ioWriter = new Format.IOWriter();
      const iformat = getInputFormat(inputFormatComp.radio);
      const oformat = getOutputFormat(outputFormatComp.radio);
      const packet = Format.util.createAVPacket();

      iformatContext.ioReader = ioReader;
      oformatContext.ioWriter = ioWriter;
      iformatContext.iformat = iformat;
      oformatContext.oformat = oformat;

      Promise.all([openReadPromise, openWritePromise]).then(async (value) => {

        const readFileHandler = value[0][0]
        const writeFileHandler = value[1]

        if (readFileHandler && writeFileHandler) {
          const fileIO = new Format.SafeFileIO(writeFileHandler);

          await fileIO.ready()

          const readFile = await readFileHandler.getFile()

          let readPos = 0;
          const readFileLength = readFile.size;

          ioReader.onFlush = async (buffer) => {
            if (readPos >= readFileLength) {
              return Format.IOError.END;
            }
            const len = Math.min(buffer.length, readFileLength - readPos);

            buffer.set(new Uint8Array(await (readFile.slice(readPos, readPos + len).arrayBuffer())), 0);

            readPos += len;

            return len;
          }
          ioReader.onSeek = (pos) => {
            readPos = Number(pos)
            return 0
          }

          ioReader.onSize = () => {
            return BigInt(readFile.size)
          }

          ioWriter.onFlush = (buffer, pos) => {
            if (pos != null) {
              fileIO.appendBufferByPosition(buffer.slice(0), Number(pos))
            }
            else {
              fileIO.write(buffer.slice(0))
            }
            return 0
          }
          ioWriter.onSeek = (pos) => {
            fileIO.seek(Number(pos))
            return 0
          }

          await Format.demux.open(iformatContext);
          
          await Format.demux.analyzeStreams(iformatContext);

          // 编码 timeBase 与解码 timeBase 一致
          iformatContext.streams.forEach(in_stream => {
            // if (in_stream.codecpar.codecType === 1) {
              const out_stream = oformatContext.createStream()
              out_stream.id = in_stream.id
              out_stream.index = in_stream.index
              Format.util.copyCodecParameters(out_stream.codecpar[Format.util.symbolStructAddress], in_stream.codecpar[Format.util.symbolStructAddress])
              out_stream.timeBase.num = in_stream.timeBase.num
              out_stream.timeBase.den = in_stream.timeBase.den
              out_stream.metadata = Object.assign({}, in_stream.metadata)
            // }
          })

          Format.mux.open(oformatContext)
          Format.mux.writeHeader(oformatContext)

          let index = 0
          console.log('start')
          const now = Date.now()
          while (1) {
            let ret = await Format.demux.readAVPacket(iformatContext, packet);
            if (ret !== 0) {
              if (ret === Format.IOError.END) {
                Format.mux.flush(oformatContext)
                Format.mux.writeTrailer(oformatContext)
                fileIO.close().then(() => {
                  console.log('write file end')
                  console.log('cost:', Date.now() - now)
                })

                iformatContext.destroy()
                oformatContext.destroy()
                Format.util.destroyAVPacket(packet)

                console.log('end')

                console.log(CHeap.Allocator.inspect())
              }
              break
            }

            // Format.probeAVPacket(packet)

            // console.log(`demux packet, pos: ${packet.pos}, index: ${packet.streamIndex}, dts: ${packet.dts}, pts: ${packet.pts}, duration: ${packet.duration}, size: ${packet.size}, keyframe: ${packet.flags & 0x01}, index: ${index++}`)

            Format.mux.writeAVPacket(oformatContext, packet)
          }
        }
      })
    }
    
    function openReadFile() {
      openReadPromise = window.showOpenFilePicker()
      process()
    }

    function openWriteFile() {
      openWritePromise = window.showSaveFilePicker({
        suggestedName: 'test_muxing.' + outputFormatComp.radio
      })
      process()
    }
  </script>
</body>
</html>