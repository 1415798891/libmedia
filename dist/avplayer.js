(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AVPlayer"] = factory();
	else
		root["AVPlayer"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/avrender/image/webgl/glsl/vertex.vert":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/glsl/vertex.vert ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 point;\nattribute vec4 color;\nvarying vec4 v_color;\n\nuniform mat4 rotateMatrix;\n\nvoid main(void){\n  gl_Position = rotateMatrix * vec4(point, 1.0);\n  v_color = color;\n}\n");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\nstruct Meta {\n  max: u32,\n  width: u32,\n  height: u32\n};\n\n@group(0) @binding(0) var<uniform> metaData: Meta;\n@group(0) @binding(1) var input: texture_2d<u32>;\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\n\n@compute @workgroup_size(8, 8) fn main(\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\n) {\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\n  if (x < metaData.width && y < metaData.height) {\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\n    var low = value & 0xff;\n    var high = (value >> 8) & 0xff;\n    value = (low << 8) | high;\n    var value_no: f32 = f32(value) / f32(metaData.max);\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\n  }\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\nstruct Meta {\n  max: u32,\n  width: u32,\n  height: u32\n};\n\n@group(0) @binding(0) var<uniform> metaData: Meta;\n@group(0) @binding(1) var input: texture_2d<u32>;\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\n\n@compute @workgroup_size(8, 8) fn main(\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\n) {\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\n  if (x < metaData.width && y < metaData.height) {\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\n    var value_no: f32 = f32(value) / f32(metaData.max);\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\n  }\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl":
/*!***************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/fragment/external.wgsl ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\n@group(0) @binding(1) var eTexture: texture_external;\n@group(0) @binding(2) var s: sampler;\n\n@fragment\nfn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {\n  return textureSampleBaseClampToEdge(eTexture, s, in_texcoord.xy);\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/vertex.wgsl":
/*!****************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/vertex.wgsl ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct PositionColorInput {\n    @location(0) in_position_3d: vec3<f32>,\n    @location(1) in_color_rgba: vec4<f32>\n};\n\nstruct PositionColorOutput {\n    @builtin(position) coords_output: vec4<f32>,\n    @location(0) color_output: vec4<f32>\n};\n\nstruct RotateMatrix {\n    matrix: mat4x4<f32>\n};\n\n@group(0) @binding(0) var<uniform> rotateMatrix: RotateMatrix;\n\n@vertex\nfn main(input: PositionColorInput) -> PositionColorOutput {\n    var output: PositionColorOutput;\n    output.color_output = input.in_color_rgba;\n    output.coords_output = rotateMatrix.matrix * vec4<f32>(input.in_position_3d, 1.0);\n    return output;\n}");

/***/ }),

/***/ "./src/audioresample/Resampler.ts":
/*!****************************************!*\
  !*** ./src/audioresample/Resampler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resampler)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__2 = "src/audioresample/Resampler.ts";




class Resampler {
    resampler;
    options;
    inputParameters;
    outputParameters;
    constructor(options) {
        this.options = options;
        this.resampler = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(input, output) {
        this.inputParameters = input;
        this.outputParameters = output;
        await this.resampler.run();
        const layout = cheap_stack__WEBPACK_IMPORTED_MODULE_1__.malloc(8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[10](layout, (input.layout ?? BigInt(0)));
        this.resampler.call('resample_set_input_parameters', input.sampleRate, input.channels, input.format, layout);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[10](layout, (output.layout ?? BigInt(0)));
        this.resampler.call('resample_set_output_parameters', output.sampleRate, output.channels, output.format, layout);
        cheap_stack__WEBPACK_IMPORTED_MODULE_1__.free(8);
        let ret = this.resampler.call('resample_init');
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`open resampler failed, ret: ${ret}`, cheap__fileName__2, 88);
        }
    }
    resample(input, output, numberOfFrames) {
        return this.resampler.call('resample_process', input, output, numberOfFrames);
    }
    close() {
        this.resampler.call('resample_destroy');
        this.resampler.destroy();
        this.resampler = null;
    }
    getInputPCMParameters() {
        return this.inputParameters;
    }
    getOutputPCMParameters() {
        return this.outputParameters;
    }
}


/***/ }),

/***/ "./src/audiostretchpitch/StretchPitcher.ts":
/*!*************************************************!*\
  !*** ./src/audiostretchpitch/StretchPitcher.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StretchPitcher)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/*
 * libmedia audio stretch and pitcher
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class StretchPitcher {
    processor;
    options;
    constructor(options) {
        this.options = options;
        this.processor = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(parameters) {
        await this.processor.run();
        this.processor.call('stretchpitch_init');
        this.processor.call('stretchpitch_set_channels', parameters.channels);
        this.processor.call('stretchpitch_set_samplerate', parameters.sampleRate);
    }
    setRate(rate) {
        this.processor.call('stretchpitch_set_rate', rate);
    }
    setRateChange(change) {
        this.processor.call('stretchpitch_set_rate_change', change);
    }
    setTempo(tempo) {
        this.processor.call('stretchpitch_set_tempo', tempo);
    }
    setTempoChange(change) {
        this.processor.call('stretchpitch_set_tempo_change', change);
    }
    setPitch(pitch) {
        this.processor.call('stretchpitch_set_pitch', pitch);
    }
    setPitchOctaves(pitch) {
        this.processor.call('stretchpitch_set_pitch_octaves', pitch);
    }
    setPitchSemiTones(pitch) {
        this.processor.call('stretchpitch_set_pitch_semi_tones', pitch);
    }
    sendSamples(input, nbSamples) {
        this.processor.call('stretchpitch_send_samples', input, nbSamples);
    }
    receiveSamples(output, maxSamples) {
        return this.processor.call('stretchpitch_receive_samples', output, maxSamples);
    }
    flush() {
        this.processor.call('stretchpitch_flush');
    }
    clear() {
        this.processor.call('stretchpitch_clear');
    }
    getUnprocessedSamplesCount() {
        return this.processor.call('stretchpitch_get_unprocessed_samples_num');
    }
    getInputOutputSamplesRatio() {
        return this.processor.call('stretchpitch_get_input_output_sample_ratio');
    }
    getLatency() {
        return this.processor.call('get_latency');
    }
    close() {
        this.processor.call('stretchpitch_destroy');
        this.processor.destroy();
        this.processor = null;
    }
}


/***/ }),

/***/ "./src/avcodec/codec/codec.ts":
/*!************************************!*\
  !*** ./src/avcodec/codec/codec.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodecId2String: () => (/* binding */ CodecId2String)
/* harmony export */ });
/*
 * libmedia  codec string map
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const CodecId2String = {
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 'mp3',
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 'mp4a.40',
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 'vorbis',
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 'flac',
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 'opus',
    [65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */]: 'ulaw',
    [65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */]: 'alaw',
    [226 /* AVCodecID.AV_CODEC_ID_AV1 */]: 'av01',
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 'avc1',
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 'hev1',
    [139 /* AVCodecID.AV_CODEC_ID_VP8 */]: 'vp8',
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 'vp09',
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 'mp4v'
};


/***/ }),

/***/ "./src/avcodec/function/getAudioCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getAudioCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");


function getAudioCodec(codecpar) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 40);
    let codec = _codec_codec__WEBPACK_IMPORTED_MODULE_1__.CodecId2String[codecId];
    if (codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        /*
         * mp4a.40.profile
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        codec = `${codec}.${profile}`;
    }
    return codec || 'unknown';
}


/***/ }),

/***/ "./src/avcodec/function/getHardwarePreference.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/function/getHardwarePreference.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHardwarePreference: () => (/* binding */ getHardwarePreference)
/* harmony export */ });
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia webcodec hardware preference different chrome version
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getHardwarePreference(enable) {
    if (enable) {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-hardware';
        }
        else {
            return 'allow';
        }
    }
    else {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-software';
        }
        else {
            return 'deny';
        }
    }
}


/***/ }),

/***/ "./src/avcodec/function/getVideoCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getVideoCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avformat/codecs/vp8 */ "./src/avformat/codecs/vp8.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");








function getVideoCodec(codecpar, extradata) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 40);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 44);
    if (!extradata && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12) !== 0) {
        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16));
    }
    let entry = _codec_codec__WEBPACK_IMPORTED_MODULE_2__.CodecId2String[codecId];
    let codec = '';
    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        /*
         * avc1.profile_idc.constraint_set.level_idc
         * 每个参数 1 个字节压缩成 16 进制
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        // High 10 Profile 会提示不支持，但是能解码出来
        if (profile === 110 /* H264Profile.kHigh10 */) {
            profile = 100 /* H264Profile.kHigh */;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02x%02x%02x', entry, profile & 0xff, extradata ? extradata[2] : 0, level & 0xff);
    }
    else if (codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        /**
         *
         * hev1.[general_profile_space?general_profile_idc].[general_profile_compatibility_flags( 十六进制）][general_tier_flag general_level_idc][constraint_flags( 十六进制）]
         * general_profile_space:
         *  A -> 1
         *  B -> 2
         *  C -> 3
         * empty -> 0
         *
         * general_tier_flag:
         *  L -> 0
         *  H -> 1
         *
         */
        let generalProfileSpace = 0;
        let generalProfileCompatibilityFlags = 0;
        let generalTierFlag = 0;
        let constraintFlags = 0;
        if (extradata?.length > 13) {
            generalProfileSpace = (extradata[1] >>> 6) & 0x03;
            generalTierFlag = (extradata[1] >>> 5) & 0x01;
            generalProfileCompatibilityFlags = extradata[2] | (extradata[3] << 8) | (extradata[4] << 16) | (extradata[5] << 24);
            // constraintFlags 目前只能使用 4 个 bit
            constraintFlags = extradata[6] & 0xf0;
        }
        const generalProfileSpaceMap = {
            0: '',
            1: 'A',
            2: 'B',
            3: 'C'
        };
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%s%d.%x.%s%d.%x', entry, generalProfileSpaceMap[generalProfileSpace], profile, generalProfileCompatibilityFlags, generalTierFlag === 0 ? 'L' : 'H', level, constraintFlags);
    }
    else if (codecId === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        /*
         * av01.profile.level+seqTier.bitDepth[.monochrome[.chromaSubsampling[.colorPrimaries[.colorPrimaries[.matrixCoefficients]]]]]
         * url: https://aomediacodec.github.io/av1-isobmff/#codecsparam
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#av1
         */
        if (extradata) {
            const params = avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_4__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%d.%02d%s.%02d.%d.%d%d%d', entry, params.profile, params.level, params.tier ? 'H' : 'M', params.bitDepth, params.monochrome, params.chromaSubsamplingX, params.chromaSubsamplingY, params.chromaSamplePosition);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%d.%02dM.08', entry, profile, level);
        }
    }
    else if (codecId === 139 /* AVCodecID.AV_CODEC_ID_VP8 */) {
        /*
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#videowebmcodecsvp08.00.41.08vorbis
         */
        if (extradata) {
            const params = avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_5__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08', entry, profile, level);
        }
        else {
            codec = entry;
        }
    }
    else if (codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        /*
         * vp09.profile.level.colorDepth.chromaSubsampling[.colorPrimaries[.transferCharacteristics[.matrixCoefficients[.blackLevel and color range]]]]
         * url: https://www.webmproject.org/vp9/mp4/#CodecsParameterString
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#webm
         */
        if (extradata) {
            const params = avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_7__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.%02d.%02d.%02d.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth, params.chromaSubsampling, params.colorPrimaries, params.colorTrc, params.colorSpace, params.fullRangeFlag);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08.00', entry, profile, level);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08.00', entry, 0, 40);
        }
    }
    else {
        codec = entry || 'unknown';
    }
    return codec;
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/AudioDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/AudioDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avcodec/wasmcodec/AudioDecoder.ts";



class WasmAudioDecoder {
    options;
    decoder;
    frame;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters) {
        await this.decoder.run();
        let ret = this.decoder.call('decoder_open', parameters, 0, 1);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`open audio decoder failed, ret: ${ret}`, cheap__fileName__0, 82);
        }
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/VideoDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/VideoDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avcodec/wasmcodec/VideoDecoder.ts";



class WasmVideoDecoder {
    options;
    decoder;
    frame;
    parameters;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, threadCount = 1) {
        await this.decoder.run();
        let ret = this.decoder.call('decoder_open', parameters, 0, threadCount);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__0, 119);
        }
        this.parameters = parameters;
        await this.decoder.childrenThreadReady();
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        this.parameters = 0;
    }
    setSkipFrameDiscard(discard) {
        this.decoder.call('decoder_discard', discard);
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/VideoDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/VideoDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var _function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");






class WebVideoDecoder {
    decoder;
    options;
    parameters;
    extradata;
    currentError;
    inputQueue;
    outputQueue;
    sort;
    keyframeRequire;
    constructor(options) {
        this.options = options;
        this.inputQueue = [];
        this.outputQueue = [];
        this.sort = common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari;
    }
    async output(frame) {
        if (this.sort) {
            let i = 0;
            for (; i < this.outputQueue.length; i++) {
                if (this.outputQueue[i].timestamp > frame.timestamp) {
                    this.outputQueue.splice(i, 0, frame);
                    break;
                }
            }
            if (i === this.outputQueue.length) {
                this.outputQueue.push(frame);
            }
            while (this.outputQueue.length > 2
                && this.outputQueue[0].timestamp === this.inputQueue[0]) {
                const output = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(output);
                }
                else {
                    output.close();
                }
                this.inputQueue.shift();
            }
        }
        else {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(frame);
            }
            else {
                frame.close();
            }
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters, buffer),
            description: this.extradata,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        });
        this.keyframeRequire = true;
    }
    async open(parameters) {
        this.currentError = null;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        this.parameters = parameters;
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 48),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 52),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 176) !== 2 /* BitFormat.ANNEXB */) ? this.extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new VideoDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.keyframeRequire = true;
        this.inputQueue.length = 0;
        this.outputQueue.length = 0;
    }
    decode(avpacket) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_5__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](element + 4)));
        }
        const timestamp = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8));
        const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
        if (this.keyframeRequire && !key) {
            return;
        }
        const videoChunk = new EncodedVideoChunk({
            type: key ? 'key' : 'delta',
            timestamp,
            data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28))
        });
        if (this.sort) {
            let i = 0;
            for (; i < this.inputQueue.length; i++) {
                if (this.inputQueue[i] > timestamp) {
                    this.inputQueue.splice(i, 0, timestamp);
                    break;
                }
            }
            if (i === this.inputQueue.length) {
                this.inputQueue.push(timestamp);
            }
        }
        try {
            this.decoder.decode(videoChunk);
        }
        catch (error) {
            return -1;
        }
        if (key) {
            this.keyframeRequire = false;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
        if (this.sort) {
            while (this.outputQueue.length) {
                const frame = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(frame);
                }
                else {
                    frame.close();
                }
            }
        }
        this.keyframeRequire = true;
    }
    close() {
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
        this.currentError = null;
        if (this.outputQueue?.length) {
            this.outputQueue.forEach((frame) => {
                frame.close();
            });
        }
        this.inputQueue = null;
        this.outputQueue = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    setSkipFrameDiscard(discard) {
    }
}


/***/ }),

/***/ "./src/avformat/AVFormatContext.ts":
/*!*****************************************!*\
  !*** ./src/avformat/AVFormatContext.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVIFormatContext: () => (/* binding */ createAVIFormatContext),
/* harmony export */   createAVOFormatContext: () => (/* binding */ createAVOFormatContext)
/* harmony export */ });
/* harmony import */ var _AVStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AVStream */ "./src/avformat/AVStream.ts");
/*
 * libmedia AVFormatContext
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVFormatContextInterval {
    packetBuffer;
    constructor() {
        this.packetBuffer = [];
    }
}
class AVFormatContext {
    metadataHeaderPadding = -1;
    streams;
    options;
    privateData;
    processPrivateData;
    iformat;
    oformat;
    // @ts-ignore
    ioReader;
    ioWriter;
    errorFlag;
    interval;
    streamIndex;
    constructor() {
        this.streams = [];
        this.errorFlag = 0;
        this.streamIndex = 0;
        this.interval = new AVFormatContextInterval();
        this.options = {};
        this.privateData = {};
    }
    getStreamById(id) {
        return this.streams.find((stream) => stream.id === id);
    }
    getStreamByIndex(index) {
        return this.streams.find((stream) => stream.index === index);
    }
    getStreamByMediaType(mediaType) {
        return this.streams.find((stream) => stream.codecpar?.codecType === mediaType);
    }
    createStream() {
        const stream = new _AVStream__WEBPACK_IMPORTED_MODULE_0__["default"]();
        stream.index = this.streamIndex++;
        stream.id = stream.index;
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
        return stream;
    }
    addStream(stream) {
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
    }
    removeStream(stream) {
        this.removeStreamByIndex(stream.index);
    }
    removeStreamById(id) {
        const index = this.streams.findIndex((stream) => stream.id === id);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    removeStreamByIndex(i) {
        const index = this.streams.findIndex((stream) => stream.index === i);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    destroy() {
        if (this.oformat) {
            this.oformat.destroy(this);
        }
        if (this.iformat) {
            this.iformat.destroy(this);
        }
        this.streams.forEach((stream) => {
            stream.destroy();
        });
        this.streams = [];
        this.interval = null;
        this.ioReader = this.ioWriter = null;
        this.oformat = this.iformat = null;
    }
}
/**
 * 创建 AVIFormatContext
 *
 * @returns
 */
function createAVIFormatContext() {
    return new AVFormatContext();
}
/**
 * 创建 AVOFormatContext
 *
 * @returns
 */
function createAVOFormatContext() {
    return new AVFormatContext();
}


/***/ }),

/***/ "./src/avformat/AVStream.ts":
/*!**********************************!*\
  !*** ./src/avformat/AVStream.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVStream)
/* harmony export */ });
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_struct_rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/struct/rational */ "./src/avutil/struct/rational.ts");





/**
 * from FFmpeg
 *
 */
class AVStream {
    /**
     * stream index in AVFormatContext
     */
    index = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Format-specific stream ID.
     * decoding: set by libavformat
     * encoding: set by the user, replaced by libavformat if left unset
     */
    id = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    privData = null;
    codecpar = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"], new avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"]());
    /**
     * An array of side data that applies to the whole stream (i.e. the
     * container does not allow it to change between packets).
     *
     * There may be no overlap between the side data in this array and side data
     * in the packets. I.e. a given side data is either exported by the muxer
     * (demuxing) / set by the caller (muxing) in this array, then it never
     * appears in the packets, or the side data is exported / sent through
     * the packets (always in the first packet where the value becomes known or
     * changes), then it does not appear in this array.
     *
     * - demuxing: Set by libavformat when the stream is created.
     * - muxing: May be set by the caller before write_header().
     *
     */
    sideData = {};
    /**
     * number of frames in this stream if known or 0
     */
    nbFrames = BigInt(0);
    metadata = {};
    /**
     * Decoding: duration of the stream, in stream time base.
     * If a source file does not specify a duration, but does specify
     * a bitrate, this value will be estimated from bitrate and file size.
     *
     * Encoding: May be set by the caller before avformat_write_header() to
     * provide a hint to the muxer about the estimated duration.
     */
    duration = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
     * Only set this if you are absolutely 100% sure that the value you set
     * it to really is the pts of the first frame.
     * This may be undefined (AV_NOPTS_VALUE).
     * @note The ASF header does NOT contain a correct start_time the ASF
     * demuxer must NOT set this.
     */
    startTime = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * 第一个 packet 的 dts
     */
    firstDTS = BigInt(0);
    /**
     * AV_DISPOSITION_* bit field
     */
    disposition = 0 /* AVDisposition.NONE */;
    /**
     *
     * 封装时间基
     *
     * decoding: set by libavformat
     * encoding: May be set by the caller before avformat_write_header() to
     *           provide a hint to the muxer about the desired timebase. In
     *           avformat_write_header(), the muxer will overwrite this field
     *           with the timebase that will actually be used for the timestamps
     *           written into the file (which may or may not be related to the
     *           user-provided one, depending on the format).
     */
    timeBase = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_rational__WEBPACK_IMPORTED_MODULE_3__.Rational);
    /**
     * 帧索引，可用于 seek
     */
    sampleIndexes = [];
    /**
     * pos 到 sample index 的映射
     */
    sampleIndexesPosMap = new Map();
    destroy() {
        if (this.codecpar) {
            this.codecpar.destroy();
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__["default"])(this.codecpar);
            this.codecpar = null;
        }
        if (this.timeBase) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__["default"])(this.timeBase);
            this.timeBase = null;
        }
        this.sampleIndexes.length = 0;
        this.sampleIndexesPosMap.clear();
    }
}


/***/ }),

/***/ "./src/avformat/bsf/AVBSFilter.ts":
/*!****************************************!*\
  !*** ./src/avformat/bsf/AVBSFilter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVBSFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");




class AVBSFilter {
    inCodecpar;
    inTimeBase;
    outCodecpar;
    init(codecpar, timeBase) {
        this.inCodecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(184);
        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_1__.copyCodecParameters)(this.inCodecpar, codecpar);
        this.inTimeBase = {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase + 4),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase)
        };
        return 0;
    }
    destroy() {
        if (this.inCodecpar) {
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_1__.freeCodecParameters)(this.inCodecpar);
            this.inCodecpar = 0;
        }
    }
}


/***/ }),

/***/ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/bsf/h2645/Annexb2AvccFilter.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Annexb2AvccFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _AVBSFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AVBSFilter */ "./src/avformat/bsf/AVBSFilter.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__6 = "src/avformat/bsf/h2645/Annexb2AvccFilter.ts";











class Annexb2AvccFilter extends _AVBSFilter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    cache;
    cached;
    init(codecpar, timeBase) {
        super.init(codecpar, timeBase);
        this.cache = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.createAVPacket)();
        this.cached = false;
        return 0;
    }
    destroy() {
        super.destroy();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.destroyAVPacket)(this.cache);
        this.cache = 0;
    }
    sendAVPacket(avpacket) {
        const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 80) === 1 /* h264.BitFormat.AVCC */ || !(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.isAnnexb)(buffer)) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.refAVPacket)(this.cache, avpacket);
        }
        else {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.copyAVPacketProps)(this.cache, avpacket);
            let convert;
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.inCodecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.inCodecpar + 4) === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */) {
                convert = _codecs_h264__WEBPACK_IMPORTED_MODULE_5__.annexb2Avcc(buffer);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.inCodecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                convert = _codecs_hevc__WEBPACK_IMPORTED_MODULE_6__.annexb2Avcc(buffer);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`not support for codecId: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.inCodecpar + 4)}`, cheap__fileName__6, 89);
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumWrite[15](this.cache + 80, 1 /* h264.BitFormat.AVCC */);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.addAVPacketData)(this.cache, convert.bufferPointer, convert.length);
            if (convert.key) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumWrite[15](this.cache + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.cache + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
            }
            if (convert.extradata) {
                const extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(convert.extradata.length);
                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memcpyFromUint8Array)(extradata, convert.extradata.length, convert.extradata);
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.addAVPacketSideData)(this.cache, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradata, convert.extradata.length);
            }
        }
        this.cached = true;
        return 0;
    }
    receiveAVPacket(avpacket) {
        if (this.cached) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.unrefAVPacket)(avpacket);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.refAVPacket)(avpacket, this.cache);
            this.cached = false;
            return 0;
        }
        else {
            return avutil_error__WEBPACK_IMPORTED_MODULE_10__.DATA_INVALID;
        }
    }
}


/***/ }),

/***/ "./src/avformat/codecs/av1.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/av1.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony export parseSequenceHeader */
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/av1syntax */ "./src/avutil/util/av1syntax.ts");
/*
 * libmedia av1 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 4) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 bit marker
 * - 7 bit version
 * - 3 bit profile
 * - 5 bit level
 * - 1 bit tier
 * - 1 bit bitdepth > 8
 * - 1 bit bitdepth == 12
 * - 1 bit monochrome
 * - 1 bit chroma_subsampling_x
 * - 1 bit chroma_subsampling_y
 * - 2 bit chroma_sample_position
 * - 8 bit padding
 *
 * @param header
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    // marker
    bitReader.readU1();
    // version
    bitReader.readU(7);
    const profile = bitReader.readU(3);
    const level = bitReader.readU(5);
    const tier = bitReader.readU1();
    let bitDepth = bitReader.readU1() ? 10 : 8;
    if (bitReader.readU1()) {
        bitDepth = 12;
    }
    const monochrome = bitReader.readU1();
    const chromaSubsamplingX = bitReader.readU1();
    const chromaSubsamplingY = bitReader.readU1();
    const chromaSamplePosition = bitReader.readU(2);
    return {
        profile,
        level,
        tier,
        bitDepth,
        monochrome,
        chromaSubsamplingX,
        chromaSubsamplingY,
        chromaSamplePosition
    };
}
/* eslint-disable camelcase */
function parseSequenceHeader(header) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](header.length);
    bitReader.appendBuffer(header);
    const seq_profile = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
    const still_picture = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    const reduced_still_picture_header = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let timing_info_present_flag = 0;
    let decoder_model_info_present_flag = 0;
    let initial_display_delay_present_flag = 0;
    let operating_points_cnt_minus_1 = 0;
    let operating_point_idc = [0];
    let seq_level_idx = [0];
    let seq_tier = [0];
    let decoder_model_present_for_this_op = [0];
    let initial_display_delay_present_for_this_op = [0];
    let initial_display_delay_minus_1 = [0];
    let buffer_delay_length_minus_1 = 0;
    let decoder_buffer_delay = [0];
    let encoder_buffer_delay = [0];
    let low_delay_mode_flag = [0];
    if (reduced_still_picture_header) {
        seq_level_idx[0] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
    }
    else {
        timing_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (timing_info_present_flag) {
            let num_units_in_display_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
            let time_scale = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
            let equal_picture_interval = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (equal_picture_interval) {
                let num_ticks_per_picture_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.uvlc(bitReader);
            }
            let decoder_model_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (decoder_model_info_present_flag) {
                buffer_delay_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
                let num_units_in_decoding_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
                let buffer_removal_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
                let frame_presentation_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
            }
        }
        else {
            decoder_model_info_present_flag = 0;
        }
        let initial_display_delay_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        let operating_points_cnt_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
        for (let i = 0; i <= operating_points_cnt_minus_1; i++) {
            operating_point_idc[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 12);
            seq_level_idx[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
            if (seq_level_idx[i] > 7) {
                seq_tier[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            }
            else {
                seq_tier[i] = 0;
            }
            if (decoder_model_info_present_flag) {
                decoder_model_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (decoder_model_present_for_this_op[i]) {
                    let n = buffer_delay_length_minus_1 + 1;
                    decoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
                    encoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
                    low_delay_mode_flag[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                }
            }
            else {
                decoder_model_present_for_this_op[i] = 0;
            }
            if (initial_display_delay_present_flag) {
                initial_display_delay_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (initial_display_delay_present_for_this_op[i]) {
                    initial_display_delay_minus_1[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
                }
            }
        }
    }
    let frame_width_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
    let frame_height_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
    let n = frame_width_bits_minus_1 + 1;
    let max_frame_width_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
    n = frame_height_bits_minus_1 + 1;
    let max_frame_height_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
    let frame_id_numbers_present_flag = 0;
    let delta_frame_id_length_minus_2 = 0;
    let additional_frame_id_length_minus_1 = 0;
    if (reduced_still_picture_header) {
        frame_id_numbers_present_flag = 0;
    }
    else {
        frame_id_numbers_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    if (frame_id_numbers_present_flag) {
        delta_frame_id_length_minus_2 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
        additional_frame_id_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
    }
    let use_128x128_superblock = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_filter_intra = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_intra_edge_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_interintra_compound = 0;
    let enable_masked_compound = 0;
    let enable_warped_motion = 0;
    let enable_dual_filter = 0;
    let enable_order_hint = 0;
    let enable_jnt_comp = 0;
    let enable_ref_frame_mvs = 0;
    let seq_force_screen_content_tools = 2;
    let seq_force_integer_mv = 2;
    let OrderHintBits = 0;
    if (!reduced_still_picture_header) {
        let enable_interintra_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_masked_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_warped_motion = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_dual_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_order_hint = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (enable_order_hint) {
            enable_jnt_comp = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            enable_ref_frame_mvs = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        }
        else {
            enable_jnt_comp = 0;
            enable_ref_frame_mvs = 0;
        }
        let seq_choose_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (seq_choose_screen_content_tools) {
            seq_force_screen_content_tools = 2;
        }
        else {
            seq_force_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        }
        if (seq_force_screen_content_tools > 0) {
            let seq_choose_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (seq_choose_integer_mv) {
                seq_force_integer_mv = 2;
            }
            else {
                seq_force_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            }
        }
        else {
            seq_force_integer_mv = 2;
        }
        if (enable_order_hint) {
            const order_hint_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
            OrderHintBits = order_hint_bits_minus_1 + 1;
        }
        else {
            OrderHintBits = 0;
        }
    }
    let enable_superres = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_cdef = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_restoration = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let high_bitdepth = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let twelve_bit = 0;
    let bit_depth = 0;
    let mono_chrome = 0;
    if (seq_profile == 2 && high_bitdepth) {
        twelve_bit = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        bit_depth = twelve_bit ? 12 : 10;
    }
    else if (seq_profile <= 2) {
        bit_depth = high_bitdepth ? 10 : 8;
    }
    if (seq_profile == 1) {
        mono_chrome = 0;
    }
    else {
        mono_chrome = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    const color_description_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let color_primaries = 0;
    let transfer_characteristics = 0;
    let matrix_coefficients = 0;
    if (color_description_present_flag) {
        color_primaries = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
        transfer_characteristics = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
        matrix_coefficients = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
    }
    else {
        color_primaries = 2;
        transfer_characteristics = 2;
        matrix_coefficients = 2;
    }
    let color_range = 0;
    let subsampling_x = 0;
    let subsampling_y = 0;
    let chroma_sample_position = 0;
    let separate_uv_delta_q = 0;
    if (mono_chrome) {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        subsampling_x = 1;
        subsampling_y = 1;
        chroma_sample_position = 0;
        separate_uv_delta_q = 0;
    }
    else if (color_primaries == 1
        && transfer_characteristics == 13
        && matrix_coefficients == 0) {
        color_range = 1;
        subsampling_x = 0;
        subsampling_y = 0;
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    else {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (seq_profile == 0) {
            subsampling_x = 1;
            subsampling_y = 1;
        }
        else if (seq_profile == 1) {
            subsampling_x = 0;
            subsampling_y = 0;
        }
        else {
            if (bit_depth == 12) {
                subsampling_x = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (subsampling_x) {
                    subsampling_y = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                }
                else {
                    subsampling_y = 0;
                }
            }
            else {
                subsampling_x = 1;
                subsampling_y = 0;
            }
        }
        if (subsampling_x && subsampling_y) {
            chroma_sample_position = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 2);
        }
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    let film_grain_params_present = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    return {
        width: max_frame_width_minus_1 + 1,
        height: max_frame_height_minus_1 + 1,
        profile: seq_profile,
        level: seq_level_idx[0],
        tier: seq_tier[0],
        bitDepth: bit_depth,
        monoChrome: mono_chrome,
        colorRange: color_range,
        colorPrimaries: color_primaries,
        transferCharacteristics: transfer_characteristics,
        matrixCoefficients: matrix_coefficients
    };
}


/***/ }),

/***/ "./src/avformat/codecs/h264.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/h264.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData)
/* harmony export */ });
/* unused harmony exports NALULengthSizeMinusOne, extradata2SpsPps, spsPps2Extradata, avcc2Annexb, parserSPS */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
var cheap__fileName__0 = "src/avformat/codecs/h264.ts";


/*
 * libmedia h264 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const NALULengthSizeMinusOne = 3;
/**
 *
 * avcc 格式的 extradata 转 annexb sps pps
 *
 * bits
 * - 8   version ( always 0x01 )
 * - 8   avc profile ( sps[0][1] )
 * - 8   avc compatibility ( sps[0][2] )
 * - 8   avc level ( sps[0][3] )
 * - 6   reserved ( all bits on )
 * - 2   NALULengthSizeMinusOne
 * - 3   reserved ( all bits on )
 * - 5   number of SPS NALUs (usually 1)
 * - repeated once per SPS:
 *   - 16         SPS size
 *   - variable   SPS NALU data
 * - 8 number of PPS NALUs (usually 1)
 * - repeated once per PPS:
 *   - 16       PPS size
 *   - variable PPS NALU data
 *
 * - ext (profile !== 66 && profile !== 77 && profile !== 88)
 *  - 6 reserved ( all bits on )
 *  - 2 chroma_format_idc
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_luma_minus8
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_chroma_minus8
 *  - 8 number of SPS_EXT NALUs
 *    - 16 SPS_EXT size
 *    - variable   SPS_EXT NALU data
 *
 */
function extradata2SpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata);
    bufferReader.skip(5);
    const spss = [];
    const ppss = [];
    const spsExts = [];
    const spsLength = bufferReader.readUint8() & 0x1f;
    for (let i = 0; i < spsLength; i++) {
        const length = bufferReader.readUint16();
        spss.push(bufferReader.readBuffer(length));
    }
    const ppsLength = bufferReader.readUint8();
    for (let i = 0; i < ppsLength; i++) {
        const length = bufferReader.readUint16();
        ppss.push(bufferReader.readBuffer(length));
    }
    if (bufferReader.remainingSize() > 4) {
        bufferReader.skip(3);
        const spsExtLength = bufferReader.readUint8();
        if (spsExtLength > 0) {
            for (let i = 0; i < spsExtLength; i++) {
                const length = bufferReader.readUint16();
                spsExts.push(bufferReader.readBuffer(length));
            }
        }
    }
    return {
        spss,
        ppss,
        spsExts
    };
}
function spsPps2Extradata(spss, ppss, spsExts = []) {
    if (spss.length > 32) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn(`h264 metadata\'s sps max length is 32, but get ${spss.length}`, cheap__fileName__0, 159);
        spss = spss.slice(0, 32);
    }
    if (spss.length > 256) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn(`h264 metadata\'s pps max length is 256, but get ${spss.length}`, cheap__fileName__0, 163);
        spss = spss.slice(0, 256);
    }
    let length = 7;
    length = spss.reduce((prev, sps) => {
        return prev + 2 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 2 + pps.length;
    }, length);
    const sps = spss[0];
    const params = parserSPS(sps);
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        length += 4;
        if (spsExts.length) {
            length = spsExts.reduce((prev, ext) => {
                return prev + 2 + ext.length;
            }, length);
        }
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"](buffer);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(0xfc | NALULengthSizeMinusOne);
    // sps
    bufferWriter.writeUint8(0xe0 | (spss.length & 0x1f));
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spss, (sps) => {
        bufferWriter.writeUint16(sps.length);
        bufferWriter.writeBuffer(sps);
    });
    // pps
    bufferWriter.writeUint8(ppss.length);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(ppss, (pps) => {
        bufferWriter.writeUint16(pps.length);
        bufferWriter.writeBuffer(pps);
    });
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        bufferWriter.writeUint8(0xfc | params.chromaFormatIdc);
        bufferWriter.writeUint8(0xf8 | params.bitDepthLumaMinus8);
        bufferWriter.writeUint8(0xf8 | params.bitDepthChromaMinus8);
        if (spsExts.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spsExts, (ext) => {
                bufferWriter.writeUint16(ext.length);
                bufferWriter.writeBuffer(ext);
            });
        }
    }
    return buffer;
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.splitNaluByStartCode)(data);
    let extradata;
    let key = false;
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = spsPps2Extradata(spss, ppss, spsExts);
        }
        nalus = nalus.filter((nalu) => {
            const type = nalu[0] & 0x1f;
            return type !== 9 /* H264NaluType.kSliceAUD */
                && type !== 8 /* H264NaluType.kSlicePPS */
                && type !== 7 /* H264NaluType.kSliceSPS */
                && type !== 13 /* H264NaluType.kSPSExt */;
        });
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        key,
        extradata
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[4] & 0x03) : NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let key = false;
    if (extradata) {
        const result = extradata2SpsPps(extradata);
        spss = result.spss;
        ppss = result.ppss;
        spsExts = result.spsExts;
        key = true;
    }
    const nalus = [];
    const seis = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 6 /* H264NaluType.kSliceSEI */) {
            seis.push(nalu);
        }
        else if (naluType !== 9 /* H264NaluType.kSliceAUD */) {
            nalus.push(nalu);
        }
    }
    let length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, 0);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = spsExts.reduce((prev, ext) => {
        return prev + 4 + ext.length;
    }, length);
    length = seis.reduce((prev, sei) => {
        return prev + 4 + sei.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length + 6);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"]((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 6));
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x09);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(seis, (sei) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sei);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spsExts, (ext) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(ext);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 6,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let others = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 7 /* H264NaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 8 /* H264NaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 13 /* H264NaluType.kSPSExt */) {
            spsExts.push(nalu);
        }
        else {
            others.push(nalu);
        }
    }
    if (spss.length || ppss.length) {
        const extradata = spsPps2Extradata(spss, ppss, spsExts);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            const extradata = spsPps2Extradata(spss, ppss, spsExts);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[4] & 0x03);
        const { spss } = extradata2SpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parserSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function parserSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_10__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nal_ref_idc
    bitReader.readU(2);
    // nal_unit_type
    bitReader.readU(5);
    const profile = bitReader.readU(8);
    // constraint_set0_flag
    bitReader.readU1();
    // constraint_set1_flag
    bitReader.readU1();
    // constraint_set2_flag
    bitReader.readU1();
    // constraint_set3_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // reserved_zero_2bits
    bitReader.readU(2);
    const level = bitReader.readU(8);
    // seq_parameter_set_id
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // 摄像机出图大部分格式是 4:2:0
    let chromaFormatIdc = 1;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    if (profile == 100 || profile == 110 || profile == 122
        || profile == 244 || profile == 44 || profile == 83
        || profile == 86 || profile == 118 || profile == 128
        || profile == 138 || profile == 139 || profile == 134 || profile == 135) {
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU1();
        }
        // bit_depth_luma_minus8
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // bit_depth_chroma_minus8
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // qpprime_y_zero_transform_bypass_flag
        bitReader.readU1();
        let seqScalingMatrixPresentFlag = bitReader.readU1();
        if (seqScalingMatrixPresentFlag) {
            const seqScalingListPresentFlag = new Array(8);
            for (let i = 0; i < ((chromaFormatIdc != 3) ? 8 : 12); i++) {
                seqScalingListPresentFlag[i] = bitReader.readU1();
            }
        }
    }
    // log2_max_frame_num_minus4
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picOrderCntType = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    if (picOrderCntType === 0) {
        // log2_max_pic_order_cnt_lsb_minus4
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    }
    else if (picOrderCntType === 1) {
        // delta_pic_order_always_zero_flag
        bitReader.readU1();
        // offset_for_non_ref_pic
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        // offset_for_top_to_bottom_field
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        const numRefFramesInPicOrderCntCycle = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        }
    }
    // max_num_ref_frames
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // gaps_in_frame_num_value_allowed_flag
    bitReader.readU1();
    const picWidthInMbsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picHeightInMapUnitsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const frameMbsOnlyFlag = bitReader.readU1();
    let width = (picWidthInMbsMinus1 + 1) * 16;
    let height = (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16;
    if (!frameMbsOnlyFlag) {
        // mb_adaptive_frame_field_flag
        bitReader.readU1();
    }
    // direct_8x8_inference_flag
    bitReader.readU1();
    const frameCroppingFlag = bitReader.readU1();
    if (frameCroppingFlag) {
        const frameCropLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        let cropUnitX = 1;
        let cropUnitY = 2 - frameCroppingFlag;
        if (chromaFormatIdc === 1) {
            cropUnitX = 2;
            cropUnitY = 2 * (2 - frameCroppingFlag);
        }
        else if (frameCroppingFlag === 2) {
            cropUnitX = 2;
            cropUnitY = 2 - frameCroppingFlag;
        }
        width -= cropUnitX * (frameCropLeftOffset + frameCropRightOffset);
        height -= cropUnitY * (frameCropTopOffset + frameCropBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8
    };
}


/***/ }),

/***/ "./src/avformat/codecs/hevc.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/hevc.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData)
/* harmony export */ });
/* unused harmony exports extradata2VpsSpsPps, vpsSpsPps2Extradata, avcc2Annexb, parserSPS */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");


/*
 * libmedia hevc util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */









const NALULengthSizeMinusOne = 3;
/**
 *
 * hvcc 格式的 extradata 转 annexb vps sps pps
 *
 * bits
 * - 8   configurationVersion( 固定   1)
 * - 2   general_profile_space
 * - 1   general_tier_flag
 * - 5   general_profile_idc
 * - 32  general_profile_compatibility_flags
 * - 48  general_constraint_indicator_flags (6 个 字节）
 * - 8   general_level_idc
 * - 4   reserved1 (1111)
 * - 4   min_spatial_segmentation_idc_L
 * - 8   min_spatial_segmentation_idc_H
 * - 6   reserved2 (111111)
 * - 2   parallelismType
 * - 6   reserved3 (111111)
 * - 2   chromaFormat
 * - 5   reserved4 (11111)
 * - 3   bitDepthLumaMinus8
 * - 5   reserved5(11111)
 * - 3   bitDepthChromaMinus8
 * - 16  avgFrameRate
 * - 2   constantFrameRate
 * - 3   numTemporalLayers
 * - 1   temporalIdNested
 * - 2   lengthSizeMinusOne
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 1   reserved (0)
 * - 6   NAL_unit_type
 * - 16  numNalus
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata, true);
    bufferReader.skip(22);
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x3f;
        const count = bufferReader.readUint16();
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss = list;
        }
        else if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss = list;
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let length = 23;
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer, true);
    const spsData = parserSPS(sps);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(sps[4]);
    bufferWriter.writeUint8(sps[5]);
    // general_constraint_indicator_flags
    bufferWriter.writeUint8(sps[6]);
    bufferWriter.writeUint8(sps[7]);
    bufferWriter.writeUint8(sps[8]);
    bufferWriter.writeUint8(sps[9]);
    bufferWriter.writeUint8(sps[10]);
    bufferWriter.writeUint8(sps[11]);
    bufferWriter.writeUint8(spsData.level);
    // min_spatial_segmentation_idc
    bufferWriter.writeUint8((1020) | 0);
    bufferWriter.writeUint8(0);
    // parallelismType
    bufferWriter.writeUint8((16320) | 0);
    // chromaFormat
    bufferWriter.writeUint8((16320) | spsData.chromaFormatIdc);
    // bitDepthLumaMinus8
    bufferWriter.writeUint8((8160) | spsData.bitDepthLumaMinus8);
    // bitDepthChromaMinus8
    bufferWriter.writeUint8((8160) | spsData.bitDepthChromaMinus8);
    // avgFrameRate
    bufferWriter.writeUint16(0);
    // constantFrameRate numTemporalLayers temporalIdNested lengthSizeMinusOne
    bufferWriter.writeUint8((0) | (8) | ((sps[0] & 0x01) << 2) | NALULengthSizeMinusOne);
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 32 /* HEVCNaluType.kSliceVPS */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 33 /* HEVCNaluType.kSliceSPS */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 34 /* HEVCNaluType.kSlicePPS */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[0] >>> 1) & 0x3f;
                return type !== 32 /* HEVCNaluType.kSliceVPS */
                    && type !== 33 /* HEVCNaluType.kSliceSPS */
                    && type !== 34 /* HEVCNaluType.kSlicePPS */
                    && type !== 35 /* HEVCNaluType.kSliceAUD */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[21] & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(35 /* HEVCNaluType.kSliceAUD */ << 1);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = (nalu[0] >>> 1) & 0x3f;
        if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[21] & 0x03);
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parserSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function parserSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    let chromaFormatIdc = 1;
    let generalProfileSpace = 0;
    let generalTierFlag = 0;
    let generalProfileCompatibilityFlag = 0;
    let constraintFlags = 0;
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_9__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nalu type
    bitReader.readU(6);
    // layerId
    bitReader.readU(6);
    // tid
    bitReader.readU(3);
    // sps_video_parameter_set_id
    bitReader.readU(4);
    // The value of sps_max_sub_layers_minus1 shall be in the range of 0 to 6, inclusive.
    const spsMaxSubLayersMinus1 = bitReader.readU(3);
    // sps_temporal_id_nesting_flag
    bitReader.readU1();
    if (spsMaxSubLayersMinus1 <= 6) {
        // profile_tier_level(sps_max_sub_layers_minus1)
        // general_profile_space
        generalProfileSpace = bitReader.readU(2);
        // general_tier_flag
        generalTierFlag = bitReader.readU1();
        // general_profile_idc
        profile = bitReader.readU(5);
        // general_profile_compatibility_flag[32]
        generalProfileCompatibilityFlag = bitReader.readU(32);
        /**
         * 1 general_progressive_source_flag
         * 1 general_interlaced_source_flag
         * 1 general_non_packed_constraint_flag
         * 1 general_frame_only_constraint_flag
         * 44 general_reserved_zero_44bits
         */
        constraintFlags = bitReader.readU(48);
        // general_level_idc
        level = bitReader.readU(8);
        const subLayerProfilePresentFlag = new Array(6);
        const subLayerLevelPresentFlag = new Array(6);
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            subLayerProfilePresentFlag[i] = bitReader.readU1();
            subLayerLevelPresentFlag[i] = bitReader.readU1();
        }
        if (spsMaxSubLayersMinus1 > 0) {
            for (let i = spsMaxSubLayersMinus1; i < 8; i++) {
                // reserved_zero_2bits
                bitReader.readU(2);
            }
        }
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            if (subLayerProfilePresentFlag[i]) {
                // sub_layer_profile_space[i]
                bitReader.readU(2);
                // sub_layer_tier_flag[i]
                bitReader.readU(1);
                // sub_layer_profile_idc[i]
                bitReader.readU(5);
                // sub_layer_profile_compatibility_flag[i][32]
                bitReader.readU(32);
                // sub_layer_progressive_source_flag[i]
                bitReader.readU(1);
                // sub_layer_interlaced_source_flag[i]
                bitReader.readU(1);
                // sub_layer_non_packed_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_frame_only_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_reserved_zero_44bits[i]
                bitReader.readU(44);
            }
            if (subLayerLevelPresentFlag[i]) {
                // sub_layer_level_idc[i]
                bitReader.readU(8);
            }
        }
        // "The  value  of sps_seq_parameter_set_id shall be in the range of 0 to 15, inclusive."
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU(1);
        }
        width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const conformanceWindowFlag = bitReader.readU1();
        let confWinLeftOffset = 0;
        let confWinRightOffset = 0;
        let confWinTopOffset = 0;
        let confWinBottomOffset = 0;
        if (conformanceWindowFlag) {
            confWinLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        }
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        let SubWidthC = 2;
        let SubHeightC = 2;
        if (chromaFormatIdc === 0) {
            SubWidthC = SubHeightC = 0;
        }
        else if (chromaFormatIdc === 2) {
            SubWidthC = 2;
            SubHeightC = 1;
        }
        else if (chromaFormatIdc === 3) {
            SubWidthC = SubHeightC = 1;
        }
        const cropUnitX = SubWidthC * (1 << (bitDepthLumaMinus8 + 1));
        const cropUnitY = SubHeightC * (1 << (bitDepthLumaMinus8 + 1));
        width -= cropUnitX * (confWinLeftOffset + confWinRightOffset);
        height -= cropUnitY * (confWinTopOffset + confWinBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8,
        generalProfileSpace,
        generalTierFlag,
        generalProfileCompatibilityFlag,
        constraintFlags
    };
}


/***/ }),

/***/ "./src/avformat/codecs/vp8.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp8.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia vp8 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata.subarray(4));
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}


/***/ }),

/***/ "./src/avformat/codecs/vp9.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp9.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia vp9 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata.subarray(4));
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}


/***/ }),

/***/ "./src/avformat/config.ts":
/*!********************************!*\
  !*** ./src/avformat/config.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DURATION_MAX_READ_SIZE: () => (/* binding */ DURATION_MAX_READ_SIZE),
/* harmony export */   SAMPLE_INDEX_STEP: () => (/* binding */ SAMPLE_INDEX_STEP)
/* harmony export */ });
/*
 * libmedia avformat config
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DURATION_MAX_READ_SIZE = 256000;
const SAMPLE_INDEX_STEP = BigInt(5000);


/***/ }),

/***/ "./src/avformat/demux.ts":
/*!*******************************!*\
  !*** ./src/avformat/demux.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   analyzeStreams: () => (/* binding */ analyzeStreams),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   readAVPacket: () => (/* binding */ readAVPacket),
/* harmony export */   seek: () => (/* binding */ seek)
/* harmony export */ });
/* unused harmony export DefaultDemuxOptions */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./function/checkStreamParameters */ "./src/avformat/function/checkStreamParameters.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ "./src/avformat/config.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/demux.ts";












const DefaultDemuxOptions = {
    fastOpen: false,
    maxAnalyzeDuration: 1000
};
// @ts-ignore
async function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, DefaultDemuxOptions, options);
    if (!formatContext.ioReader) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need IOReader', cheap__fileName__0, 62);
    }
    if (!formatContext.iformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need iformat', cheap__fileName__0, 65);
    }
    if (formatContext.iformat.type === 2 /* AVFormat.MPEGTS */) {
        // mpegts 的最小分析时长为 2 秒，mpegts 的 dts 一般从 1.4 秒开始
        opts.maxAnalyzeDuration = Math.max(opts.maxAnalyzeDuration, 2000);
    }
    formatContext.iformat.init(formatContext);
    formatContext.options = opts;
    return formatContext.iformat.readHeader(formatContext);
}
// @ts-ignore
async function estimateDurationFromPts(formatContext) {
    const fileSize = await formatContext.ioReader.fileSize();
    if (fileSize <= BigInt(0)) {
        return;
    }
    const cache = formatContext.interval.packetBuffer;
    formatContext.interval.packetBuffer = [];
    let now = formatContext.ioReader.getPos();
    let retry = 0;
    while (retry < 4) {
        const pos = fileSize - BigInt(Math.floor(_config__WEBPACK_IMPORTED_MODULE_2__.DURATION_MAX_READ_SIZE << retry));
        const nextPos = await formatContext.iformat.seek(formatContext, null, pos, 2 /* AVSeekFlags.BYTE */);
        if (nextPos > BigInt(0)) {
            now = nextPos;
        }
        const lastDurationMap = {};
        const avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        while (true) {
            const ret = await readAVPacket(formatContext, avpacket);
            if (ret < 0) {
                break;
            }
            else {
                let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
                const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
                if (stream.startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT) {
                    duration -= stream.startTime;
                }
                else {
                    duration -= stream.firstDTS;
                }
                if (duration > BigInt(0)) {
                    if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT
                        || !lastDurationMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32)]
                        || (stream.duration < duration
                            && Math.abs(Number(duration - stream.duration)) < 60 * stream.timeBase.den / stream.timeBase.num)) {
                        stream.duration = duration;
                    }
                    lastDurationMap[avpacket.streamIndex] = duration;
                }
            }
        }
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
        let hasDuration = true;
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.streams, (stream) => {
            if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT) {
                hasDuration = false;
                return false;
            }
        });
        if (hasDuration) {
            break;
        }
        retry++;
    }
    common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
    });
    formatContext.interval.packetBuffer = cache;
    await formatContext.iformat.seek(formatContext, null, now, 2 /* AVSeekFlags.BYTE */);
}
// @ts-ignore
async function analyzeStreams(formatContext) {
    const needStreams = formatContext.iformat.getAnalyzeStreamsCount();
    const streamFirstGotMap = {};
    const streamDtsMap = {};
    const streamBitMap = {};
    let avpacket = 0;
    const caches = [];
    let ret = 0;
    while (true) {
        if (formatContext.streams.length >= needStreams
            && (0,_function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__.checkStreamParameters)(formatContext)
            && formatContext.options.fastOpen) {
            break;
        }
        if (!avpacket) {
            avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        }
        let packetCached = false;
        ret = await readAVPacket(formatContext, avpacket);
        if (ret !== 0) {
            break;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28)) {
            packetCached = true;
            caches.push(avpacket);
            if (!streamFirstGotMap[stream.index]) {
                stream.firstDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16);
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
                streamFirstGotMap[stream.index] = true;
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) < stream.startTime) {
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
            }
            if (streamDtsMap[stream.index]) {
                streamDtsMap[stream.index].push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16));
            }
            else {
                streamDtsMap[stream.index] = [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16)];
            }
            if (streamBitMap[stream.index]) {
                streamBitMap[stream.index] += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28);
            }
            else {
                streamBitMap[stream.index] = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28);
            }
        }
        if (streamDtsMap[stream.index] && streamDtsMap[stream.index].length === 12) {
            let count = BigInt(0);
            for (let i = 1; i < streamDtsMap[stream.index].length; i++) {
                count += streamDtsMap[stream.index][i] - streamDtsMap[stream.index][i - 1];
            }
            let value = Number(count) / (streamDtsMap[stream.index].length - 1);
            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && stream.codecpar.sampleRate > 0) {
                stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
            }
            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                stream.codecpar.framerate.num = stream.timeBase.den * stream.timeBase.num;
                stream.codecpar.framerate.den = value >>> 0;
            }
            const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
            stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.startTime) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(BigInt(Math.floor(formatContext.options.maxAnalyzeDuration)), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q, stream.timeBase)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_0__.each(streamDtsMap, (list, id) => {
                const stream = formatContext.getStreamById(+id);
                if (list && list.length > 1) {
                    let count = BigInt(0);
                    for (let i = 1; i < list.length; i++) {
                        count += list[i] - list[i - 1];
                    }
                    let value = Number(count) / (streamDtsMap[stream.index].length - 1);
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && stream.codecpar.sampleRate > 0) {
                        stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        stream.codecpar.framerate.num = stream.timeBase.den * stream.timeBase.num;
                        stream.codecpar.framerate.den = value >>> 0;
                    }
                    const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
                    stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
                }
            });
            if (packetCached) {
                avpacket = 0;
            }
            break;
        }
        if (packetCached) {
            avpacket = 0;
        }
    }
    if (avpacket) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
    }
    if (caches.length) {
        formatContext.interval.packetBuffer = caches.concat(formatContext.interval.packetBuffer);
    }
    if (ret === -1048576 /* IOError.END */) {
        return 0;
    }
    else if (ret !== 0) {
        return ret;
    }
    if (formatContext.iformat.type === 2 /* AVFormat.MPEGTS */ && (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */)) {
        await estimateDurationFromPts(formatContext);
    }
    return 0;
}
function addSample(stream, avpacket) {
    const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
        if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8)) {
            return 1;
        }
        else {
            return -1;
        }
    });
    const sample = {
        dts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16),
        pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8),
        pos: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56),
        size: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28),
        duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 48),
        flags: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36)
    };
    if (index > -1) {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56), index);
        stream.sampleIndexes.splice(index, 0, sample);
    }
    else {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56), stream.sampleIndexes.length);
        stream.sampleIndexes.push(sample);
    }
}
// @ts-ignore
async function packetNeedRead(formatContext, avpacket) {
    const stream = formatContext.getStreamById(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
    let ret = 0;
    // h264 hevc aac 解析到 extradata，继续
    if (stream
        && (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */)) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28)
            && (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.hasAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */)) {
            while (1) {
                const tmpPacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
                ret = await formatContext.iformat.readAVPacket(formatContext, tmpPacket);
                if (ret !== 0) {
                    if (formatContext.interval.packetBuffer.length) {
                        let cache = formatContext.interval.packetBuffer.shift();
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, cache);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(cache);
                        return packetNeedRead(formatContext, avpacket);
                    }
                    return ret;
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](tmpPacket + 32) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32)) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](tmpPacket + 28)) {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.copyAVPacketData)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(tmpPacket);
                        return 0;
                    }
                    else {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(tmpPacket);
                        continue;
                    }
                }
                else {
                    formatContext.interval.packetBuffer.push(tmpPacket);
                }
            }
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 32 /* AVPacketFlags.AV_PKT_FLAG_END */) {
            return readAVPacket(formatContext, avpacket);
        }
    }
    if (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */) {
        if (!stream.sampleIndexesPosMap.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56))) {
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    addSample(stream, avpacket);
                }
            }
            else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
                    if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8)) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                });
                if (!stream.sampleIndexes.length
                    || (index < 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[stream.sampleIndexes.length - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_10__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)
                    || (index > 0
                        && index < stream.sampleIndexes.length - 1
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[index - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_10__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)
                    || (index === 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.sampleIndexes[0].pts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_10__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)) {
                    addSample(stream, avpacket);
                }
            }
        }
    }
    return 0;
}
// @ts-ignore
async function readAVPacket(formatContext, avpacket) {
    let ret = 0;
    (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
    if (formatContext.interval.packetBuffer.length) {
        const cache = formatContext.interval.packetBuffer.shift();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, cache);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(cache);
        return packetNeedRead(formatContext, avpacket);
    }
    ret = await formatContext.iformat.readAVPacket(formatContext, avpacket);
    if (ret !== 0) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
        return ret;
    }
    return packetNeedRead(formatContext, avpacket);
}
// @ts-ignore
async function seek(formatContext, streamIndex, timestamp, flags) {
    let stream = formatContext.streams[streamIndex];
    if (!stream) {
        stream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (!stream) {
            stream = formatContext.getStreamByMediaType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
        }
    }
    if (!stream) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error(`not found any stream to seek, streamIndex: ${stream.index}`, cheap__fileName__0, 456);
        return BigInt(avutil_error__WEBPACK_IMPORTED_MODULE_11__.DATA_INVALID);
    }
    common_util_logger__WEBPACK_IMPORTED_MODULE_1__.debug(`seek in ${stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
        ? 'video'
        : 'audio'} stream, streamIndex: ${stream.index}, timestamp: ${timestamp}, flags: ${flags}`, cheap__fileName__0, 460);
    timestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(timestamp, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q, stream.timeBase);
    const ret = await formatContext.iformat.seek(formatContext, stream, timestamp, flags);
    if (ret >= BigInt(0)) {
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
        });
        formatContext.interval.packetBuffer.length = 0;
        return BigInt(0);
    }
    return ret;
}


/***/ }),

/***/ "./src/avformat/formats/OFormat.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/OFormat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OFormat)
/* harmony export */ });
/*
 * libmedia abstract format encoder
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class OFormat {
    type = -1 /* AVFormat.UNKNOWN */;
    destroy(formatContext) { }
}


/***/ }),

/***/ "./src/avformat/formats/OMovFormat.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/OMovFormat.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OMovFormat)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _OFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OFormat */ "./src/avformat/formats/OFormat.ts");
/* harmony import */ var _mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mov/function/createMovContext */ "./src/avformat/formats/mov/function/createMovContext.ts");
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _mov_omov__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mov/omov */ "./src/avformat/formats/mov/omov.ts");
/* harmony import */ var _mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mov/function/createMovStreamContext */ "./src/avformat/formats/mov/function/createMovStreamContext.ts");
/* harmony import */ var _mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mov/function/createFragmentTrack */ "./src/avformat/formats/mov/function/createFragmentTrack.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./mov/function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _function_rewriteIO__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../function/rewriteIO */ "./src/avformat/function/rewriteIO.ts");
/* harmony import */ var _function_arrayItemSame__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../function/arrayItemSame */ "./src/avformat/function/arrayItemSame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bsf/h2645/Annexb2AvccFilter */ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts");
var cheap__fileName__2 = "src/avformat/formats/OMovFormat.ts";




/*
 * libmedia mov encoder
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


















const defaultOptions = {
    fragmentMode: 0 /* FragmentMode.GOP */,
    movMode: 0 /* MovMode.MP4 */,
    fragment: false,
    fastOpen: false,
    defaultBaseIsMoof: false
};
class OMovFormat extends _OFormat__WEBPACK_IMPORTED_MODULE_0__["default"] {
    type = 1 /* AVFormat.MOV */;
    context;
    options;
    annexb2AvccFilter;
    constructor(options = {}) {
        super();
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_1__.extend({}, defaultOptions, options);
        this.context = (0,_mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_2__["default"])();
    }
    init(formatContext) {
        formatContext.ioWriter.setEndian(true);
        const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (videoStream) {
            this.annexb2AvccFilter = new _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_3__["default"]();
            this.annexb2AvccFilter.init(videoStream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_4__.symbolStructAddress], videoStream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_4__.symbolStructAddress]);
        }
        return 0;
    }
    destroy(formatContext) {
        super.destroy(formatContext);
        if (this.annexb2AvccFilter) {
            this.annexb2AvccFilter.destroy();
            this.annexb2AvccFilter = null;
        }
    }
    /*
     * stream.disposition controls the "enabled" flag in the tkhd tag.
     * QuickTime will not play a track if it is not enabled.  So make sure
     * that one track of each type (audio, video, subtitle) is enabled.
     *
     * Subtitles are special.  For audio and video, setting "enabled" also
     * makes the track "default" (i.e. it is rendered when played). For
     * subtitles, an "enabled" subtitle is not rendered by default, but
     * if no subtitle is enabled, the subtitle menu in QuickTime will be
     * empty!
     */
    enableStreams(formatContext) {
        const enabled = [];
        const first = [];
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            enabled[i] = 0;
            first[i] = -1;
        }
        common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream, index) => {
            if (stream.codecpar.codecType === -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */
                || stream.codecpar.codecType >= 5 /* AVMediaType.AVMEDIA_TYPE_NB */) {
                return true;
            }
            if (first[stream.codecpar.codecType] < 0) {
                first[stream.codecpar.codecType] = index;
            }
            if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
                enabled[stream.codecpar.codecType]++;
                stream.privData.flags |= 1 /* TKHDFlags.ENABLED */;
            }
        });
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            switch (i) {
                case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                case 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */:
                    if (enabled[i] > 1) {
                        formatContext.streams[enabled[i]].privData.perStreamGrouping = true;
                    }
                    if (!enabled[i] && first[i] >= 0) {
                        formatContext.streams[first[i]].privData.flags |= 1 /* TKHDFlags.ENABLED */;
                    }
                    break;
            }
        }
    }
    writeHeader(formatContext) {
        this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom');
        this.context.minorVersion = 512;
        this.context.compatibleBrand = [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom')];
        this.context.timescale = 1000;
        if (this.options.fragment) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso6'));
            this.context.fragment = true;
        }
        if (this.options.movMode === 1 /* MovMode.MOV */) {
            this.context.isom = true;
            this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('qt  ');
            this.context.compatibleBrand = [this.context.majorBrand];
        }
        if (this.options.movMode !== 1 /* MovMode.MOV */) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso2'));
            const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            if (videoStream && videoStream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('avc1'));
            }
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('mp41'));
        }
        _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeFtyp(formatContext.ioWriter, this.context);
        this.context.holdMoovPos = formatContext.ioWriter.getPos();
        if (this.options.fragment) {
            this.context.currentFragment = {
                pos: BigInt(0),
                currentTrack: null,
                sequence: 1,
                tracks: [],
                size: 0,
                firstWrote: false
            };
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
                const track = (0,_mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__["default"])();
                track.baseIsMoof = this.options.defaultBaseIsMoof;
                track.streamIndex = stream.index;
                track.trackId = this.context.nextTrackId++;
                streamContext.trackId = track.trackId;
                track.ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__["default"]();
                track.ioWriter.onFlush = (data) => {
                    track.buffers.push(data.slice());
                    return 0;
                };
                this.context.currentFragment.tracks.push(track);
            });
            this.enableStreams(formatContext);
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
            formatContext.ioWriter.flush();
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.trackId = this.context.nextTrackId++;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
            });
            this.enableStreams(formatContext);
            const pos = formatContext.ioWriter.getPos();
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
        return 0;
    }
    updateCurrentChunk(formatContext) {
        let currentChunk = this.context.currentChunk;
        if (!currentChunk.sampleCount) {
            return;
        }
        const prevStream = formatContext.streams.find((stream) => {
            return stream.index === currentChunk.streamIndex;
        });
        const prevMovStreamContext = prevStream.privData;
        prevMovStreamContext.chunkCount++;
        prevMovStreamContext.chunkOffsets.push(currentChunk.pos);
        if (!prevMovStreamContext.stscFirstChunk.length) {
            prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
            prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
            prevMovStreamContext.stscSampleDescriptionIndex.push(1);
            prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
        }
        else {
            if (prevMovStreamContext.lastStscCount !== currentChunk.sampleCount) {
                prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
                prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
                prevMovStreamContext.stscSampleDescriptionIndex.push(1);
                prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
            }
        }
    }
    checkMdat(formatContext, len) {
        const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
        if (mdat.type !== "mdat" /* BoxType.MDAT */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.error('last box is not mdat', cheap__fileName__2, 298);
            return;
        }
        const pos = formatContext.ioWriter.getPos();
        const size = Number(pos - mdat.pos);
        if (size + len > avutil_constant__WEBPACK_IMPORTED_MODULE_12__.UINT32_MAX) {
            mdat.size = size;
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
    }
    updateCurrentFragment(formatContext, currentDts) {
        if (this.context.currentFragment.firstWrote) {
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                if (!track.sampleCount || !stream) {
                    return true;
                }
                const streamContext = stream.privData;
                track.baseDataOffset = formatContext.ioWriter.getPos();
                if (!track.sampleDurations.length) {
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if (stream.codecpar.frameSize > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(BigInt(stream.codecpar.frameSize / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            // 随便猜一个？每帧一个 fragment 没有 sampleDuration QuickTime 无法播放
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avQ2D)(stream.codecpar.framerate) > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(BigInt(Math.floor(1 / (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avQ2D)(stream.codecpar.framerate) * avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE)), avutil_constant__WEBPACK_IMPORTED_MODULE_12__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            // 随便猜一个？每帧一个 fragment 没有 sampleDuration QuickTime 无法播放
                            // 取帧率 30
                            track.sampleDurations.push((stream.timeBase.den / (30 * stream.timeBase.num)) >>> 0);
                        }
                    }
                    else {
                        track.sampleDurations.push(0);
                    }
                }
                else if (currentDts && track.sampleDurations.length === track.sampleSizes.length - 1) {
                    track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                }
                streamContext.lastDuration = track.sampleDurations[track.sampleSizes.length - 1];
                if (track.sampleFlags.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_14__["default"])(track.sampleFlags, 1)) {
                    track.firstSampleFlags = track.sampleFlags[0];
                    track.defaultSampleFlags = track.sampleFlags[1] ?? track.firstSampleFlags;
                    track.sampleFlags = [];
                }
                if (track.sampleSizes.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_14__["default"])(track.sampleSizes)) {
                    track.defaultSampleSize = track.sampleSizes[0];
                    track.sampleSizes = [];
                }
                if (track.sampleDurations.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_14__["default"])(track.sampleDurations)) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                    track.sampleDurations = [];
                }
                if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    track.defaultSampleFlags = 33554432 /* SampleFlags.DEPENDS_NO */;
                }
                else if (track.sampleFlags.length) {
                    track.defaultSampleFlags = track.sampleFlags[0];
                }
                if (track.sampleSizes.length) {
                    track.defaultSampleSize = track.sampleSizes[0];
                }
                if (track.sampleDurations.length) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                }
            });
            formatContext.ioWriter.flush();
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoof(formatContext.ioWriter, formatContext, this.context);
            let dataOffset = this.context.currentFragment.size + 8;
            const buffers = [];
            let mdatSize = 8;
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(this.context.currentFragment.tracks, (track) => {
                if (!track.sampleCount) {
                    return true;
                }
                track.ioWriter.flush();
                const buffer = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_15__["default"])(Uint8Array, track.buffers);
                track.dataOffset = dataOffset;
                dataOffset += buffer.length;
                mdatSize += buffer.length;
                buffers.push(buffer);
                (0,_function_rewriteIO__WEBPACK_IMPORTED_MODULE_16__["default"])(formatContext.ioWriter, track.dataOffsetPos, track.dataOffset, 'int32');
                track.buffers = [];
                track.sampleFlags = [];
                track.sampleSizes = [];
                track.sampleDurations = [];
                track.sampleCompositionTimeOffset = [];
                track.sampleCount = 0;
                track.firstSampleFlags = 0;
            });
            formatContext.ioWriter.writeUint32(mdatSize);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(buffers, (buffer) => {
                formatContext.ioWriter.writeBuffer(buffer);
            });
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_17__["default"])(formatContext.ioWriter, this.context);
            formatContext.ioWriter.flush();
            this.context.currentFragment.firstWrote = false;
            this.context.currentFragment.sequence++;
        }
    }
    writeAVPacket(formatContext, avpacket) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 28)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`packet\'s size is 0: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 465);
            return 0;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32));
        if (!stream) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`can not found the stream width the avpacket\'s streamIndex: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 472);
            return;
        }
        const streamContext = stream.privData;
        const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_19__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_20__.Rational), stream.timeBase);
        const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 8) < BigInt(0) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 16) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_19__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_20__.Rational), stream.timeBase);
        if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */)
            && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 80) !== 1 /* BitFormat.AVCC */) {
            this.annexb2AvccFilter.sendAVPacket(avpacket);
            this.annexb2AvccFilter.receiveAVPacket(avpacket);
        }
        if (this.context.fragment) {
            const track = this.context.currentFragment.tracks.find((track) => {
                return track.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32);
            });
            if (track) {
                if (this.options.fragmentMode === 0 /* FragmentMode.GOP */
                    && stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                    && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */
                    || this.options.fragmentMode === 1 /* FragmentMode.FRAME */) {
                    if (this.context.currentFragment.tracks.length === 1) {
                        this.updateCurrentFragment(formatContext, dts);
                    }
                    else {
                        this.updateCurrentFragment(formatContext);
                    }
                }
                track.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketData)(avpacket));
                if (!track.sampleSizes.length) {
                    track.baseMediaDecodeTime = dts;
                }
                if (track.sampleSizes.length
                    && (!track.sampleDurations[track.sampleSizes.length - 1]
                        || track.sampleDurations[track.sampleSizes.length - 1] <= 0)) {
                    track.sampleDurations[track.sampleSizes.length - 1] = Number(dts - streamContext.lastDts);
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 48) > 0) {
                    track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[17](avpacket + 48), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_19__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_20__.Rational), stream.timeBase)));
                }
                track.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 28));
                if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    let flag = 0;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        flag |= 33554432 /* SampleFlags.DEPENDS_NO */;
                    }
                    else {
                        flag |= (16777216 /* SampleFlags.DEPENDS_YES */ | 65536 /* SampleFlags.IS_NON_SYN */);
                    }
                    track.sampleCompositionTimeOffset.push(Number((pts || dts) - dts));
                    track.sampleFlags.push(flag);
                }
                track.sampleCount++;
                streamContext.lastPts = pts > streamContext.lastPts ? pts : streamContext.lastPts;
                streamContext.lastDts = dts;
                this.context.currentFragment.firstWrote = true;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`can not found track width streamIndex ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 551);
            }
        }
        else {
            this.checkMdat(formatContext, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 28));
            const pos = formatContext.ioWriter.getPos();
            let currentChunk = this.context.currentChunk;
            if (!currentChunk) {
                currentChunk = this.context.currentChunk = {
                    pos,
                    streamIndex: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32),
                    sampleCount: 1
                };
            }
            else if (currentChunk.streamIndex !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32)) {
                this.updateCurrentChunk(formatContext);
                currentChunk.streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 32);
                currentChunk.sampleCount = 1;
                currentChunk.pos = pos;
            }
            else {
                currentChunk.sampleCount++;
            }
            formatContext.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketData)(avpacket));
            streamContext.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 28));
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_18__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                streamContext.stssSampleNumbers.push(streamContext.sampleSizes.length);
            }
            if (!streamContext.firstWrote) {
                streamContext.startDts = dts;
                streamContext.startCT = Number((pts || dts) - dts);
                streamContext.firstWrote = true;
            }
            else {
                const deltas = Number(dts - streamContext.lastDts);
                if (!streamContext.sttsSampleCounts.length) {
                    streamContext.sttsSampleCounts.push(1);
                    streamContext.sttsSampleDeltas.push(deltas);
                }
                else {
                    if (streamContext.sttsSampleDeltas[streamContext.sttsSampleDeltas.length - 1] === deltas) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts.push(1);
                        streamContext.sttsSampleDeltas.push(deltas);
                    }
                }
            }
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const ctts = Number((pts || dts) - dts);
                if (!streamContext.cttsSampleCounts.length) {
                    streamContext.cttsSampleCounts.push(1);
                    streamContext.cttsSampleOffsets.push(ctts);
                }
                else {
                    if (streamContext.cttsSampleOffsets[streamContext.cttsSampleOffsets.length - 1]
                        === ctts) {
                        streamContext.cttsSampleCounts[streamContext.cttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.cttsSampleCounts.push(1);
                        streamContext.cttsSampleOffsets.push(ctts);
                    }
                }
            }
            streamContext.lastPts = (pts || dts) > streamContext.lastPts ? (pts || dts) : streamContext.lastPts;
            streamContext.lastDts = dts;
        }
        return 0;
    }
    writeTrailer(formatContext) {
        if (!this.context.fragment) {
            this.updateCurrentChunk(formatContext);
            let lastPts = BigInt(0);
            let timeBase;
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream) => {
                const streamContext = stream.privData;
                if (streamContext.sampleSizes.length) {
                    if (streamContext.sttsSampleDeltas.length) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts = [1];
                        streamContext.sttsSampleDeltas = [0];
                    }
                }
                if (streamContext.lastPts > lastPts) {
                    lastPts = streamContext.lastPts;
                    timeBase = stream.timeBase;
                }
            });
            this.context.duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(lastPts, timeBase, { den: 1000, num: 1 });
            const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
            if (mdat.type !== "mdat" /* BoxType.MDAT */) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.error('last box is not mdat', cheap__fileName__2, 665);
            }
            mdat.size = Number(formatContext.ioWriter.getPos() - mdat.pos);
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_17__["default"])(formatContext.ioWriter, this.context);
            if (this.options.fastOpen) {
                formatContext.ioWriter.flush();
                let buffers = [];
                const rawFlush = formatContext.ioWriter.onFlush;
                formatContext.ioWriter.onFlush = (buffer) => {
                    buffers.push(buffer.slice());
                    return 0;
                };
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                let data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_15__["default"])(Uint8Array, buffers);
                common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream) => {
                    const streamContext = stream.privData;
                    if (streamContext.chunkOffsets.length) {
                        for (let i = 0; i < streamContext.chunkOffsets.length; i++) {
                            streamContext.chunkOffsets[i] += BigInt(Math.floor(data.length));
                        }
                    }
                });
                buffers = [];
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_15__["default"])(Uint8Array, buffers);
                if (rawFlush) {
                    rawFlush(data, this.context.holdMoovPos);
                }
                formatContext.ioWriter.onFlush = rawFlush;
            }
            else {
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
            }
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
            formatContext.ioWriter.writeUint32(8);
            formatContext.ioWriter.writeString("mfra" /* BoxType.MFRA */);
            formatContext.ioWriter.flush();
        }
        return 0;
    }
    flush(formatContext) {
        if (this.options.fragment) {
            common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
        }
        formatContext.ioWriter.flush();
        return 0;
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/boxType.ts":
/*!*********************************************!*\
  !*** ./src/avformat/formats/mov/boxType.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContainerBoxs: () => (/* binding */ ContainerBoxs),
/* harmony export */   FullBoxs: () => (/* binding */ FullBoxs)
/* harmony export */ });
/* unused harmony export BasicBoxs */
/*
 * libmedia mp4 box defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const BasicBoxs = [
    "ftyp" /* BoxType.FTYP */,
    "mdat" /* BoxType.MDAT */,
    "idat" /* BoxType.IDAT */,
    "free" /* BoxType.FREE */,
    "skip" /* BoxType.SKIP */,
    "meco" /* BoxType.MECO */,
    "strk" /* BoxType.STRK */,
];
const FullBoxs = [
    "hmhd" /* BoxType.HMHD */,
    "nmhd" /* BoxType.NMHD */,
    "iods" /* BoxType.IODS */,
    "xml " /* BoxType.XML */,
    "url " /* BoxType.URL */,
    "bxml" /* BoxType.BXML */,
    "ipro" /* BoxType.IPRO */,
    "mere" /* BoxType.MERE */,
    "stts" /* BoxType.STTS */,
    "ctts" /* BoxType.CTTS */,
    "stss" /* BoxType.STSS */,
    "stsz" /* BoxType.STSZ */,
    "stz2" /* BoxType.STZ2 */,
    "stsc" /* BoxType.STSC */,
    "stco" /* BoxType.STCO */,
    "co64" /* BoxType.CO64 */,
    "stsd" /* BoxType.STSD */,
    "dref" /* BoxType.DREF */,
    "mvhd" /* BoxType.MVHD */,
    "tkhd" /* BoxType.TKHD */,
    "mdhd" /* BoxType.MDHD */,
    "hdlr" /* BoxType.HDLR */
];
const ContainerBoxs = [
    "moov" /* BoxType.MOOV */,
    "trak" /* BoxType.TRAK */,
    "edts" /* BoxType.EDTS */,
    "mdia" /* BoxType.MDIA */,
    "minf" /* BoxType.MINF */,
    "dinf" /* BoxType.DINF */,
    "stbl" /* BoxType.STBL */,
    "mvex" /* BoxType.MVEX */,
    "moof" /* BoxType.MOOF */,
    "traf" /* BoxType.TRAF */,
    "vttc" /* BoxType.VTTC */,
    "tref" /* BoxType.TREF */,
    "iref" /* BoxType.IREF */,
    "mfra" /* BoxType.MFRA */,
    "hnti" /* BoxType.HNTI */,
    "hinf" /* BoxType.HINF */,
    "strd" /* BoxType.STRD */,
    "sinf" /* BoxType.SINF */,
    "rinf" /* BoxType.RINF */,
    "schi" /* BoxType.SCHI */,
    "trgr" /* BoxType.TRGR */,
    "udta" /* BoxType.UDTA */,
    "iprp" /* BoxType.IPRP */,
    "ipco" /* BoxType.IPCO */,
    "strk" /* BoxType.STRK */,
    "meco" /* BoxType.MECO */
];


/***/ }),

/***/ "./src/avformat/formats/mov/function/createFragmentTrack.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createFragmentTrack.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createFragmentTrack)
/* harmony export */ });
/*
 * libmedia create fragment track
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function createFragmentTrack() {
    return {
        trackId: 0,
        baseDataOffset: BigInt(0),
        defaultSampleDuration: 0,
        defaultSampleSize: 0,
        defaultSampleFlags: 0,
        baseMediaDecodeTime: BigInt(0),
        sampleCount: 0,
        dataOffset: 0,
        dataOffsetPos: BigInt(0),
        firstSampleFlags: 0,
        sampleDurations: [],
        sampleSizes: [],
        sampleFlags: [],
        sampleCompositionTimeOffset: [],
        baseIsMoof: false,
        ioWriter: null,
        buffers: []
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovContext.ts":
/*!***************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovContext.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov context
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovContext() {
    return {
        isom: false,
        timescale: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        duration: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT,
        foundMoov: false,
        foundMdat: false,
        majorBrand: 0,
        minorVersion: 0,
        compatibleBrand: [],
        creationTime: BigInt(0),
        modificationTime: BigInt(0),
        rate: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        volume: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        matrix: null,
        nextTrackId: 1,
        fragment: false,
        trexs: [],
        currentFragment: null,
        boxsPositionInfo: [],
        holdMoovPos: BigInt(0),
        currentChunk: null
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovStreamContext.ts":
/*!*********************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovStreamContext.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovStreamContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov stream context
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovStreamContext() {
    return {
        chunkOffsets: null,
        cttsSampleCounts: null,
        cttsSampleOffsets: null,
        stscFirstChunk: null,
        stscSamplesPerChunk: null,
        stscSampleDescriptionIndex: null,
        stssSampleNumbersMap: null,
        stssSampleNumbers: null,
        sampleSizes: null,
        sttsSampleCounts: null,
        sttsSampleDeltas: null,
        timescale: 0,
        duration: BigInt(0),
        trackId: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        layer: 0,
        alternateGroup: 0,
        volume: 0,
        matrix: null,
        width: 0,
        height: 0,
        audioCid: 0,
        samplesPerFrame: 0,
        bytesPerFrame: 0,
        currentSample: 0,
        sampleEnd: false,
        samplesIndex: [],
        fragIndexes: [],
        lastPts: BigInt(0),
        lastDts: BigInt(0),
        startDts: BigInt(0),
        startCT: 0,
        lastDuration: 0,
        chunkCount: 0,
        firstWrote: false,
        lastStscCount: 0,
        perStreamGrouping: false,
        index: 0,
        flags: 0
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/updatePositionSize.ts":
/*!*****************************************************************!*\
  !*** ./src/avformat/formats/mov/function/updatePositionSize.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updatePositionSize)
/* harmony export */ });
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia update box position size
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function updatePositionSize(ioWriter, movContext) {
    const pos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = pos - BigInt(Math.floor(pointer));
    const seeks = [];
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(movContext.boxsPositionInfo, (item) => {
        if (item.pos < pos && item.pos >= minPos) {
            ioWriter.seekInline(pointer + Number(item.pos - pos));
            ioWriter.writeUint32(item.size);
        }
        else {
            seeks.push(item);
        }
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(seeks, (item) => {
        ioWriter.seek(item.pos);
        ioWriter.writeUint32(item.size);
    });
    if (seeks.length) {
        ioWriter.seek(pos);
    }
    else {
        ioWriter.seekInline(pointer);
    }
    movContext.boxsPositionInfo = [];
}


/***/ }),

/***/ "./src/avformat/formats/mov/layout.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/mov/layout.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FragmentTrackBoxLayoutMap: () => (/* binding */ FragmentTrackBoxLayoutMap),
/* harmony export */   MoofTrafBoxLayout: () => (/* binding */ MoofTrafBoxLayout),
/* harmony export */   TrackBoxLayoutMap: () => (/* binding */ TrackBoxLayoutMap)
/* harmony export */ });
/*
 * libmedia mp4 box layout
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getTrackBoxAudioLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getTrackBoxVideoLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stss" /* BoxType.STSS */
                                },
                                {
                                    type: "ctts" /* BoxType.CTTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackAudioBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackVideoBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
const FragmentTrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getFragmentTrackAudioBoxLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getFragmentTrackVideoBoxLayout
};
const TrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getTrackBoxAudioLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getTrackBoxVideoLayout
};
const MoofTrafBoxLayout = [
    {
        type: "tfhd" /* BoxType.TFHD */
    },
    {
        type: "tfdt" /* BoxType.TFDT */
    },
    {
        type: "trun" /* BoxType.TRUN */
    }
];


/***/ }),

/***/ "./src/avformat/formats/mov/mov.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/mov/mov.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVCodecID2Mp4a: () => (/* binding */ AVCodecID2Mp4a),
/* harmony export */   HandlerType2MediaType: () => (/* binding */ HandlerType2MediaType),
/* harmony export */   Mp4aObj2AVCodecID: () => (/* binding */ Mp4aObj2AVCodecID),
/* harmony export */   tag2CodecId: () => (/* binding */ tag2CodecId)
/* harmony export */ });
/* unused harmony export Mp4Tag2AVCodecID */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/*
 * libmedia mp4 identify defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const Mp4Tag2AVCodecID = {
    mp4v: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    avc1: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    avc3: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    hev1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    hvc1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    vp09: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    av01: 226 /* AVCodecID.AV_CODEC_ID_AV1 */,
    mp4a: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    opus: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */
};
const AVCodecID2Mp4a = {
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 0x40,
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 0x69,
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 0xAD,
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 0xC1,
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 0xDD,
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 0x20,
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 0x21,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 0x23,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 0xB1,
    [0 /* AVCodecID.AV_CODEC_ID_NONE */]: 0
};
const Mp4aObj2AVCodecID = {
    0x20: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    0x21: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    0x23: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    0xB1: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    0x40: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x66: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x67: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x68: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x69: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0x6B: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0xAD: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    0xC1: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    0xDD: 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    0: 0 /* AVCodecID.AV_CODEC_ID_NONE */
};
const HandlerType2MediaType = {
    vide: 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    soun: 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    clcp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    sbtl: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subt: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    text: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */
};
const tag2CodecId = {
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mp4a" /* BoxType.MP4A */)]: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    [0x6D730055]: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('Opus')]: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('fLaC')]: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('spex')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('SPXN')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('ac-3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('sac3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"]["mp4v" /* BoxType.MP4V */]]: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('av01')]: 226 /* AVCodecID.AV_CODEC_ID_AV1 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp08')]: 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp09')]: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('avc1')]: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hev1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hvc1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('text')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('tx3g')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */
};


/***/ }),

/***/ "./src/avformat/formats/mov/omov.ts":
/*!******************************************!*\
  !*** ./src/avformat/formats/mov/omov.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   writeFtyp: () => (/* binding */ writeFtyp),
/* harmony export */   writeMoof: () => (/* binding */ writeMoof),
/* harmony export */   writeMoov: () => (/* binding */ writeMoov)
/* harmony export */ });
/* unused harmony export updateSize */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _boxType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boxType */ "./src/avformat/formats/mov/boxType.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _writing_writers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./writing/writers */ "./src/avformat/formats/mov/writing/writers.ts");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layout */ "./src/avformat/formats/mov/layout.ts");
/* harmony import */ var _function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/*
 * libmedia mp4 encode util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






function updateSize(ioWriter, pointer, size) {
    const current = ioWriter.getPointer();
    ioWriter.seekInline(pointer);
    ioWriter.writeUint32(size);
    ioWriter.seekInline(current);
}
function writeFtyp(ioWriter, context) {
    ioWriter.flush();
    const pointer = ioWriter.getPointer();
    const now = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("ftyp" /* BoxType.FTYP */));
    ioWriter.writeUint32(context.majorBrand || (0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('isom'));
    ioWriter.writeUint32(context.minorVersion || 512);
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(context.compatibleBrand, (value) => {
        ioWriter.writeUint32(value);
    });
    updateSize(ioWriter, pointer, Number(ioWriter.getPos() - now));
    if (context.isom) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("wide" /* BoxType.WIDE */));
    }
    else if (!context.fragment) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("free" /* BoxType.FREE */));
    }
}
function writeEmptyBox(ioWriter, tag) {
    const isFullBox = common_util_array__WEBPACK_IMPORTED_MODULE_1__.has(_boxType__WEBPACK_IMPORTED_MODULE_2__.FullBoxs, tag);
    ioWriter.writeUint32(isFullBox ? 12 : 8);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(tag));
    if (isFullBox) {
        // version & flags
        ioWriter.writeUint32(0);
    }
}
function writeLayout(ioWriter, layouts, stream, movContext) {
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(layouts, (layout) => {
        if (!layout) {
            return true;
        }
        if (_writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type]) {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type](ioWriter, stream, movContext);
        }
        else if (layout.children) {
            const pos = ioWriter.getPos();
            ioWriter.writeUint32(0);
            ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(layout.type));
            writeLayout(ioWriter, layout.children, stream, movContext);
            movContext.boxsPositionInfo.push({
                pos,
                type: layout.type,
                size: Number(ioWriter.getPos() - pos)
            });
        }
        else {
            writeEmptyBox(ioWriter, layout.type);
        }
    });
}
function writeMoov(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moov" /* BoxType.MOOV */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mvhd" /* BoxType.MVHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(formatContext.streams, (stream) => {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("trak" /* BoxType.TRAK */));
        writeLayout(ioWriter, movContext.fragment
            ? _layout__WEBPACK_IMPORTED_MODULE_4__.FragmentTrackBoxLayoutMap[stream.codecpar.codecType](movContext)
            : _layout__WEBPACK_IMPORTED_MODULE_4__.TrackBoxLayoutMap[stream.codecpar.codecType](movContext), stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "trak" /* BoxType.TRAK */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    if (movContext.fragment) {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mvex" /* BoxType.MVEX */));
        common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(formatContext.streams, (stream) => {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["trex" /* BoxType.TREX */](ioWriter, stream, movContext);
        });
        movContext.boxsPositionInfo.push({
            pos,
            type: "mvex" /* BoxType.MVEX */,
            size: Number(ioWriter.getPos() - pos)
        });
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "moov" /* BoxType.MOOV */,
        size: Number(ioWriter.getPos() - pos)
    });
    (0,_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, movContext);
}
function writeMoof(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moof" /* BoxType.MOOF */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mfhd" /* BoxType.MFHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(movContext.currentFragment.tracks, (track) => {
        if (!track.sampleCount) {
            return true;
        }
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("traf" /* BoxType.TRAF */));
        const stream = formatContext.streams.find((stream) => {
            return stream.privData.trackId === track.trackId;
        });
        writeLayout(ioWriter, _layout__WEBPACK_IMPORTED_MODULE_4__.MoofTrafBoxLayout, stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "traf" /* BoxType.TRAF */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    const size = Number(ioWriter.getPos() - pos);
    movContext.boxsPositionInfo.push({
        pos,
        type: "moof" /* BoxType.MOOF */,
        size
    });
    movContext.currentFragment.size = size;
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/av1c.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/av1c.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 av1c box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("av1C" /* BoxType.AV1C */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/avcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/avcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 avcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("avcC" /* BoxType.AVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/btrt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/btrt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 btrt box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("btrt" /* BoxType.BTRT */);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/co64.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/co64.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 co64 box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const chunkOffsets = stream.privData.chunkOffsets || [];
    // size
    ioWriter.writeUint32(8 + chunkOffsets.length * 8);
    // tag
    ioWriter.writeString("co64" /* BoxType.CO64 */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint64(chunkOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/colr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/colr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 colr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const icc = stream.sideData[28 /* AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE */];
    if (icc) {
        // size
        ioWriter.writeUint32(12 + icc.length);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('prof');
        ioWriter.writeBuffer(icc);
    }
    else {
        const fullRange = stream.codecpar.colorRange === 2 /* AVColorRange.AVCOL_RANGE_JPEG */;
        // size
        ioWriter.writeUint32(19);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('nclx');
        ioWriter.writeUint16(stream.codecpar.colorPrimaries);
        ioWriter.writeUint16(stream.codecpar.colorTrc);
        ioWriter.writeUint16(stream.codecpar.colorSpace);
        ioWriter.writeUint8(fullRange ? (128) : 0);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/ctts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/ctts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/formats/mov/writing/ctts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.cttsSampleCounts || [];
    const sampleOffsets = context.cttsSampleOffsets || [];
    if (sampleCounts.length !== sampleOffsets.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts sampleCounts\'s length is not match sampleOffsets\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleOffsets.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("ctts" /* BoxType.CTTS */);
    // version use int
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dfla.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dfla.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/formats/mov/writing/dfla.ts";


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error('invalid extradata', cheap__fileName__0, 56);
    }
    else {
        // size
        ioWriter.writeUint32(extradata.length + 16);
        // tag
        ioWriter.writeString("dfLa" /* BoxType.DFLA */);
        // version
        ioWriter.writeUint8(0);
        // flags
        ioWriter.writeUint24(0);
        ioWriter.writeUint8((128) | 0 /* FlacMetadataType.FLAC_METADATA_TYPE_STREAMINFO */);
        ioWriter.writeUint24(extradata.length);
        ioWriter.writeBuffer(extradata);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dops.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dops.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/*
 * libmedia mp4 dops box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata || extradata.length < 19) {
        ioWriter.writeUint32(19);
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        ioWriter.writeUint8(0);
        ioWriter.writeUint8(stream.codecpar.chLayout.nbChannels);
        ioWriter.writeUint16(stream.codecpar.initialPadding);
        ioWriter.writeUint32(stream.codecpar.sampleRate);
        ioWriter.writeUint16(0);
        ioWriter.writeUint8(0);
    }
    else {
        const reader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__["default"](extradata, false);
        // size
        ioWriter.writeUint32(extradata.length);
        // tag
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        // Version
        ioWriter.writeUint8(0);
        reader.seek(9);
        ioWriter.writeUint8(reader.readUint8());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeUint32(reader.readUint32());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeBuffer(extradata.subarray(18));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dref.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dref.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 dref box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(28);
    // tag
    ioWriter.writeString("dref" /* BoxType.DREF */);
    // version & flags
    ioWriter.writeUint32(0);
    // entry count
    ioWriter.writeUint32(1);
    // size
    ioWriter.writeUint32(0x0c);
    ioWriter.writeString("url " /* BoxType.URL */);
    // version & flags
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/edts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/edts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 edts box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    let duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_0__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    let startCT = streamContext.startCT;
    const delay = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_0__.avRescaleQ)(streamContext.startDts + BigInt(Math.floor(startCT)), stream.timeBase, {
        den: streamContext.timescale,
        num: 1
    });
    let version = duration < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.INT32_MAX ? 0 : 1;
    version |= delay < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.INT32_MAX ? 0 : 1;
    const entrySize = (version === 1) ? 20 : 12;
    const entryCount = 1 + (delay > 0 ? 1 : 0);
    const size = 24 + entryCount * entrySize;
    // size
    ioWriter.writeUint32(size);
    // tag
    ioWriter.writeString("edts" /* BoxType.EDTS */);
    ioWriter.writeUint32(size - 8);
    ioWriter.writeString("elst" /* BoxType.ELST */);
    ioWriter.writeUint8(version);
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    if (delay > 0) {
        if (version === 1) {
            ioWriter.writeUint64(delay);
            ioWriter.writeInt64(avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE_BIGINT);
        }
        else {
            ioWriter.writeUint32(Number(delay));
            ioWriter.writeInt32(-1);
        }
        ioWriter.writeUint32(0x00010000);
    }
    else {
        startCT = -Math.min(Number(streamContext.startDts), 0);
        duration += delay;
    }
    if (movContext.fragment) {
        duration = BigInt(0);
    }
    if (version === 1) {
        ioWriter.writeUint64(duration);
        ioWriter.writeInt64(BigInt(Math.floor(startCT)));
    }
    else {
        ioWriter.writeUint32(Number(duration));
        ioWriter.writeInt32(startCT);
    }
    ioWriter.writeUint32(0x00010000);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/esds.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/esds.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _mov__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mov */ "./src/avformat/formats/mov/mov.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 esds box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function writeDescriptorLength(ioWriter, tag, size) {
    ioWriter.writeUint8(tag);
    for (let i = 3; i > 0; i--) {
        ioWriter.writeUint8((size >> (7 * i)) | 0x80);
    }
    ioWriter.writeUint8(size & 0x7F);
}
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const decoderSpecificInfoLen = stream.codecpar.extradata ? 5 + stream.codecpar.extradataSize : 0;
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("esds" /* BoxType.ESDS */);
    // version = 0
    ioWriter.writeUint32(0);
    // ES descriptor
    writeDescriptorLength(ioWriter, 3 /* MP4Tag.MP4_ES_DESCR_TAG */, 21 + decoderSpecificInfoLen + 5 + 1);
    ioWriter.writeUint16(streamContext.trackId);
    // ioWriter
    ioWriter.writeUint8(0x00);
    // DecoderConfig descriptor
    writeDescriptorLength(ioWriter, 4 /* MP4Tag.MP4_DEC_CONFIG_DESCR_TAG */, 13 + decoderSpecificInfoLen);
    // Object type indication
    if ((stream.codecpar.codecId === 86016 /* AVCodecID.AV_CODEC_ID_MP2 */ || stream.codecpar.codecId === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */)
        && stream.codecpar.sampleRate > 24000) {
        // 11172-3
        ioWriter.writeUint8(0x6B);
    }
    else {
        ioWriter.writeUint8(_mov__WEBPACK_IMPORTED_MODULE_0__.AVCodecID2Mp4a[stream.codecpar.codecId]);
    }
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        // flags (= NeroSubpicStream)
        ioWriter.writeUint8((224) | 1);
    }
    else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        // flags (= Audiostream)
        ioWriter.writeUint8(0x15);
    }
    else {
        // flags (= Visualstream)
        ioWriter.writeUint8(0x11);
    }
    //  Buffersize DB
    ioWriter.writeUint24(0);
    // maxbitrate
    ioWriter.writeUint32(0);
    // avgbitrate
    ioWriter.writeUint32(0);
    if (stream.codecpar.extradata) {
        writeDescriptorLength(ioWriter, 5 /* MP4Tag.MP4_DEC_SPECIFIC_DESCR_TAG */, stream.codecpar.extradataSize);
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    // SL descriptor
    writeDescriptorLength(ioWriter, 6 /* MP4Tag.MP4_SL_DESCR_TAG */, 1);
    ioWriter.writeUint8(0x02);
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/function/writeMatrix.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/writing/function/writeMatrix.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ writeMatrix)
/* harmony export */ });
/*
 * libmedia write matrix
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
/**
 * transformation matrix
 *  |a  b  u|
 *  |c  d  v|
 *  |tx ty w|
 */
function writeMatrix(ioWriter, a, b, c, d, tx, ty) {
    ioWriter.writeUint32(a << 16);
    ioWriter.writeUint32(b << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(c << 16);
    ioWriter.writeUint32(d << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(tx << 16);
    ioWriter.writeUint32(ty << 16);
    ioWriter.writeUint32(1073741824);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hdlr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hdlr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 hdlr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("hdlr" /* BoxType.HDLR */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    let hdlr = 'dhlr';
    let hdlrType = 'url ';
    let descr = 'DataHandler';
    if (stream) {
        hdlr = 'mhlr';
        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            hdlrType = 'soun';
            descr = 'SoundHandler';
        }
        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            hdlrType = 'vide';
            descr = 'VideoHandler';
        }
        else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            hdlrType = 'text';
            descr = 'SubtitleHandler';
        }
        else {
            if (stream.metadata['handlerName']) {
                descr = stream.metadata['handlerName'];
            }
            if (stream.metadata['hdlrType']) {
                hdlrType = stream.metadata['hdlrType'];
            }
        }
    }
    // handler
    ioWriter.writeString(hdlr);
    // handler type 
    ioWriter.writeString(hdlrType);
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    if (!stream || movContext.isom) {
        ioWriter.writeUint8(descr.length);
    }
    ioWriter.writeString(descr);
    if (stream && !movContext.isom) {
        // c string
        ioWriter.writeUint8(0);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "hdlr" /* BoxType.HDLR */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hvcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hvcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 hvcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("hvcC" /* BoxType.HVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mdhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mdhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp4 mdhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = streamContext.lastPts;
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const languge = stream.metadata['language'] || 21956;
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 44 : 32);
    // tag
    ioWriter.writeString("mdhd" /* BoxType.MDHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(stream.timeBase.den);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // language
    ioWriter.writeUint16(languge);
    // reserved (quality) 
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 mfhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("mfhd" /* BoxType.MFHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(movContext.currentFragment.sequence);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/minfHdlr.ts":
/*!******************************************************!*\
  !*** ./src/avformat/formats/mov/writing/minfHdlr.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/*
 * libmedia mp4 hdlr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    (0,_hdlr__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, null, movContext);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mvhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mvhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/*
 * libmedia mp4 mvhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const duration = movContext.duration;
    const creationTime = movContext.creationTime || 0;
    const modificationTime = movContext.modificationTime || 0;
    const timescale = movContext.timescale || 0;
    let nextTrackId = movContext.nextTrackId || 1;
    if (movContext.fragment) {
        nextTrackId = 2;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 120 : 108);
    // tag
    ioWriter.writeString("mvhd" /* BoxType.MVHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(timescale);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved (preferred rate) 1.0 = normal
    ioWriter.writeUint32(0x00010000);
    // reserved (preferred volume) 1.0 = normal
    ioWriter.writeUint16(0x0100);
    // reserved
    ioWriter.writeUint16(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    // reserved (preview time)
    ioWriter.writeUint32(0);
    // reserved (preview duration)
    ioWriter.writeUint32(0);
    // reserved (poster time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (current time)
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(nextTrackId);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/pasp.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/pasp.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 pasp box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("pasp" /* BoxType.PASP */);
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/smhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/smhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 smhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("smhd" /* BoxType.SMHD */);
    // version & flags
    ioWriter.writeUint32(0);
    // reserved (balance, normally = 0
    ioWriter.writeUint16(0);
    // reserved
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stco.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stco.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stco box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const chunkOffsets = context.chunkOffsets || [];
    // size
    ioWriter.writeUint32(16 + chunkOffsets.length * 4);
    // tag
    ioWriter.writeString("stco" /* BoxType.STCO */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint32(Number(chunkOffsets[i]));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/formats/mov/writing/stsc.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const firstChunk = context.stscFirstChunk;
    const samplesPerChunk = context.stscSamplesPerChunk;
    const sampleDescriptionIndex = context.stscSampleDescriptionIndex;
    if (firstChunk.length !== samplesPerChunk.length
        || firstChunk.length !== sampleDescriptionIndex.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts firstChunk\'s length is not match samplesPerChunk\'s length or sampleDescriptionIndex\'s length', cheap__fileName__0, 42);
    }
    const entryCount = Math.min(firstChunk.length, samplesPerChunk.length, sampleDescriptionIndex.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 12);
    // tag
    ioWriter.writeString("stsc" /* BoxType.STSC */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(firstChunk[i]);
        ioWriter.writeUint32(samplesPerChunk[i]);
        ioWriter.writeUint32(sampleDescriptionIndex[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _avcc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./avcc */ "./src/avformat/formats/mov/writing/avcc.ts");
/* harmony import */ var _hvcc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hvcc */ "./src/avformat/formats/mov/writing/hvcc.ts");
/* harmony import */ var _vpcc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vpcc */ "./src/avformat/formats/mov/writing/vpcc.ts");
/* harmony import */ var _av1c__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./av1c */ "./src/avformat/formats/mov/writing/av1c.ts");
/* harmony import */ var _dfla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dfla */ "./src/avformat/formats/mov/writing/dfla.ts");
/* harmony import */ var _dops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dops */ "./src/avformat/formats/mov/writing/dops.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/* harmony import */ var _colr__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colr */ "./src/avformat/formats/mov/writing/colr.ts");
/* harmony import */ var _pasp__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pasp */ "./src/avformat/formats/mov/writing/pasp.ts");
/* harmony import */ var _btrt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./btrt */ "./src/avformat/formats/mov/writing/btrt.ts");
/* harmony import */ var _wave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wave */ "./src/avformat/formats/mov/writing/wave.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _function_digital2Tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../function/digital2Tag */ "./src/avformat/function/digital2Tag.ts");
/*
 * libmedia mp4 stsd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */













const AVCodecID2Tag = {
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: "avc1" /* BoxType.AVC1 */,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: "hvc1" /* BoxType.HVC1 */,
    [226 /* AVCodecID.AV_CODEC_ID_AV1 */]: "av01" /* BoxType.AV01 */,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: "vp09" /* BoxType.VP09 */
};
function getTag(codecpar) {
    if (codecpar.codecTag) {
        return (0,_function_digital2Tag__WEBPACK_IMPORTED_MODULE_0__["default"])(codecpar.codecTag);
    }
    let tag = AVCodecID2Tag[codecpar.codecId];
    if (!tag) {
        if (codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            tag = "mp4v" /* BoxType.MP4V */;
        }
        else if (codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            if (codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
                tag = "Opus" /* BoxType.OPUS */;
            }
            else if (codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
                tag = "fLaC" /* BoxType.FLAC */;
            }
            else {
                tag = "mp4a" /* BoxType.MP4A */;
            }
        }
        else if (codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            tag = "text" /* BoxType.TEXT */;
        }
        else {
            tag = "none" /* BoxType.NONE */;
        }
    }
    return tag;
}
function writeAudioTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const version = movContext.isom ? 1 : 0;
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // SoundDescription Version
    ioWriter.writeUint16(version);
    // SoundDescription Revision level
    ioWriter.writeUint16(0);
    // Reserved
    ioWriter.writeUint32(0);
    if (movContext.isom) {
        ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        if (stream.codecpar.codecId === 65541 /* AVCodecID.AV_CODEC_ID_PCM_U8 */
            || stream.codecpar.codecId === 65540 /* AVCodecID.AV_CODEC_ID_PCM_S8 */) {
            ioWriter.writeUint16(8);
        }
        else if (stream.codecpar.codecId === 69643 /* AVCodecID.AV_CODEC_ID_ADPCM_G726 */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(-2);
    }
    else {
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
            ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        }
        else {
            ioWriter.writeUint16(2);
        }
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(0);
    }
    // packet size (= 0) 
    ioWriter.writeUint16(0);
    if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        ioWriter.writeUint16(48000);
    }
    else if (stream.codecpar.codecId === 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        ioWriter.writeUint32(stream.codecpar.sampleRate);
    }
    else {
        ioWriter.writeUint16(stream.codecpar.sampleRate);
    }
    if (stream.codecpar.codecId !== 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        // Reserved
        ioWriter.writeUint16(0);
    }
    // SoundDescription V1 extended info
    if (version === 1) {
        // Samples per packet
        ioWriter.writeUint32(stream.codecpar.frameSize);
        // Bytes per packet
        ioWriter.writeUint32(0);
        // Bytes per frame
        ioWriter.writeUint32(0);
        // Bytes per sample
        ioWriter.writeUint32(2);
    }
    if (movContext.isom
        && (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */
            || stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */
            || stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */
            || stream.codecpar.codecId === 73728 /* AVCodecID.AV_CODEC_ID_AMR_NB */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 69638 /* AVCodecID.AV_CODEC_ID_ADPCM_MS */
            || stream.codecpar.codecId === 69633 /* AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV */
            || stream.codecpar.codecId === 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */)) {
        (0,_wave__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
        (0,_dfla__WEBPACK_IMPORTED_MODULE_2__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        (0,_dops__WEBPACK_IMPORTED_MODULE_3__["default"])(ioWriter, stream, movContext);
    }
    else if (tag == "mp4a" /* BoxType.MP4A */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_4__["default"])(ioWriter, stream, movContext);
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeVideoTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const uncompressedYcbcr = ((stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
        && stream.codecpar.format == 15 /* AVPixelFormat.AV_PIX_FMT_UYVY422 */)
        || (stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
            && stream.codecpar.format == 1 /* AVPixelFormat.AV_PIX_FMT_YUYV422 */)
        || stream.codecpar.codecId == 203 /* AVCodecID.AV_CODEC_ID_V308 */
        || stream.codecpar.codecId == 204 /* AVCodecID.AV_CODEC_ID_V408 */
        || stream.codecpar.codecId == 156 /* AVCodecID.AV_CODEC_ID_V410 */
        || stream.codecpar.codecId == 127 /* AVCodecID.AV_CODEC_ID_V210 */);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // Codec stream version
    ioWriter.writeUint16(uncompressedYcbcr ? 2 : 0);
    // Codec stream revision (=0)
    ioWriter.writeUint16(0);
    // Reserved
    if (movContext.isom) {
        ioWriter.writeString('FFMP');
        if (stream.codecpar.codecId === 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */ || uncompressedYcbcr) {
            /* Temporal Quality */
            ioWriter.writeUint32(0);
            /* Spatial Quality = lossless*/
            ioWriter.writeUint32(0x400);
        }
        else {
            /* Temporal Quality = normal */
            ioWriter.writeUint32(0x200);
            /* Spatial Quality = normal */
            ioWriter.writeUint32(0x200);
        }
    }
    else {
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
    }
    ioWriter.writeUint16(stream.codecpar.width);
    ioWriter.writeUint16(stream.codecpar.height);
    // Horizontal resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Vertical resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Data size (= 0)
    ioWriter.writeUint32(0);
    // Frame count (= 1)
    ioWriter.writeUint16(1);
    let compressorName = (stream.metadata['compressorName'] || '');
    compressorName = compressorName.slice(0, 31);
    ioWriter.writeUint8(compressorName.length);
    ioWriter.writeString(compressorName);
    if (compressorName.length < 31) {
        let len = 31 - compressorName.length;
        while (len > 0) {
            ioWriter.writeUint8(0);
            len--;
        }
    }
    // Reserved
    if (movContext.isom && stream.codecpar.bitsPerCodedSample) {
        ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
    }
    else {
        ioWriter.writeUint16(0x18);
    }
    ioWriter.writeUint16(0xffff);
    if (tag === "mp4v" /* BoxType.MP4V */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_4__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        (0,_avcc__WEBPACK_IMPORTED_MODULE_6__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        (0,_hvcc__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        (0,_vpcc__WEBPACK_IMPORTED_MODULE_8__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        (0,_av1c__WEBPACK_IMPORTED_MODULE_9__["default"])(ioWriter, stream, movContext);
    }
    (0,_colr__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    (0,_pasp__WEBPACK_IMPORTED_MODULE_11__["default"])(ioWriter, stream, movContext);
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeSubtitleTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_4__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.extradata) {
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_12__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("stsd" /* BoxType.STSD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    // entry count
    ioWriter.writeUint32(1);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        writeAudioTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        writeVideoTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        writeSubtitleTag(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stss.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stss.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stss box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleNumbers = stream.privData.stssSampleNumbers;
    // size
    ioWriter.writeUint32(16 + sampleNumbers.length * 4);
    // tag
    ioWriter.writeString("stss" /* BoxType.STSS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(sampleNumbers.length);
    for (let i = 0; i < sampleNumbers.length; i++) {
        ioWriter.writeUint32(sampleNumbers[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsz.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsz.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stsz box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleSizes = stream.privData.sampleSizes;
    // size
    ioWriter.writeUint32(20 + sampleSizes.length * 4);
    // tag
    ioWriter.writeString("stsz" /* BoxType.STSZ */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(sampleSizes.length);
    for (let i = 0; i < sampleSizes.length; i++) {
        ioWriter.writeUint32(sampleSizes[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/formats/mov/writing/stts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.sttsSampleCounts || [];
    const sampleDeltas = context.sttsSampleDeltas || [];
    if (sampleCounts.length !== sampleDeltas.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('stts sampleCounts\'s length is not match sampleDeltas\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleDeltas.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("stts" /* BoxType.STTS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleDeltas[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfdt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfdt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfdt box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const baseMediaDecodeTime = track ? track.baseMediaDecodeTime : BigInt(0);
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("tfdt" /* BoxType.TFDT */);
    // version use int64
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint64(baseMediaDecodeTime);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    let flags = 1 /* TFHDFlags.BASE_DATA_OFFSET */
        | 8 /* TFHDFlags.SAMPLE_DURATION */
        | 16 /* TFHDFlags.SAMPLE_SIZE */
        | 32 /* TFHDFlags.SAMPLE_FLAGS */;
    if (track.baseIsMoof) {
        flags &= ~1 /* TFHDFlags.BASE_DATA_OFFSET */;
        flags |= 131072 /* TFHDFlags.DEFAULT_BASE_IS_MOOF */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("tfhd" /* BoxType.TFHD */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(track.trackId);
    if (flags & 1 /* TFHDFlags.BASE_DATA_OFFSET */) {
        ioWriter.writeUint64(track.baseDataOffset);
    }
    if (flags & 8 /* TFHDFlags.SAMPLE_DURATION */) {
        ioWriter.writeUint32(track.defaultSampleDuration);
    }
    if (flags & 16 /* TFHDFlags.SAMPLE_SIZE */) {
        ioWriter.writeUint32(track.defaultSampleSize);
    }
    if (flags & 32 /* TFHDFlags.SAMPLE_FLAGS */) {
        ioWriter.writeUint32(track.defaultSampleFlags);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "tfhd" /* BoxType.TFHD */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tkhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tkhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 tkhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_0__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const layer = streamContext.layer || 0;
    const alternateGroup = streamContext.alternateGroup || 0;
    let width = stream.codecpar.width > 0 ? stream.codecpar.width : 0;
    let height = stream.codecpar.height > 0 ? stream.codecpar.height : 0;
    if (width < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.UINT16_MAX) {
        width = width << 16;
    }
    if (height < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.UINT16_MAX) {
        height = height << 16;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_1__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_1__.UINT32_MAX ? 0 : 1;
    let flags = 2 /* TKHDFlags.IN_MOVIE */;
    if (streamContext.flags & 1 /* TKHDFlags.ENABLED */) {
        flags |= 1 /* TKHDFlags.ENABLED */;
    }
    // size
    ioWriter.writeUint32(version === 1 ? 100 : 92);
    // tag
    ioWriter.writeString("tkhd" /* BoxType.TKHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(flags);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // trackId
    ioWriter.writeUint32(streamContext.trackId);
    // reserved
    ioWriter.writeUint32(0);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeInt16(layer);
    ioWriter.writeInt16(streamContext.perStreamGrouping ? alternateGroup : stream.codecpar.codecType);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        ioWriter.writeInt16(0x0100);
    }
    else {
        ioWriter.writeInt16(0);
    }
    // reserved
    ioWriter.writeInt16(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    ioWriter.writeUint32(width);
    ioWriter.writeUint32(height);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trex.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trex.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trex box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const trex = movContext.trexs.find((trex) => {
        trex.trackId === stream.privData.trackId;
    });
    const duration = trex?.duration ?? 0;
    const size = trex?.size ?? 0;
    const flags = trex?.flags ?? 0;
    // size
    ioWriter.writeUint32(32);
    // tag
    ioWriter.writeString("trex" /* BoxType.TREX */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(track.trackId);
    // default_sample_description_index
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(duration);
    ioWriter.writeUint32(size);
    ioWriter.writeUint32(flags);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trun.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trun.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trun box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === streamContext.trackId;
    });
    const firstSampleFlags = track.firstSampleFlags || 0;
    const dataOffset = track.dataOffset || 0;
    const sampleDurations = track.sampleDurations;
    const sampleSizes = track.sampleSizes;
    const sampleFlags = track.sampleFlags;
    const sampleCompositionTimeOffset = track.sampleCompositionTimeOffset;
    const sampleCount = track.sampleCount;
    const hasSampleDurations = sampleDurations.length > 0;
    const hasSampleSizes = sampleSizes.length > 0;
    const hasSampleFlags = sampleFlags.length > 0;
    const hasSampleCompositionTimeOffset = sampleCompositionTimeOffset.length > 0;
    const hasFirstFlag = firstSampleFlags !== 0;
    let flags = 1 /* TRUNFlags.DATA_OFFSET */;
    if (hasFirstFlag) {
        flags |= 4 /* TRUNFlags.FIRST_FLAG */;
    }
    if (hasSampleDurations) {
        flags |= 256 /* TRUNFlags.DURATION */;
    }
    if (hasSampleSizes) {
        flags |= 512 /* TRUNFlags.SIZE */;
    }
    if (hasSampleFlags) {
        flags |= 1024 /* TRUNFlags.FLAGS */;
    }
    if (hasSampleCompositionTimeOffset) {
        flags |= 2048 /* TRUNFlags.CTS_OFFSET */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("trun" /* BoxType.TRUN */);
    // version use int32
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(sampleCount);
    track.dataOffsetPos = ioWriter.getPos();
    ioWriter.writeInt32(dataOffset);
    if (hasFirstFlag) {
        ioWriter.writeUint32(firstSampleFlags);
    }
    for (let i = 0; i < sampleCount; i++) {
        if (hasSampleDurations) {
            ioWriter.writeUint32(sampleDurations[i] || 0);
        }
        if (hasSampleSizes) {
            ioWriter.writeUint32(sampleSizes[i] || 0);
        }
        if (hasSampleFlags) {
            ioWriter.writeUint32(sampleFlags[i] || 0);
        }
        if (hasSampleCompositionTimeOffset) {
            ioWriter.writeInt32(sampleCompositionTimeOffset[i] || 0);
        }
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "trun" /* BoxType.TRUN */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vmhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vmhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 vmhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("vmhd" /* BoxType.VMHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(1);
    // reserved (graphics mode = copy)
    ioWriter.writeUint64(BigInt(0));
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vpcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vpcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 vpcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("vpcC" /* BoxType.VPCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/wave.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/wave.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/*
 * libmedia mp4 wave box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("wave" /* BoxType.WAVE */);
    if (stream.codecpar.codecId !== 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */) {
        ioWriter.writeUint32(12);
        ioWriter.writeString("frma" /* BoxType.FRMA */);
        ioWriter.writeUint32(stream.codecpar.codecTag);
    }
    if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        // seless atom needed by mplayer, ipod, not needed by quicktime
        ioWriter.writeUint32(12);
        ioWriter.writeString("mp4a" /* BoxType.MP4A */);
        ioWriter.writeUint32(0);
        (0,_esds__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, stream, movContext);
    }
    else {
        if (movContext.fragment) {
            if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
                ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
                delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            }
            else {
                if (stream.codecpar.extradata) {
                    ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
                }
            }
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    // null tag
    ioWriter.writeUint32(8);
    ioWriter.writeUint32(0);
    movContext.boxsPositionInfo.push({
        pos,
        type: "wave" /* BoxType.WAVE */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/writers.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/formats/mov/writing/writers.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stts */ "./src/avformat/formats/mov/writing/stts.ts");
/* harmony import */ var _ctts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctts */ "./src/avformat/formats/mov/writing/ctts.ts");
/* harmony import */ var _stss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stss */ "./src/avformat/formats/mov/writing/stss.ts");
/* harmony import */ var _stsz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stsz */ "./src/avformat/formats/mov/writing/stsz.ts");
/* harmony import */ var _stsc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stsc */ "./src/avformat/formats/mov/writing/stsc.ts");
/* harmony import */ var _stco__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stco */ "./src/avformat/formats/mov/writing/stco.ts");
/* harmony import */ var _co64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./co64 */ "./src/avformat/formats/mov/writing/co64.ts");
/* harmony import */ var _mdhd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mdhd */ "./src/avformat/formats/mov/writing/mdhd.ts");
/* harmony import */ var _mvhd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mvhd */ "./src/avformat/formats/mov/writing/mvhd.ts");
/* harmony import */ var _tkhd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tkhd */ "./src/avformat/formats/mov/writing/tkhd.ts");
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/* harmony import */ var _stsd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stsd */ "./src/avformat/formats/mov/writing/stsd.ts");
/* harmony import */ var _vmhd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./vmhd */ "./src/avformat/formats/mov/writing/vmhd.ts");
/* harmony import */ var _edts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./edts */ "./src/avformat/formats/mov/writing/edts.ts");
/* harmony import */ var _smhd__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./smhd */ "./src/avformat/formats/mov/writing/smhd.ts");
/* harmony import */ var _dref__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dref */ "./src/avformat/formats/mov/writing/dref.ts");
/* harmony import */ var _trex__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./trex */ "./src/avformat/formats/mov/writing/trex.ts");
/* harmony import */ var _mfhd__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./mfhd */ "./src/avformat/formats/mov/writing/mfhd.ts");
/* harmony import */ var _tfhd__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tfhd */ "./src/avformat/formats/mov/writing/tfhd.ts");
/* harmony import */ var _tfdt__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tfdt */ "./src/avformat/formats/mov/writing/tfdt.ts");
/* harmony import */ var _trun__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./trun */ "./src/avformat/formats/mov/writing/trun.ts");
/* harmony import */ var _minfHdlr__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./minfHdlr */ "./src/avformat/formats/mov/writing/minfHdlr.ts");
/*
 * libmedia mp4 box writers
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






















const writers = {
    ["stts" /* BoxType.STTS */]: _stts__WEBPACK_IMPORTED_MODULE_0__["default"],
    ["ctts" /* BoxType.CTTS */]: _ctts__WEBPACK_IMPORTED_MODULE_1__["default"],
    ["stss" /* BoxType.STSS */]: _stss__WEBPACK_IMPORTED_MODULE_2__["default"],
    ["stsz" /* BoxType.STSZ */]: _stsz__WEBPACK_IMPORTED_MODULE_3__["default"],
    ["stsc" /* BoxType.STSC */]: _stsc__WEBPACK_IMPORTED_MODULE_4__["default"],
    ["stco" /* BoxType.STCO */]: _stco__WEBPACK_IMPORTED_MODULE_5__["default"],
    ["co64" /* BoxType.CO64 */]: _co64__WEBPACK_IMPORTED_MODULE_6__["default"],
    ["mdhd" /* BoxType.MDHD */]: _mdhd__WEBPACK_IMPORTED_MODULE_7__["default"],
    ["mvhd" /* BoxType.MVHD */]: _mvhd__WEBPACK_IMPORTED_MODULE_8__["default"],
    ["tkhd" /* BoxType.TKHD */]: _tkhd__WEBPACK_IMPORTED_MODULE_9__["default"],
    ["hdlr" /* BoxType.HDLR */]: _hdlr__WEBPACK_IMPORTED_MODULE_10__["default"],
    ["stsd" /* BoxType.STSD */]: _stsd__WEBPACK_IMPORTED_MODULE_11__["default"],
    ["vmhd" /* BoxType.VMHD */]: _vmhd__WEBPACK_IMPORTED_MODULE_12__["default"],
    ["edts" /* BoxType.EDTS */]: _edts__WEBPACK_IMPORTED_MODULE_13__["default"],
    ["smhd" /* BoxType.SMHD */]: _smhd__WEBPACK_IMPORTED_MODULE_14__["default"],
    ["dref" /* BoxType.DREF */]: _dref__WEBPACK_IMPORTED_MODULE_15__["default"],
    ["trex" /* BoxType.TREX */]: _trex__WEBPACK_IMPORTED_MODULE_16__["default"],
    ["mfhd" /* BoxType.MFHD */]: _mfhd__WEBPACK_IMPORTED_MODULE_17__["default"],
    ["tfhd" /* BoxType.TFHD */]: _tfhd__WEBPACK_IMPORTED_MODULE_18__["default"],
    ["tfdt" /* BoxType.TFDT */]: _tfdt__WEBPACK_IMPORTED_MODULE_19__["default"],
    ["trun" /* BoxType.TRUN */]: _trun__WEBPACK_IMPORTED_MODULE_20__["default"],
    ["minf_hdlr" /* BoxType.MINF_HDLR */]: _minfHdlr__WEBPACK_IMPORTED_MODULE_21__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (writers);


/***/ }),

/***/ "./src/avformat/function/arrayItemSame.ts":
/*!************************************************!*\
  !*** ./src/avformat/function/arrayItemSame.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ arrayItemSame)
/* harmony export */ });
/*
 * libmedia array item is all same
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function arrayItemSame(data, start = 0) {
    if (!data) {
        return false;
    }
    if (data.length < 2) {
        return true;
    }
    let first = data[start];
    let i = start + 1;
    for (; i < data.length; i++) {
        if (first !== data[i]) {
            break;
        }
    }
    return i === data.length;
}


/***/ }),

/***/ "./src/avformat/function/checkStreamParameters.ts":
/*!********************************************************!*\
  !*** ./src/avformat/function/checkStreamParameters.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkStreamParameters: () => (/* binding */ checkStreamParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia check stream parameters
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function checkStreamParameters(context) {
    let result = true;
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(context.streams, (stream) => {
        switch (stream.codecpar.codecType) {
            case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                if (stream.codecpar.chLayout.nbChannels === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.sampleRate === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.frameSize === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                break;
            case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D)(stream.codecpar.framerate) === 0
                    || stream.codecpar.width === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.height === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                    || stream.codecpar.codecId === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */)
                    && (stream.codecpar.profile === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                        || stream.codecpar.level === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE)) {
                    result = false;
                }
                break;
        }
    });
    return result;
}


/***/ }),

/***/ "./src/avformat/function/digital2Tag.ts":
/*!**********************************************!*\
  !*** ./src/avformat/function/digital2Tag.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ digital2Tag)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia number to tag string
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function digital2Tag(value, len = 4) {
    let tag = '';
    for (let i = 0; i < len; i++) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(value)) {
            tag = String.fromCharCode(value & 0xff) + tag;
            value >>>= 8;
        }
        else {
            tag = String.fromCharCode(Number(value & BigInt(0xff))) + tag;
            value >>= BigInt(8);
        }
    }
    return tag;
}


/***/ }),

/***/ "./src/avformat/function/mktag.ts":
/*!****************************************!*\
  !*** ./src/avformat/function/mktag.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mktag)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/function/mktag.ts";
/*
 * libmedia string tag to uint32 in little end
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function mktag(tag) {
    if (tag.length !== 4) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`tag length is not 4, tag: ${tag}`, cheap__fileName__0, 30);
    }
    let value = 0;
    for (let i = 0; i < 4; i++) {
        value = (value << 8) | tag.charCodeAt(i);
    }
    return value;
}


/***/ }),

/***/ "./src/avformat/function/rewriteIO.ts":
/*!********************************************!*\
  !*** ./src/avformat/function/rewriteIO.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rewriteIO)
/* harmony export */ });
/*
 * libmedia rewrite value with pos
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function rewriteIO(ioWriter, pos, value, type) {
    const nowPos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = nowPos - BigInt(Math.floor(pointer));
    let inline = false;
    if (pos < nowPos && pos >= minPos) {
        ioWriter.seekInline(pointer + Number(pos - nowPos));
        inline = true;
    }
    else {
        ioWriter.seek(pos);
    }
    switch (type) {
        case 'uint8':
            ioWriter.writeUint8((value & 0xff));
            break;
        case 'int8':
            ioWriter.writeInt8(value);
            break;
        case 'uint16':
            ioWriter.writeUint16((value & 0xffff));
            break;
        case 'int16':
            ioWriter.writeInt16(value);
            break;
        case 'uint32':
            ioWriter.writeUint32((value >>> 0));
            break;
        case 'int32':
            ioWriter.writeInt32(value);
            break;
        case 'uint64':
            ioWriter.writeUint64(BigInt.asUintN(64, value));
            break;
        case 'int64':
            ioWriter.writeInt64(value);
            break;
        case 'float':
            ioWriter.writeFloat(value);
            break;
        case 'double':
            ioWriter.writeDouble(value);
            break;
    }
    if (inline) {
        ioWriter.seekInline(pointer);
    }
    else {
        ioWriter.seek(nowPos);
    }
}


/***/ }),

/***/ "./src/avformat/mux.ts":
/*!*****************************!*\
  !*** ./src/avformat/mux.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   writeAVPacket: () => (/* binding */ writeAVPacket),
/* harmony export */   writeHeader: () => (/* binding */ writeHeader),
/* harmony export */   writeTrailer: () => (/* binding */ writeTrailer)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/mux.ts";




const defaultMuxOptions = {
    paddingZero: false
};
function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, defaultMuxOptions, options);
    if (!formatContext.ioWriter) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need ioWriter', cheap__fileName__0, 46);
    }
    if (!formatContext.oformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need oformat', cheap__fileName__0, 49);
    }
    formatContext.options = opts;
    formatContext.processPrivateData = {
        first: new Map()
    };
    return formatContext.oformat.init(formatContext);
}
function writeHeader(formatContext) {
    formatContext.oformat.writeHeader(formatContext);
}
function writeAVPacket(formatContext, avpacket) {
    const privateData = formatContext.processPrivateData;
    if (!privateData.first.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32))) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) > BigInt(0)) {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16));
        }
        else {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32), BigInt(0));
        }
    }
    if (formatContext.options.paddingZero) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](avpacket + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)));
    }
    return formatContext.oformat.writeAVPacket(formatContext, avpacket);
}
function writeTrailer(formatContext) {
    formatContext.oformat.writeTrailer(formatContext);
}
function flush(formatContext) {
    formatContext.oformat.flush(formatContext);
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FetchIOLoader.ts":
/*!*************************************************!*\
  !*** ./src/avnetwork/ioLoader/FetchIOLoader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FetchIOLoader)
/* harmony export */ });
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avnetwork/ioLoader/FetchIOLoader.ts";
/*
 * libmedia fetch loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class FetchIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    contentLength;
    receivedLength;
    info;
    range;
    startBytes;
    endBytes;
    eofIndex;
    abortController;
    reader;
    buffers;
    constructor(options = {}) {
        super(options);
    }
    async open(info, range) {
        this.info = info;
        this.range = range;
        if (!this.range.to) {
            this.range.to = -1;
        }
        this.range.from = Math.max(this.range.from, 0);
        if (this.eofIndex < 0) {
            this.eofIndex = range.to;
        }
        this.startBytes = 0;
        this.endBytes = -1;
        this.receivedLength = 0;
        this.buffers = [];
        if (this.range && !this.options.isLive) {
            this.startBytes = this.range.from ?? 0;
        }
        this.status = 1 /* IOLoaderStatus.CONNECTING */;
        if (!this.options.isLive && !this.options.disableSegment) {
            const params = {
                method: 'HEAD',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (this.info.headers) {
                common_util_object__WEBPACK_IMPORTED_MODULE_1__.each(this.info.headers, (value, key) => {
                    params.headers[key] = value;
                });
            }
            if (this.info.withCredentials) {
                params.credentials = 'include';
            }
            if (this.info.referrerPolicy) {
                params.referrerPolicy = this.info.referrerPolicy;
            }
            if (AbortController) {
                this.abortController = new AbortController();
                params.signal = this.abortController.signal;
            }
            try {
                const res = await fetch(this.info.url, params);
                if (res.ok && (res.status >= 200 && res.status <= 299)) {
                    const lengthHeader = res.headers.get('X-Content-Length') || res.headers.get('Content-Length');
                    if (lengthHeader != null) {
                        this.contentLength = parseInt(lengthHeader);
                        if (this.range.to < 0) {
                            this.eofIndex = this.contentLength + this.range.to;
                        }
                    }
                    this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                    this.status = 2 /* IOLoaderStatus.BUFFERING */;
                }
                else {
                    this.endBytes = -1;
                }
            }
            catch (error) {
                this.endBytes = -1;
            }
        }
    }
    async openReader() {
        const params = {
            method: 'GET',
            headers: {},
            mode: 'cors',
            cache: 'default',
            referrerPolicy: 'no-referrer-when-downgrade'
        };
        if (this.info.headers) {
            common_util_object__WEBPACK_IMPORTED_MODULE_1__.each(this.info.headers, (value, key) => {
                params.headers[key] = value;
            });
        }
        if (!this.options.isLive) {
            params.headers['range'] = `bytes=${this.startBytes}-${this.endBytes > 0 ? this.endBytes : ''}`;
        }
        if (this.info.withCredentials) {
            params.credentials = 'include';
        }
        if (this.info.referrerPolicy) {
            params.referrerPolicy = this.info.referrerPolicy;
        }
        if (this.abortController) {
            this.abortController.abort();
        }
        if (typeof AbortController === 'function') {
            this.abortController = new AbortController();
            params.signal = this.abortController.signal;
        }
        try {
            const res = await fetch(this.info.url, params);
            if (res.ok && (res.status >= 200 && res.status <= 299)) {
                this.reader = res.body.getReader();
            }
            else {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`FetchStreamLoader: Http code invalid, ${res.status} ${res.statusText}`, cheap__fileName__0, 189);
            }
        }
        catch (error) {
            if (this.retryCount < this.options.retryCount && (!this.options.isLive || !this.receivedLength)) {
                this.retryCount++;
                this.status = 1 /* IOLoaderStatus.CONNECTING */;
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_3__["default"](this.options.retryInterval);
                return this.openReader();
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`FetchStreamLoader: exception ${error.message}`, cheap__fileName__0, 202);
            }
        }
    }
    async readInterval(buffer, preLen = 0) {
        let pos = 0;
        while (this.buffers.length && pos < buffer.length) {
            const cache = this.buffers.shift();
            if (cache.length > buffer.length - pos) {
                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                this.buffers.unshift(cache.subarray(buffer.length - pos));
                pos = buffer.length;
            }
            else {
                buffer.set(cache, pos);
                pos += cache.length;
            }
        }
        if (pos >= buffer.length) {
            return buffer.length + preLen;
        }
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
        }
        if (!this.reader) {
            await this.openReader();
        }
        const { value, done } = await this.reader.read();
        if (done) {
            if (this.contentLength !== null && (this.receivedLength + this.range.from) < this.endBytes + 1) {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('Fetch stream meet Early-EOF', cheap__fileName__0, 241);
            }
            else if (this.options.isLive || this.options.disableSegment || (this.receivedLength + this.range.from) >= this.eofIndex) {
                this.status = 4 /* IOLoaderStatus.COMPLETE */;
                this.startBytes = 0;
                return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
            }
            else {
                await this.reader.cancel();
                if (this.abortController) {
                    this.abortController.abort();
                }
                this.reader = null;
                this.startBytes = this.endBytes + 1;
                this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                return this.readInterval(buffer.subarray(pos), pos);
            }
        }
        else {
            this.receivedLength += value.length;
            if (value.length > buffer.length - pos) {
                buffer.set(value.subarray(0, buffer.length - pos), pos);
                this.buffers.push(value.subarray(buffer.length - pos));
                return buffer.length + preLen;
            }
            else {
                buffer.set(value, pos);
                pos += value.length;
                return pos + preLen;
            }
        }
    }
    async read(buffer) {
        return this.readInterval(buffer);
    }
    async seek(pos) {
        await this.abort();
        this.receivedLength = Number(pos) - this.range.from;
        this.startBytes = Number(pos);
        if (!this.options.disableSegment) {
            this.endBytes = Math.min(this.startBytes + this.options.preload, this.eofIndex);
        }
        this.buffers.length = 0;
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        0;
    }
    async size() {
        if (this.options.isLive) {
            return BigInt(0);
        }
        return BigInt(Math.floor(this.contentLength));
    }
    async abort() {
        if (!this.reader) {
            return;
        }
        await this.reader.cancel();
        if (this.abortController) {
            this.abortController.abort();
        }
        this.reader = null;
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FileIOLoader.ts":
/*!************************************************!*\
  !*** ./src/avnetwork/ioLoader/FileIOLoader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileIOLoader)
/* harmony export */ });
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia file loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class FileIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    info;
    range;
    readPos;
    endPos;
    reader;
    readerResolve;
    async open(info, range) {
        this.info = info;
        this.range = range;
        this.readPos = 0;
        this.endPos = this.info.file.size;
        if (range.from > 0) {
            this.readPos = range.from;
        }
        if (range.to > 0) {
            this.endPos = range.to;
        }
        this.status = 2 /* IOLoaderStatus.BUFFERING */;
    }
    async readBufferByReader(len) {
        if (!this.reader) {
            this.reader = new FileReader();
            this.reader.onloadend = (event) => {
                if (this.readerResolve) {
                    this.readerResolve(event.target.result);
                }
            };
        }
        const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        return new Promise((resolve) => {
            this.readerResolve = resolve;
            this.reader.readAsArrayBuffer(blobSlice.call(this.info.file, this.readPos, this.readPos + len));
        });
    }
    async read(buffer) {
        if (this.readPos >= this.endPos) {
            this.status === 4 /* IOLoaderStatus.COMPLETE */;
            return -1048576 /* IOError.END */;
        }
        const len = Math.min(buffer.length, this.endPos - this.readPos);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(Blob.prototype.arrayBuffer)) {
            buffer.set(new Uint8Array(await (this.info.file.slice(this.readPos, this.readPos + len).arrayBuffer())), 0);
        }
        else {
            buffer.set(new Uint8Array(await this.readBufferByReader(len)), 0);
        }
        this.readPos += len;
        if (this.readPos >= this.endPos) {
            this.status = 4 /* IOLoaderStatus.COMPLETE */;
        }
        return len;
    }
    async seek(pos) {
        await this.abort();
        this.readPos = Number(pos);
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        return 0;
    }
    async size() {
        return BigInt(Math.floor(this.info.file.size));
    }
    async abort() {
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/IOLoader.ts":
/*!********************************************!*\
  !*** ./src/avnetwork/ioLoader/IOLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOLoader)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia abstract loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const optionsDefault = {
    isLive: true,
    preload: 5242880,
    retryCount: 20,
    retryInterval: 1
};
class IOLoader {
    options;
    status;
    retryCount;
    retryTimeout;
    constructor(options = {}) {
        this.options = options;
        this.status = 0 /* IOLoaderStatus.IDLE */;
        this.retryCount = 0;
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, optionsDefault);
        common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(this.options, options);
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioDecodePipeline)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
var cheap__fileName__2 = "src/avpipeline/AudioDecodePipeline.ts";




/*
 * libmedia AudioDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










class AudioDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_2__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_4__["default"]), options.avframeListMutex);
        const decoder = new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_5__["default"]({
            resource: options.resource,
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`audio decode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__2, 88);
                const task = this.tasks.get(options.taskId);
                if (task.openReject) {
                    task.openReject(error);
                    task.openReject = null;
                }
            },
            onReceiveFrame(frame) {
                frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](task.stats + 216, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_9__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[15](task.stats + 216)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_9__["default"])();
            },
            avframePool: avframePool
        });
        // const decoder = new WebAudioDecoder({
        //   onError: (error) => {
        //     logger.error(`audio decode error, taskId: ${options.taskId}, error: ${error}`)
        //     const task = this.tasks.get(options.taskId)
        //     if (task.openReject) {
        //       task.openReject(error)
        //       task.openReject = null
        //     }
        //   },
        //   onReceiveFrame(frame) {
        //     logger.info(`receive audio frame, pts: ${frame.timestamp}`)
        //     frame.close()
        //     // frameCaches.push(reinterpret_cast<pointer<AVFrameRef>>(frame))
        //   },
        // })
        const task = {
            ...options,
            frameCaches,
            inputEnd: false,
            decoder,
            lastDecodeTimestamp: 0,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_4__["default"]), options.avpacketListMutex)
        };
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame);
                                break;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                await task.decoder.flush();
                                task.inputEnd = true;
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info(`audio decoder ended, taskId: ${task.taskId}`, cheap__fileName__2, 165);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                const ret = task.decoder.decode(avpacket);
                                task.avpacketPool.release(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](task.stats + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[15](task.stats + 48) + 1);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`audio decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__2, 177);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`audio decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__2, 184);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async open(taskId, parameters, timeBase) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                await task.decoder.open(parameters);
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_6__.fatal('task not found', cheap__fileName__2, 209);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.decoder) {
                await task.decoder.flush();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(task.frameCaches, (frame) => {
                task.avframePool.release(frame);
            });
            task.frameCaches.length = 0;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_9__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info(`reset audio decoder, taskId: ${task.taskId}`, cheap__fileName__2, 225);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_12__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            task.decoder.close();
            task.frameCaches.forEach((frame) => {
                task.avframePool.release(frame);
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioRenderPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_collection_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/collection/List */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var audioresample_Resampler__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! audioresample/Resampler */ "./src/audioresample/Resampler.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/implement/AVPCMBufferPoolImpl */ "./src/avutil/implement/AVPCMBufferPoolImpl.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! audiostretchpitch/StretchPitcher */ "./src/audiostretchpitch/StretchPitcher.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
var cheap__fileName__3 = "src/avpipeline/AudioRenderPipeline.ts";







/*
 * libmedia AudioRenderPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


















class AudioRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    avPCMBufferPool;
    avPCMBufferList;
    constructor() {
        super();
        this.avPCMBufferList = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])((cheap_std_collection_List__WEBPACK_IMPORTED_MODULE_2__["default"]));
        this.avPCMBufferPool = new avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_3__["default"](this.avPCMBufferList);
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](options.rightPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            controlIPCPort,
            resampler: null,
            stretchpitcher: new Map(),
            outPCMBuffer: null,
            waitPCMBuffer: 0,
            waitAVFrame: 0,
            waitPCMBufferPos: 0,
            frameEnded: false,
            stretchpitcherEnded: false,
            playRate: 1,
            playTempo: 1,
            playPitch: 1,
            useStretchpitcher: false,
            lastNotifyPTS: BigInt(0),
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT,
            firstPlayed: false,
            seeking: false,
            pausing: false,
            seekSync: null,
            receivePCMSync: null,
            paddingAVFrame: 0,
            fakePlayStartTimestamp: 0,
            fakePlaySamples: BigInt(0),
            fakePlayTimer: null,
            fakePlay: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_6__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(options.avframeList, cheap_std_collection_List__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
        for (let i = 0; i < options.playChannels; i++) {
            const stretchpitcher = new audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_9__["default"]({
                resource: options.stretchpitcherResource
            });
            task.stretchpitcher.set(i, stretchpitcher);
            await stretchpitcher.open({
                sampleRate: options.playSampleRate,
                channels: 1
            });
            stretchpitcher.setTempo(task.playTempo);
            stretchpitcher.setPitch(task.playPitch);
            stretchpitcher.setRate(task.playRate);
        }
        const me = this;
        async function pullNewAudioFrame() {
            let audioFrame;
            if (task.paddingAVFrame) {
                audioFrame = task.paddingAVFrame;
                task.paddingAVFrame = 0;
            }
            else {
                audioFrame = await task.leftIPCPort.request('pull');
            }
            if (audioFrame === -1048576 /* IOError.END */) {
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    stretchpitcher.flush();
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`audio render ended, taskId: ${task.taskId}`, cheap__fileName__3, 201);
                return -1048576 /* IOError.END */;
            }
            else if (audioFrame < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`pull audio frame failed, taskId: ${task.taskId}`, cheap__fileName__3, 205);
                return audioFrame;
            }
            else {
                if (task.playRate !== 1
                    || task.playTempo !== 1
                    || task.playPitch !== 1
                    || task.enableJitterBuffer) {
                    task.useStretchpitcher = true;
                }
                else {
                    task.useStretchpitcher = false;
                }
                if (!task.firstPlayed) {
                    const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                    task.firstPlayed = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`got first audio frame, pts: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](audioFrame + 104)}(${start}ms), taskId: ${task.taskId}`, cheap__fileName__3, 227);
                }
                task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[17](task.stats + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](task.stats + 64) + BigInt(1));
                if (task.lastRenderTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](task.stats + 220, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 220)));
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                let releaseAudioFrame = true;
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168) !== task.playSampleRate || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 80) !== task.playFormat) {
                    if (task.resampler) {
                        const current = task.resampler.getInputPCMParameters();
                        if (current.format !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 80) || current.sampleRate !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168)) {
                            task.resampler.close();
                            task.resampler = null;
                        }
                    }
                    if (!task.resampler) {
                        task.resampler = new audioresample_Resampler__WEBPACK_IMPORTED_MODULE_14__["default"]({
                            resource: task.resamplerResource
                        });
                        await task.resampler.open({
                            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168),
                            format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 80),
                            channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 332)
                        }, {
                            sampleRate: task.playSampleRate,
                            format: task.playFormat,
                            channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 332)
                        });
                    }
                    let pcmBuffer = me.avPCMBufferPool.alloc();
                    let ret = task.resampler.resample(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](audioFrame + 64), pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76));
                    if (ret < 0) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`resample error, ret: ${ret}, taskId: ${task.taskId}`, cheap__fileName__3, 272);
                        return ret;
                    }
                    if (!task.useStretchpitcher) {
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 4));
                        }
                        me.avPCMBufferPool.release(pcmBuffer);
                    }
                }
                else {
                    if (!task.useStretchpitcher) {
                        let pcmBuffer = me.avPCMBufferPool.alloc();
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](pcmBuffer + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](pcmBuffer + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](pcmBuffer + 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 332));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[20](pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](audioFrame + 64));
                        task.waitAVFrame = audioFrame;
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                        releaseAudioFrame = false;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](audioFrame + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76));
                        }
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 332));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](task.stats + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76));
                if (releaseAudioFrame) {
                    task.avframePool.release(audioFrame);
                }
            }
            return 0;
        }
        async function receiveToPCMBuffer(pcmBuffer) {
            let receive = 0;
            if (task.seeking) {
                await new Promise((resolve) => {
                    task.receivePCMSync = resolve;
                });
            }
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 212) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.jitterBuffer)) {
                    me.setPlayRate(task.taskId, 1);
                }
            }
            if (task.frameEnded && task.useStretchpitcher) {
                let ret = 0;
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                        ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive);
                    }
                }
                if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8)) {
                    task.stretchpitcherEnded = true;
                    for (let i = 0; i < task.playChannels; i++) {
                        // 将不足的置为 0 
                        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_15__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive) * 4);
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](pcmBuffer + 4, receive);
                return 0;
            }
            while (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8)) {
                let len = 0;
                if (!task.useStretchpitcher) {
                    if (task.waitPCMBuffer) {
                        len = Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.waitPCMBuffer + 4) - task.waitPCMBufferPos, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive);
                        if (len) {
                            for (let i = 0; i < task.playChannels; i++) {
                                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_15__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](task.waitPCMBuffer) + (i * 4)) + task.waitPCMBufferPos * 4, len * 4);
                            }
                            task.waitPCMBufferPos += len;
                        }
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.waitPCMBuffer + 4) === task.waitPCMBufferPos) {
                            if (task.waitAVFrame) {
                                // data 是 avframe 的引用，这里需要置空，防止 waitPCMBuffer 释放的时候将 avframe 的内存释放了
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                                task.avframePool.release(task.waitAVFrame);
                                task.waitAVFrame = 0;
                            }
                            me.avPCMBufferPool.release(task.waitPCMBuffer);
                            task.waitPCMBuffer = 0;
                        }
                    }
                }
                else {
                    for (let i = 0; i < task.playChannels; i++) {
                        const stretchpitcher = task.stretchpitcher.get(i);
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                            len = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive);
                        }
                    }
                }
                receive += len;
                if (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8)) {
                    let ret = await pullNewAudioFrame();
                    if (ret === -1048576 /* IOError.END */) {
                        task.frameEnded = true;
                        if (task.useStretchpitcher) {
                            for (let i = 0; i < task.playChannels; i++) {
                                const stretchpitcher = task.stretchpitcher.get(i);
                                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                                    stretchpitcher.flush();
                                    ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive);
                                }
                            }
                            if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8)) {
                                task.stretchpitcherEnded = true;
                                for (let i = 0; i < task.playChannels; i++) {
                                    // 将不足的置为 0 
                                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_15__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) - receive) * 4);
                                }
                            }
                            receive += ret;
                        }
                        break;
                    }
                    else if (ret < 0) {
                        return ret;
                    }
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[15](pcmBuffer + 4, receive);
            if (task.currentPTS - task.lastNotifyPTS >= BigInt(1000)) {
                task.lastNotifyPTS = task.currentPTS;
                const latency = (((task.useStretchpitcher ? task.stretchpitcher.get(0).getLatency() : 0)
                    // 双缓冲，假定后缓冲播放到中间
                    + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](pcmBuffer + 8) * 3 >>> 1)) / task.playSampleRate * 1000) >>> 0;
                task.controlIPCPort.notify('syncPts', {
                    pts: common_util_bigint__WEBPACK_IMPORTED_MODULE_16__.max(task.currentPTS - BigInt(Math.floor(latency)), BigInt(0))
                });
            }
            if (task.seekSync) {
                task.seekSync();
                task.seekSync = null;
            }
            return 0;
        }
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const pcmBuffer = request.params.buffer;
                    const ret = await receiveToPCMBuffer(pcmBuffer);
                    rightIPCPort.reply(request, ret);
                    break;
                }
                case 'pullBuffer': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const nbSamples = request.params.nbSamples;
                    if (!task.outPCMBuffer || task.outPCMBuffer.maxnbSamples !== nbSamples) {
                        if (task.outPCMBuffer) {
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(task.outPCMBuffer.data);
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_18__.symbolStructAddress]);
                            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_19__["default"])(task.outPCMBuffer);
                        }
                        task.outPCMBuffer = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_20__["default"]);
                        task.outPCMBuffer.data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avMalloc)(4 * task.playChannels);
                        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avMallocz)(nbSamples * 4 * task.playChannels);
                        for (let i = 0; i < task.playChannels; i++) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[20](task.outPCMBuffer.data + (i * 4), data + nbSamples * 4 * i);
                        }
                        task.outPCMBuffer.maxnbSamples = nbSamples;
                    }
                    const ret = await receiveToPCMBuffer(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_18__.symbolStructAddress]);
                    if (ret < 0) {
                        rightIPCPort.reply(request, ret);
                        return;
                    }
                    const pcm = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_15__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](task.outPCMBuffer.data), task.outPCMBuffer.nbSamples * 4 * task.playChannels).slice();
                    rightIPCPort.reply(request, pcm.buffer, null, [pcm.buffer]);
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    checkUseStretchpitcher(task) {
        const use = task.playRate !== 1
            || task.playTempo !== 1
            || task.playPitch !== 1
            || task.enableJitterBuffer;
        if (task.useStretchpitcher && !use) {
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).flush();
            }
        }
    }
    setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 212) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.playRate = rate;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setRate(rate);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async setPlayTempo(taskId, tempo) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playTempo = tempo;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setTempo(tempo);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    setPlayPitch(taskId, pitch) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playPitch = pitch;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setPitch(pitch);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.fakePlay) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__3, 600);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            else {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            task.seeking = true;
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).clear();
                }
            }
            if (task.waitPCMBuffer) {
                if (task.waitAVFrame) {
                    // data 是 avframe 的引用，这里需要置空，防止 waitPCMBuffer 释放的时候将 avframe 的内存释放了
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_12__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                    task.avframePool.release(task.waitAVFrame);
                    task.waitAVFrame = 0;
                }
                this.avPCMBufferPool.release(task.waitPCMBuffer);
                task.waitPCMBuffer = 0;
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__3, 630);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            let videoEnded = false;
            while (true) {
                let now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                let videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 112);
                while (!videoEnded && maxQueueLength && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 112) > maxQueueLength) {
                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_21__["default"](0);
                    // 检查 videoPacketQueueLength 200ms 内没有变化说明 video 已经 sync 完成
                    // 否则某些条件下会卡主
                    if ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])() - now > 200 && videoPacketQueueLength === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 112)) {
                        videoEnded = true;
                    }
                    if (videoPacketQueueLength !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 112)) {
                        videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.stats + 112);
                        now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                    }
                }
                let audioFrame = await task.leftIPCPort.request('pull');
                if (audioFrame < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`pull audio frame end after seek, taskId: ${taskId}`, cheap__fileName__3, 660);
                    task.frameEnded = true;
                    break;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`use the first audio frame because of the seek time${timestamp} < 0`, cheap__fileName__3, 666);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    task.paddingAVFrame = audioFrame;
                    task.frameEnded = false;
                    task.lastNotifyPTS = pts;
                    break;
                }
                else {
                    task.avframePool.release(audioFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__3, 690);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.seeking = false;
            if (task.receivePCMSync) {
                task.receivePCMSync();
                task.receivePCMSync = null;
            }
            if (!task.pausing) {
                if (task.fakePlay) {
                    task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                    task.fakePlaySamples = BigInt(0);
                    this.fakePlayNext(task);
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__3, 712);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.lastNotifyPTS = BigInt(0);
            task.frameEnded = false;
            task.firstPlayed = false;
            task.stretchpitcherEnded = false;
            if (task.stretchpitcher?.size) {
                for (let i = 0; i < task.playChannels; i++) {
                    task.stretchpitcher.get(i)?.clear();
                }
            }
            if (task.fakePlayTimer) {
                clearTimeout(task.fakePlayTimer);
            }
            task.fakePlaySamples = BigInt(0);
            task.fakePlayStartTimestamp = 0;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`restart task, taskId: ${task.taskId}`, cheap__fileName__3, 735);
        }
    }
    async fakePlayNext(task) {
        const audioFrame = await task.leftIPCPort.request('pull');
        if (audioFrame < 0) {
            task.frameEnded = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`audio fake render ended, taskId: ${task.taskId}`, cheap__fileName__3, 746);
            task.controlIPCPort.notify('ended');
            return;
        }
        if (!task.fakePlay || task.pausing) {
            task.avframePool.release(audioFrame);
            return;
        }
        let next = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168) * 1000) >>> 0;
        next /= (task.playRate * task.playTempo);
        const targetSamples = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])() - task.fakePlayStartTimestamp)) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168) >>> 0) / BigInt(1000);
        const diff = Number(targetSamples - task.fakePlaySamples);
        next -= (diff / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 168) * 1000) >>> 0;
        task.fakePlaySamples += BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](audioFrame + 76) >>> 0);
        task.avframePool.release(audioFrame);
        task.fakePlayTimer = setTimeout(() => {
            task.fakePlayTimer = null;
            this.fakePlayNext(task);
        }, next);
    }
    async fakePlay(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
            task.fakePlay = true;
            task.fakePlaySamples = BigInt(0);
            this.fakePlayNext(task);
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`start fake play, taskId: ${task.taskId}`, cheap__fileName__3, 784);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = true;
            if (task.fakePlay) {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`task paused, taskId: ${task.taskId}`, cheap__fileName__3, 799);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = false;
            if (task.fakePlay) {
                task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                task.fakePlaySamples = BigInt(0);
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
                this.fakePlayNext(task);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`task unpaused, taskId: ${task.taskId}`, cheap__fileName__3, 814);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_22__.INVALID_OPERATE;
        }
        return await this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.resampler) {
                task.resampler.close();
            }
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).close();
                }
                task.stretchpitcher.clear();
            }
            if (task.outPCMBuffer) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(task.outPCMBuffer.data);
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_18__.symbolStructAddress]);
                (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_19__["default"])(task.outPCMBuffer);
            }
            if (task.waitPCMBuffer) {
                this.avPCMBufferPool.release(task.waitPCMBuffer);
            }
            if (task.waitAVFrame) {
                task.avframePool.release(task.waitAVFrame);
            }
            if (task.paddingAVFrame) {
                task.avframePool.release(task.paddingAVFrame);
            }
            task.leftIPCPort.destroy();
            task.rightIPCPort.destroy();
            this.tasks.delete(taskId);
        }
    }
    async clear() {
        await super.clear();
        this.avPCMBufferList.clear((buffer) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](buffer)) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](buffer));
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_17__.avFreep)(buffer);
            }
        }, 20);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_19__["default"])(this.avPCMBufferList);
    }
}


/***/ }),

/***/ "./src/avpipeline/DemuxPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/DemuxPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DemuxPipeline)
/* harmony export */ });
/* unused harmony export STREAM_INDEX_ALL */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var avformat_demux__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avformat/demux */ "./src/avformat/demux.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
var cheap__fileName__2 = "src/avpipeline/DemuxPipeline.ts";





















const STREAM_INDEX_ALL = -1;
class DemuxPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    async judgeFormat(ioReader, defaultFormat = -1 /* AVFormat.UNKNOWN */) {
        let signature = await ioReader.peekString(8);
        if (/^FLV/.test(signature)) {
            return 0 /* AVFormat.FLV */;
        }
        else if (/^DKIF/.test(signature)) {
            return 4 /* AVFormat.IVF */;
        }
        else if (/^ftyp/.test(signature.slice(4, 8))) {
            return 1 /* AVFormat.MP4 */;
        }
        else if (/^OggS/.test(signature)) {
            return 3 /* AVFormat.OGGS */;
        }
        else if (/^ID3/.test(signature)) {
            return 7 /* AVFormat.MP3 */;
        }
        else if ((await ioReader.peekUint32()) === 0x1A45DFA3) {
            return 5 /* AVFormat.MATROSKA */;
        }
        return defaultFormat;
    }
    createTask(options) {
        let leftIPCPort;
        if (options.mainTaskId) {
            const mainTask = this.tasks.get(options.mainTaskId);
            leftIPCPort = mainTask.leftIPCPort;
        }
        else {
            leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.leftPort);
        }
        const bufferLength = options.bufferLength || 1048576;
        const buf = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMalloc)(bufferLength);
        if (!buf) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.NO_MEMORY;
        }
        const buffer = new cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__["default"](buf, bufferLength);
        const ioReader = new common_io_IOReader__WEBPACK_IMPORTED_MODULE_5__["default"](bufferLength, true, buffer);
        if (!options.isLive) {
            ioReader.flags |= 1 /* IOFlags.SEEKABLE */;
        }
        ioReader.onFlush = async (buffer) => {
            const params = {
                pointer: buffer.byteOffset,
                length: buffer.length
            };
            if (options.ioloaderOptions) {
                params.ioloaderOptions = options.ioloaderOptions;
            }
            try {
                const len = await leftIPCPort.request('read', params);
                return len;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSeek = async (pos) => {
            try {
                const params = {
                    pos
                };
                if (options.ioloaderOptions) {
                    params.ioloaderOptions = options.ioloaderOptions;
                }
                await leftIPCPort.request('seek', params);
                return 0;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSize = async () => {
            try {
                return await leftIPCPort.request('size');
            }
            catch (error) {
                return BigInt(-1048574 /* IOError.INVALID_OPERATION */);
            }
        };
        const formatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_6__.createAVIFormatContext)();
        formatContext.ioReader = ioReader;
        this.tasks.set(options.taskId, {
            ...options,
            leftIPCPort,
            rightIPCPorts: new Map(),
            formatContext,
            ioReader,
            buffer: buf,
            cacheAVPackets: new Map(),
            cacheRequests: new Map(),
            realFormat: -1 /* AVFormat.UNKNOWN */,
            demuxEnded: false,
            loop: null,
            gopCounter: 0,
            lastKeyFramePts: BigInt(0),
            lastAudioDts: BigInt(0),
            lastVideoDts: BigInt(0),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_7__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avpacketListMutex)
        });
        return 0;
    }
    async openStream(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await task.leftIPCPort.request('open');
            let format;
            try {
                format = await this.judgeFormat(task.ioReader, task.format);
                task.format = format;
            }
            catch (error) {
                return avutil_error__WEBPACK_IMPORTED_MODULE_3__.DATA_INVALID;
            }
            let iformat;
            switch (format) {
                case 0 /* AVFormat.FLV */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_codecs_aac_ts-src_avformat_formats_IFormat_ts-src_avformat_function_seekInBytes_ts"), __webpack_require__.e("src_avformat_formats_IFlvFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlvFormat */ "./src/avformat/formats/IFlvFormat.ts"))).default);
                    }
                    break;
                case 1 /* AVFormat.MP4 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMovFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMovFormat */ "./src/avformat/formats/IMovFormat.ts"))).default);
                    }
                    break;
                case 2 /* AVFormat.MPEGTS */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_codecs_aac_ts-src_avformat_formats_IFormat_ts-src_avformat_function_seekInBytes_ts"), __webpack_require__.e("src_avformat_formats_IMpegtsFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMpegtsFormat */ "./src/avformat/formats/IMpegtsFormat.ts"))).default);
                    }
                    break;
                case 4 /* AVFormat.IVF */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IIvfFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IIvfFormat */ "./src/avformat/formats/IIvfFormat.ts"))).default);
                    }
                    break;
                case 3 /* AVFormat.OGGS */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IOggsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IOggsFormat */ "./src/avformat/formats/IOggsFormat.ts"))).default);
                    }
                    break;
                case 7 /* AVFormat.MP3 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMp3Format_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMp3Format */ "./src/avformat/formats/IMp3Format.ts"))).default);
                    }
                    break;
                case 5 /* AVFormat.MATROSKA */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMatroskaFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMatroskaFormat */ "./src/avformat/formats/IMatroskaFormat.ts"))).default));
                    }
                    break;
                default:
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error('format not support', cheap__fileName__2, 327);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_3__.FORMAT_NOT_SUPPORT;
            }
            task.realFormat = format;
            task.formatContext.iformat = iformat;
            return await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.open(task.formatContext, {
                maxAnalyzeDuration: 2,
                fastOpen: task.isLive
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 342);
        }
    }
    async getFormat(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.realFormat;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 352);
        }
    }
    async analyzeStreams(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.analyzeStreams(task.formatContext);
            const streams = [];
            for (let i = 0; i < task.formatContext.streams.length; i++) {
                const stream = task.formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_12__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: stream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_12__.symbolStructAddress]
                });
            }
            return streams;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 380);
        }
    }
    async connectStreamTask(taskId, streamIndex, port) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
            task.cacheAVPackets.set(streamIndex, []);
            ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'pull': {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (cacheAVPackets.length) {
                            const avpacket = cacheAVPackets.shift();
                            if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) - 1);
                            }
                            else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 112) - 1);
                            }
                            ipcPort.reply(request, avpacket);
                        }
                        else {
                            if (task.demuxEnded) {
                                ipcPort.reply(request, -1048576 /* IOError.END */);
                            }
                            else {
                                task.cacheRequests.set(streamIndex, request);
                                if (task.loop && task.loop.isStarted()) {
                                    task.loop.resetInterval();
                                }
                            }
                        }
                        break;
                    }
                }
            });
            task.rightIPCPorts.set(streamIndex, ipcPort);
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`connect stream ${streamIndex}, taskId: ${task.taskId}`, cheap__fileName__2, 422);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 425);
        }
    }
    async startDemux(taskId, isLive, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.format === 2 /* AVFormat.MPEGTS */) {
                // mpegts 最小 20
                maxQueueLength = Math.max(maxQueueLength, 20);
            }
            if (task.loop) {
                task.loop.destroy();
            }
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_15__["default"](async () => {
                if (!isLive) {
                    let full = false;
                    let hasZero = false;
                    task.cacheAVPackets.forEach((list) => {
                        if (list.length > maxQueueLength) {
                            full = true;
                        }
                        if (list.length === 0) {
                            hasZero = true;
                        }
                    });
                    if (full && !hasZero) {
                        task.loop.emptyTask();
                        return;
                    }
                }
                const avpacket = task.avpacketPool.alloc();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                if (!ret) {
                    const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32);
                    if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && task.cacheAVPackets.has(streamIndex)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 24) + BigInt(1));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 16) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 24) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) > task.lastAudioDts) {
                            const list = task.cacheAVPackets.get(streamIndex);
                            if (list && list.length) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 212, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                            }
                            else {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 212, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - task.lastAudioDts & 0xffffffffn) >> 0)));
                            }
                        }
                        task.lastAudioDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16);
                    }
                    else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                        && task.cacheAVPackets.has(streamIndex)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 104) + BigInt(1));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 96, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 96) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 160) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8) > task.lastKeyFramePts) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 88, task.gopCounter);
                                task.gopCounter = 1;
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 84, (Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8) - task.lastKeyFramePts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q) & 0xffffffffn) >> 0));
                            }
                            task.lastKeyFramePts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8);
                        }
                        else {
                            task.gopCounter++;
                        }
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 104) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) > task.lastVideoDts) {
                            const list = task.cacheAVPackets.get(streamIndex);
                            if (list && list.length) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 200, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                            }
                            else {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 200, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - task.lastVideoDts & 0xffffffffn) >> 0)));
                            }
                        }
                        task.lastVideoDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16);
                    }
                    if (task.cacheRequests.has(streamIndex)) {
                        task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), avpacket);
                        task.cacheRequests.delete(streamIndex);
                    }
                    else {
                        if (task.cacheAVPackets.has(streamIndex)) {
                            task.cacheAVPackets.get(streamIndex).push(avpacket);
                            if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) + 1);
                            }
                            else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 112) + 1);
                            }
                        }
                        else {
                            if (task.rightIPCPorts.has(STREAM_INDEX_ALL)) {
                                if (task.cacheRequests.has(STREAM_INDEX_ALL)) {
                                    task.rightIPCPorts.get(STREAM_INDEX_ALL).reply(task.cacheRequests.get(STREAM_INDEX_ALL), avpacket);
                                    task.cacheRequests.delete(STREAM_INDEX_ALL);
                                }
                                else {
                                    task.cacheAVPackets.get(STREAM_INDEX_ALL).push(avpacket);
                                }
                            }
                            else {
                                task.avpacketPool.release(avpacket);
                            }
                        }
                    }
                }
                else {
                    task.avpacketPool.release(avpacket);
                    if (ret !== -1048576 /* IOError.END */) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`demux error, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__2, 561);
                    }
                    task.demuxEnded = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`demuxer ended, taskId: ${task.taskId}`, cheap__fileName__2, 566);
                    for (let streamIndex of task.cacheRequests.keys()) {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (!cacheAVPackets.length) {
                            task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), -1048576 /* IOError.END */);
                            task.cacheRequests.delete(streamIndex);
                        }
                    }
                    task.loop.stop();
                }
            }, 0, 0, true, false);
            task.loop.start();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`start demux loop, taskId: ${task.taskId}`, cheap__fileName__2, 581);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 584);
        }
    }
    async seek(taskId, timestamp, flags) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret >= BigInt(0)) {
                    task.cacheAVPackets.forEach((list) => {
                        common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(list, (avpacket) => {
                            task.avpacketPool.release(avpacket);
                        });
                        list.length = 0;
                    });
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 112, 0);
                    const avpacket = task.avpacketPool.alloc();
                    while (true) {
                        ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                        if (ret < 0 || task.cacheAVPackets.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32))) {
                            break;
                        }
                    }
                    if (ret >= 0) {
                        task.demuxEnded = false;
                        const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32);
                        task.cacheAVPackets.get(streamIndex).push(avpacket);
                        if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) + 1);
                        }
                        else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 112) + 1);
                        }
                        task.loop.start();
                        let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8);
                        if (task.formatContext.streams[streamIndex].startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE_BIGINT) {
                            duration -= task.formatContext.streams[streamIndex].startTime;
                        }
                        else {
                            duration -= task.formatContext.streams[streamIndex].firstDTS;
                        }
                        return (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`got first packet failed after seek, taskId: ${task.taskId}`, cheap__fileName__2, 637);
                        task.avpacketPool.release(avpacket);
                        task.demuxEnded = true;
                        return timestamp;
                    }
                }
                return ret;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info('seek before demux loop start', cheap__fileName__2, 648);
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret < 0) {
                    return ret;
                }
                return timestamp;
            }
        }
    }
    /**
     * 裁剪 avpacket 队列大小
     *
     * @param taskId
     * @param max （毫秒）
     */
    async croppingAVPacketQueue(taskId, max) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.cacheAVPackets.forEach((list, streamIndex) => {
                const lastDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[list.length - 1] + 16);
                let i = list.length - 2;
                for (i = list.length - 2; i >= 0; i--) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](list[i] + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q) >= max) {
                            break;
                        }
                    }
                }
                if (i > 0) {
                    list.splice(0, i).forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, list.length);
                    }
                    else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 112, list.length);
                    }
                }
            });
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
            }
            task.leftIPCPort.destroy();
            task.rightIPCPorts.forEach((ipcPort) => {
                ipcPort.destroy();
            });
            task.rightIPCPorts.clear();
            task.formatContext.destroy();
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(task.buffer);
            task.cacheAVPackets.forEach((list) => {
                list.forEach((avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/IOPipeline.ts":
/*!**************************************!*\
  !*** ./src/avpipeline/IOPipeline.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOPipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avnetwork/ioLoader/FetchIOLoader */ "./src/avnetwork/ioLoader/FetchIOLoader.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avnetwork/ioLoader/FileIOLoader */ "./src/avnetwork/ioLoader/FileIOLoader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avpipeline/IOPipeline.ts";










class IOPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        let ioLoader;
        switch (options.type) {
            case 0 /* IOType.Fetch */:
                ioLoader = new avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_1__["default"](options.options);
                break;
            case 1 /* IOType.File */:
                ioLoader = new avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_2__["default"](options.options);
                break;
            case 2 /* IOType.HLS */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_HlsIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/HlsIOLoader */ "./src/avnetwork/ioLoader/HlsIOLoader.ts"))).default(options.options);
                }
                break;
            case 3 /* IOType.DASH */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_DashIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/DashIOLoader */ "./src/avnetwork/ioLoader/DashIOLoader.ts"))).default(options.options);
                }
                break;
        }
        if (!ioLoader) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](options.rightPort);
        const task = {
            ...options,
            ioLoader,
            ipcPort
        };
        ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__.REQUEST, async (request) => {
            switch (request.method) {
                case 'open': {
                    try {
                        await ioLoader.open(options.info, options.range);
                        ipcPort.reply(request, {});
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader open error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 118);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'read': {
                    const pointer = request.params.pointer;
                    const length = request.params.length;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapSafeUint8Array)(pointer, length);
                    try {
                        const len = await ioLoader.read(buffer, ioloaderOptions);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[17](task.stats + 176, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[17](task.stats + 176) + BigInt(len >>> 0));
                        ipcPort.reply(request, len);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader read error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 139);
                        ipcPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_3__.DATA_INVALID);
                    }
                    break;
                }
                case 'seek': {
                    const pos = request.params.pos;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    try {
                        await ioLoader.seek(pos, ioloaderOptions);
                        ipcPort.reply(request);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader seek error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 157);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'size': {
                    ipcPort.reply(request, await ioLoader.size());
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    async open(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.open(task.info, task.range);
            return 0;
        }
    }
    async getDuration(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 2 /* IOType.HLS */ || task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getDuration();
                }
            }
            return 0;
        }
    }
    async hasAudio(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasAudio();
                }
            }
            return false;
        }
    }
    async hasVideo(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasVideo();
                }
            }
            return false;
        }
    }
    async hasSubtitle(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasSubtitle();
                }
            }
            return false;
        }
    }
    async getVideoList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getVideoList();
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getVideoList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getAudioList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getAudioList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getSubtitleList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getSubtitleList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async selectVideo(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectVideo(index);
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.selectVideo(index);
                }
            }
        }
    }
    async selectAudio(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectAudio(index);
                }
            }
        }
    }
    async selectSubtitle(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectSubtitle(index);
                }
            }
        }
    }
    async getMinBuffer(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            {
                if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            return 0;
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.stop();
            task.ipcPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/Pipeline.ts":
/*!************************************!*\
  !*** ./src/avpipeline/Pipeline.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pipeline)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/*
 * libmedia abstract Pipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Pipeline {
    tasks;
    constructor() {
        this.tasks = new Map();
    }
    async clear() {
        if (this.tasks.size) {
            for (const key of this.tasks.keys()) {
                await this.unregisterTask(key);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.setLevel(level);
    }
    async getTaskCount() {
        return this.tasks.size;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/webcodec/VideoDecoder */ "./src/avcodec/webcodec/VideoDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
var cheap__fileName__0 = "src/avpipeline/VideoDecodePipeline.ts";





/*
 * libmedia VideoDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

















class VideoDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task, enableHardwareAcceleration = true) {
        return new avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_1__["default"]({
            onError: (error) => {
                if (task.hardwareRetryCount > 3 || !task.firstDecoded) {
                    task.targetDecoder = task.softwareDecoder;
                    task.hardwareDecoder.close();
                    task.hardwareDecoder = null;
                    task.decoderReady = this.openSoftwareDecoder(task);
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video decode error width hardware(${task.hardwareRetryCount}), taskId: ${task.taskId}, error: ${error}, try to fallback to software decoder`, cheap__fileName__0, 116);
                }
                else {
                    task.hardwareRetryCount++;
                    try {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`retry open hardware decoder(${task.hardwareRetryCount}), taskId: ${task.taskId}`, cheap__fileName__0, 121);
                        task.decoderReady = task.hardwareDecoder.open(task.parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`retry open hardware decoder failed, fallback to software decoder, taskId: ${task.taskId}`, cheap__fileName__0, 125);
                    }
                }
                task.needKeyFrame = true;
                task.leftIPCPort.request('requestKeyframe');
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 136) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 224, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 224)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
            },
            enableHardwareAcceleration
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_7__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            softwareDecoder: null,
            hardwareDecoder: null,
            frameCaches,
            inputEnd: false,
            targetDecoder: null,
            needKeyFrame: true,
            parameters: 0,
            hardwareRetryCount: 0,
            lastDecodeTimestamp: 0,
            firstDecoded: false,
            decoderReady: null,
            softwareDecoderOpened: false,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avpacketListMutex)
        };
        task.softwareDecoder = options.resource
            ? new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_11__["default"]({
                resource: options.resource,
                onError: (error) => {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__0, 183);
                    const task = this.tasks.get(options.taskId);
                    if (task.openReject) {
                        task.openReject(error);
                        task.openReject = null;
                    }
                },
                onReceiveFrame(frame) {
                    task.firstDecoded = true;
                    frameCaches.push(frame);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 136) + BigInt(1));
                    if (task.lastDecodeTimestamp) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 224, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 224)));
                    }
                    task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
                },
                avframePool: avframePool
            })
            : (common_util_support__WEBPACK_IMPORTED_MODULE_12__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
        if (!task.softwareDecoder) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error('software decoder not support', cheap__fileName__0, 207);
            return avutil_error__WEBPACK_IMPORTED_MODULE_13__.INVALID_OPERATE;
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_12__["default"].videoDecoder && options.enableHardware) {
            task.hardwareDecoder = this.createWebcodecDecoder(task);
        }
        task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame, null, common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame) ? null : [frame]);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame, null, common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame) ? null : [frame]);
                                break;
                            }
                            if (task.decoderReady) {
                                await task.decoderReady;
                                task.decoderReady = null;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    // 硬解的 flush 有时会卡主，这里设置 2 秒超时，若超时只能丢弃还未 flush 出来的帧了
                                    let ret = await Promise.race([
                                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](2),
                                        task.targetDecoder.flush()
                                    ]);
                                    if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(ret)) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video hardware decoder flush failed, ignore it, taskId: ${task.taskId}`, cheap__fileName__0, 250);
                                    }
                                }
                                else {
                                    await task.targetDecoder.flush();
                                }
                                task.inputEnd = true;
                                // 等待 flush 出的帧入队
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](0);
                                }
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame, null, task.targetDecoder === task.hardwareDecoder ? [frame] : null);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 267);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                if (task.needKeyFrame) {
                                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                        task.needKeyFrame = false;
                                    }
                                    else {
                                        task.avpacketPool.release(avpacket);
                                        continue;
                                    }
                                }
                                let ret = task.targetDecoder.decode(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 128) + 1);
                                    if (task.targetDecoder === task.hardwareDecoder && task.softwareDecoder) {
                                        task.targetDecoder = task.softwareDecoder;
                                        task.hardwareDecoder.close();
                                        task.hardwareDecoder = null;
                                        await this.openSoftwareDecoder(task);
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video decode error width hardware, taskId: ${task.taskId}, error: ${ret}, try to fallback to software decoder`, cheap__fileName__0, 296);
                                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                            ret = task.targetDecoder.decode(avpacket);
                                            if (ret >= 0) {
                                                task.avpacketPool.release(avpacket);
                                                continue;
                                            }
                                        }
                                        else {
                                            task.avpacketPool.release(avpacket);
                                            task.needKeyFrame = true;
                                            task.leftIPCPort.request('requestKeyframe');
                                            continue;
                                        }
                                    }
                                    task.avpacketPool.release(avpacket);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 312);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                task.avpacketPool.release(avpacket);
                                // 硬解队列中的 EncodedVideoChunk 过多会报错， 这里判断做一下延时
                                while (task.targetDecoder === task.hardwareDecoder
                                    && task.hardwareDecoder.getQueueLength() > 20) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](0);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 326);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 333);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async openSoftwareDecoder(task) {
        if (task.softwareDecoder && !task.softwareDecoderOpened) {
            const parameters = task.parameters;
            let threadCount = 1;
            if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__["default"])()) {
                let pixels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 48) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 52);
                let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(parameters + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational));
                if (pixels >= 2073600 && pixels <= 2211840) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 2;
                    }
                    if (framerate > 30) {
                        threadCount = 2;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 4;
                        }
                    }
                    else if (framerate > 60) {
                        threadCount = 4;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 6;
                        }
                    }
                }
                else if (pixels > 2211840 && pixels <= 8294400) {
                    threadCount = 4;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 6;
                    }
                }
                else if (pixels > 8294400) {
                    threadCount = 6;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 226 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 8;
                    }
                }
                threadCount = Math.min(threadCount, navigator.hardwareConcurrency);
            }
            await task.softwareDecoder.open(parameters, threadCount);
            task.softwareDecoderOpened = true;
        }
    }
    async open(taskId, parameters) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`cannot open hardware decoder, ${error}`, cheap__fileName__0, 407);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                task.parameters = parameters;
                if (task.targetDecoder === task.softwareDecoder) {
                    await this.openSoftwareDecoder(task);
                }
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 423);
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task && task.softwareDecoder) {
            let discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(task.parameters + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational));
            if (framerate >= 120) {
                if (rate <= 1) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 1.5) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 3) {
                    // 跳过所有帧间编码帧
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else {
                    // 跳过所有帧间编码帧
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else if (framerate >= 60) {
                if (rate < 1.5) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 3) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 8) {
                    discard = 24 /* AVDiscard.AVDISCARD_NONINTRA */;
                }
                else {
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else {
                discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            }
            task.softwareDecoder.setSkipFrameDiscard(discard);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 467);
        }
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.targetDecoder === task.softwareDecoder) {
                await task.targetDecoder.flush();
            }
            // webcodec flush 有可能会卡主，这里重新创建解码器
            else if (task.targetDecoder === task.hardwareDecoder) {
                task.hardwareDecoder.close();
                task.hardwareDecoder = this.createWebcodecDecoder(task);
                await task.hardwareDecoder.open(task.parameters);
                task.targetDecoder = task.hardwareDecoder;
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(task.frameCaches, (frame) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            task.frameCaches.length = 0;
            task.needKeyFrame = true;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`reset video decoder, taskId: ${task.taskId}`, cheap__fileName__0, 497);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_13__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            if (task.softwareDecoder) {
                task.softwareDecoder.close();
            }
            if (task.hardwareDecoder) {
                task.hardwareDecoder.close();
            }
            task.frameCaches.forEach((frame) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            this.tasks.delete(taskId);
        }
    }
    async getTasksInfo() {
        const info = [];
        this.tasks.forEach((task) => {
            info.push({
                codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 4),
                width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 48),
                height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 52),
                framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(task.parameters + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational)),
                hardware: task.targetDecoder === task.hardwareDecoder
            });
        });
        return info;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoRenderPipeline)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avrender/image/Canvas2dRender */ "./src/avrender/image/Canvas2dRender.ts");
/* harmony import */ var avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avrender/image/WebGPUExternalRender */ "./src/avrender/image/WebGPUExternalRender.ts");
/* harmony import */ var avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avrender/image/WebGLYUV8Render */ "./src/avrender/image/WebGLYUV8Render.ts");
/* harmony import */ var avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avrender/image/WebGLYUV16Render */ "./src/avrender/image/WebGLYUV16Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avrender/image/WebGPUYUV8Render */ "./src/avrender/image/WebGPUYUV8Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avrender/image/WebGPUYUV16Render */ "./src/avrender/image/WebGPUYUV16Render.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
var cheap__fileName__2 = "src/avpipeline/VideoRenderPipeline.ts";




/*
 * libmedia VideoRenderPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






















const WebGPURenderList =  true ? [
    avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_0__["default"]
] : 0;
{
    WebGPURenderList.push(avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_1__["default"]);
}
const WebGLRenderList = [
    avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_2__["default"]
];
{
    WebGLRenderList.push(avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_3__["default"]);
}
var AdjustStatus;
(function (AdjustStatus) {
    AdjustStatus[AdjustStatus["None"] = 0] = "None";
    AdjustStatus[AdjustStatus["Accelerate"] = 1] = "Accelerate";
    AdjustStatus[AdjustStatus["Decelerate"] = 2] = "Decelerate";
})(AdjustStatus || (AdjustStatus = {}));
const HHRPrimaries = ['bt2020', 'bt2100', 'st2048', 'p3-dcl', 'hlg'];
function isHDR(primaries) {
    return common_util_array__WEBPACK_IMPORTED_MODULE_4__.has(HHRPrimaries, primaries);
}
class VideoRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.leftPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            controlIPCPort,
            render: null,
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT,
            firstPTS: BigInt(0),
            startTimestamp: BigInt(0),
            playRate: BigInt(100),
            targetRate: BigInt(100),
            frontFrame: null,
            backFrame: null,
            renderFrame: null,
            renderFrameCount: BigInt(0),
            loop: null,
            renderRedyed: false,
            adjust: AdjustStatus.None,
            adjustDiff: BigInt(0),
            lastAdjustTimestamp: BigInt(0),
            firstRendered: false,
            canvasUpdated: false,
            renderCreating: false,
            pauseTimestamp: 0,
            lastNotifyPTS: BigInt(0),
            skipRender: false,
            isSupport: () => false,
            frontBuffered: false,
            ended: false,
            seeking: false,
            seekSync: null,
            pausing: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_8__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_9__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_10__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
        controlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__.NOTIFY, async (request) => {
            switch (request.method) {
                case 'syncPts': {
                    const targetPTS = request.params.pts;
                    const diff = Math.abs(Number(targetPTS - task.currentPTS));
                    if (diff > 100 && task.currentPTS > BigInt(0)) {
                        if (targetPTS > task.currentPTS) {
                            task.adjust = AdjustStatus.Accelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`video render sync pts accelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff}, taskId: ${task.taskId}`, cheap__fileName__2, 224);
                        }
                        else {
                            task.adjust = AdjustStatus.Decelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`video render sync pts decelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff} taskId: ${task.taskId}`, cheap__fileName__2, 228);
                        }
                        task.adjustDiff = BigInt(Math.floor(diff));
                    }
                    break;
                }
                case 'skipRender': {
                    task.skipRender = request.params.skipRender;
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    async createRender(task, frame) {
        if (task.renderCreating) {
            return;
        }
        task.renderCreating = true;
        task.renderRedyed = false;
        if (task.render) {
            task.render.destroy();
        }
        if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(frame)) {
            if ( true && task.enableWebGPU
                && common_util_support__WEBPACK_IMPORTED_MODULE_14__["default"].webgpu
                && (
                // chrome116+ webgpu 可以导入 VideoFrame 作为纹理
                common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '116', true))
                && !isHDR(frame.colorSpace.primaries)) {
                // WebGPUExternalRender 性能最优
                task.render = new avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_16__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode,
                    onRenderContextLost: () => {
                        task.canvasUpdated = false;
                        task.renderRedyed = false;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn('render context lost', cheap__fileName__2, 273);
                        task.controlIPCPort.notify('updateCanvas');
                    }
                });
                task.isSupport = avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_16__["default"].isSupport;
            }
            else {
                // CanvasImageRender 支持 hdr 视频渲染
                task.render = new avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_17__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode
                });
                task.isSupport = avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_17__["default"].isSupport;
            }
        }
        else {
            // 优先使用 webgpu，webgpu 性能优于 webgl
            if ( true && task.enableWebGPU && common_util_support__WEBPACK_IMPORTED_MODULE_14__["default"].webgpu) {
                common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(WebGPURenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn('render context lost', cheap__fileName__2, 299);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
            else {
                common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(WebGLRenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn('render context lost', cheap__fileName__2, 317);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
        }
        if (!task.render) {
            task.renderCreating = false;
            return;
        }
        await task.render.init();
        task.render.viewport(task.viewportWidth, task.viewportHeight);
        task.render.clear();
        task.render.setRotate(task.renderRotate ?? 0);
        task.render.enableHorizontalFlip(task.flipHorizontal ?? false);
        task.render.enableVerticalFlip(task.flipVertical ?? false);
        task.renderRedyed = true;
        task.renderCreating = false;
    }
    async play(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has already call play', cheap__fileName__2, 346);
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame) && task.backFrame < 0) {
                task.backFrame = 0;
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 353);
                task.controlIPCPort.notify('ended');
                return;
            }
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.frontFrame) && task.frontFrame < 0) {
                task.ended = true;
                task.frontBuffered = false;
                task.frontFrame = 0;
            }
            const me = this;
            function swap() {
                if (task.seeking) {
                    return;
                }
                if (task.backFrame) {
                    if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) {
                        task.backFrame.close();
                    }
                    else {
                        task.avframePool.release(task.backFrame);
                    }
                }
                task.backFrame = null;
                if (task.frontBuffered) {
                    task.backFrame = task.frontFrame;
                    task.frontFrame = null;
                }
                else {
                    return false;
                }
                if (task.ended) {
                    return;
                }
                task.frontBuffered = false;
                const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
                task.leftIPCPort.request('pull').then((frame) => {
                    if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(frame) && frame < 0) {
                        task.ended = true;
                        task.frontFrame = null;
                        return;
                    }
                    const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])() - now;
                    // 超过 1 秒认为是网卡了（断点暂停），对齐一下时间
                    if (cost > 1000) {
                        task.startTimestamp += BigInt(Math.floor(cost));
                    }
                    task.frontFrame = frame;
                    task.frontBuffered = true;
                    if (task.seekSync) {
                        task.seekSync();
                        task.seekSync = null;
                        return;
                    }
                    if (!task.backFrame) {
                        swap();
                    }
                });
                return true;
            }
            await this.createRender(task, task.backFrame);
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)((!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`got first video frame, pts: ${!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104)}(${task.firstPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 439);
            // 当第一个帧的 pts 大于 1000ms 时判定不是从 0 开始，这里做一下对其
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.currentPTS = task.firstPTS;
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            const inWorker = (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_20__["default"])();
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_21__["default"](() => {
                if (!task.backFrame) {
                    if (!task.ended) {
                        task.loop.emptyTask();
                    }
                    else {
                        if (task.render && task.renderRedyed) {
                            task.render.clear();
                        }
                        task.loop.stop();
                        task.adjust = AdjustStatus.None;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 465);
                        task.controlIPCPort.notify('ended');
                    }
                    return;
                }
                if (!task.isSupport(task.backFrame)) {
                    if (task.render) {
                        task.renderRedyed = false;
                        task.renderFrame = task.backFrame;
                        task.controlIPCPort.notify('updateCanvas');
                        return;
                    }
                    else {
                        this.createRender(task, task.backFrame);
                    }
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)((!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
                if (pts < task.currentPTS) {
                    // 差值大于 1000s 认为从头开始了
                    if (task.currentPTS - pts > BigInt(1000000)) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - (pts * BigInt(100) / task.targetRate);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`dropping frame with pts ${pts}, which is earlier then the last rendered frame(${task.currentPTS}), taskId: ${task.taskId}`, cheap__fileName__2, 495);
                        swap();
                        return;
                    }
                }
                if (task.adjust === AdjustStatus.Accelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - task.lastAdjustTimestamp >= BigInt(200)) {
                            const sub = task.adjustDiff <= BigInt(100)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_22__.min(task.adjustDiff, BigInt(100)) * BigInt(100) / task.targetRate;
                            task.startTimestamp -= sub;
                            task.adjustDiff -= sub;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`video render accelerate startTimestamp sub: ${sub}, taskId: ${task.taskId}`, cheap__fileName__2, 516);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])()));
                        }
                    }
                }
                else if (task.adjust === AdjustStatus.Decelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - task.lastAdjustTimestamp >= BigInt(300)) {
                            const add = task.adjustDiff < BigInt(50)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_22__.min(task.adjustDiff, BigInt(50)) * BigInt(100) / task.targetRate;
                            task.startTimestamp += add;
                            task.adjustDiff -= add;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`video render decelerate startTimestamp add: ${add}, taskId: ${task.taskId}`, cheap__fileName__2, 537);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])()));
                        }
                    }
                }
                if (task.enableJitterBuffer) {
                    let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 112) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 200) * 1000;
                    if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.jitterBuffer)) {
                        me.setPlayRate(task.taskId, 1);
                    }
                }
                const diff = pts * BigInt(100) / task.playRate + task.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])()));
                if (diff <= 0) {
                    // 太晚的帧跳过渲染
                    if (task.renderRedyed
                        && !task.skipRender
                        && (inWorker || (-diff < BigInt(100)) || (task.renderFrameCount & BigInt(0x01)))) {
                        task.render.render(task.backFrame);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                        if (task.lastRenderTimestamp) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 228, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 228)));
                        }
                        task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 152) + 1);
                    }
                    task.renderFrameCount++;
                    if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.backFrame + 68));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.backFrame + 72));
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 76, task.backFrame.displayWidth);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_23__.CTypeEnumWrite[15](task.stats + 80, task.backFrame.displayHeight);
                    }
                    if (!task.firstRendered) {
                        task.controlIPCPort.notify(task.canvasUpdated ? 'firstRenderedAfterUpdateCanvas' : 'firstRendered');
                        task.firstRendered = true;
                        task.canvasUpdated = false;
                    }
                    if (task.playRate !== task.targetRate) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.playRate = task.targetRate;
                    }
                    task.currentPTS = pts;
                    if (pts - task.lastNotifyPTS >= BigInt(1000)) {
                        task.lastNotifyPTS = pts;
                        task.controlIPCPort.notify('syncPts', {
                            pts
                        });
                    }
                    swap();
                }
                else {
                    task.loop.emptyTask();
                }
            }, 0, 0);
            task.loop.start();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 608);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has not played', cheap__fileName__2, 616);
            }
            if (task.loop.isStarted()) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has already run', cheap__fileName__2, 620);
            }
            if (task.backFrame) {
                if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastNotifyPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
            task.firstRendered = false;
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)((!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
            task.currentPTS = task.firstPTS;
            // 当第一个帧的 pts 大于 1000ms 时判定不是从 0 开始，这里做一下对其
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            task.loop.start();
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has not played', cheap__fileName__2, 671);
            }
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
            task.loop.stop();
            task.pausing = true;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 678);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.seeking) {
                return;
            }
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has not played', cheap__fileName__2, 689);
            }
            task.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])() - task.pauseTimestamp));
            if (!task.seeking) {
                task.loop.start();
            }
            task.pausing = false;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 699);
        }
    }
    async updateCanvas(taskId, canvas) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.canvas = canvas;
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            task.isSupport = () => false;
            task.canvasUpdated = true;
            task.firstRendered = false;
            task.renderRedyed = false;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 717);
        }
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 112) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.stats + 200) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 733);
        }
    }
    async setRenderMode(taskId, mode) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderMode = mode;
                task.render.setRenderMode(mode);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 746);
        }
    }
    async setRenderRotate(taskId, rotate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderRotate = rotate;
                task.render.setRotate(rotate);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 759);
        }
    }
    async enableHorizontalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipHorizontal = enable;
                task.render.enableHorizontalFlip(enable);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 772);
        }
    }
    async enableVerticalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipVertical = enable;
                task.render.enableVerticalFlip(enable);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 785);
        }
    }
    async resize(taskId, width, height) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.render.viewport(width, height);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 797);
        }
    }
    async setSkipRender(taskId, skip) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.skipRender = skip;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__2, 807);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            // 当前正在 pull frontFrame，等待其结束
            if (!task.ended && !task.frontBuffered) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__2, 816);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            task.seeking = true;
            task.loop.stop();
            if (task.backFrame) {
                if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.frontFrame = null;
            task.backFrame = null;
            task.currentPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__2, 844);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            while (true) {
                task.backFrame = await task.leftIPCPort.request('pull');
                if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame) && task.backFrame < 0) {
                    task.ended = true;
                    task.seeking = false;
                    task.adjust = AdjustStatus.None;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`pull video frame end after seek, taskId: ${taskId}`, cheap__fileName__2, 859);
                    task.controlIPCPort.notify('ended');
                    return;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`use the first video frame because of the seek time${timestamp} < 0`, cheap__fileName__2, 865);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)((!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    break;
                }
                if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__2, 892);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])())) - (timestamp + task.startPTS) * BigInt(100) / task.playRate;
            task.frontFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.frontFrame) && task.frontFrame < 0) {
                task.frontFrame = null;
                task.frontBuffered = false;
                task.ended = true;
            }
            else {
                task.frontBuffered = true;
            }
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
            task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_11__.avRescaleQ)((!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q);
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`got first video frame, pts: ${!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_19__.CTypeEnumRead[17](task.backFrame + 104)}(${task.currentPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 921);
            task.seeking = false;
            if (!task.pausing) {
                task.loop.start();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__2, 930);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_24__.INVALID_OPERATE;
        }
        return await this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
                task.loop = null;
            }
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            if (task.backFrame) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.backFrame) && task.backFrame > 0) {
                    task.avframePool.release(task.backFrame);
                }
                else {
                    task.backFrame.close();
                }
                task.backFrame = null;
            }
            if (task.frontFrame) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(task.frontFrame) && task.frontFrame > 0) {
                    task.avframePool.release(task.frontFrame);
                }
                else {
                    task.frontFrame.close();
                }
                task.frontFrame = null;
            }
            task.leftIPCPort.destroy();
            task.controlIPCPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/struct/jitter.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/struct/jitter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JitterBuffer: () => (/* binding */ JitterBuffer)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia jitter buffer struct defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class JitterBuffer {
    min;
    max;
}
(function (prototype) {
    var map = new Map();
    map.set("min", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("max", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(JitterBuffer.prototype);


/***/ }),

/***/ "./src/avpipeline/struct/stats.ts":
/*!****************************************!*\
  !*** ./src/avpipeline/struct/stats.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stats)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia stats struct defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Stats {
    /**
     * 音频通道数
     */
    channels;
    /**
     * 音频采样率
     */
    sampleRate;
    /**
     * 音频帧大小
     */
    audioFrameSize;
    /**
     * 音频包总字节数
     */
    audioPacketBytes;
    /**
     * 音频包总数
     */
    audioPacketCount;
    /**
     * 当前音频包队列长度
     */
    audioPacketQueueLength;
    /**
     * 音频包丢弃总数
     */
    audioDropPacketCount;
    /**
     * 音频解码错误包总数
     */
    audioDecodeErrorPacketCount;
    /**
     * 音频解码帧总数
     */
    audioFrameDecodeCount;
    /**
     * 音频渲染帧总数
     */
    audioFrameRenderCount;
    /**
     * 音频帧丢弃总数
     */
    audioFrameDropCount;
    /**
     * 视频宽度
     */
    width;
    /**
     * 视频高度
     */
    height;
    /**
     * 视频关键帧间隔
     */
    keyFrameInterval;
    /**
     * 视频 gop 长度
     */
    gop;
    /**
     * 视频包总字节数
     */
    videoPacketBytes;
    /**
     * 视频包总数
     */
    videoPacketCount;
    /**
     * 当前视频包队列总数
     */
    videoPacketQueueLength;
    /**
     * 视频包丢弃总数
     */
    videoDropPacketCount;
    /**
     * 视频包解码错误总数
     */
    videoDecodeErrorPacketCount;
    /**
     * 视频解码帧总数
     */
    videoFrameDecodeCount;
    /**
     * 视频渲染帧总数
     */
    videoFrameRenderCount;
    /**
     * 视频帧丢弃总数（解码未渲染）
     */
    videoFrameDropCount;
    /**
     * 视频关键帧总数
     */
    keyFrameCount;
    /**
     * buffer 丢弃总字节数
     */
    bufferDropBytes;
    /**
     * buffer 接收总字节数
     */
    bufferReceiveBytes;
    /**
     * 音频码率
     */
    audioBitrate;
    /**
     * 视频码率
     */
    videoBitrate;
    /**
     * 视频解码帧率
     */
    videoDecodeFramerate;
    /**
     * 视频渲染帧率
     */
    videoRenderFramerate;
    /**
     * 视频编码帧率（根据 dts 计算）
     */
    videoEncodeFramerate;
    /**
     * 音频解码帧率
     */
    audioDecodeFramerate;
    /**
     * 音频渲染帧率
     */
    audioRenderFramerate;
    /**
     * 音视频编码帧率（根据 dts 计算）
     */
    audioEncodeFramerate;
    /**
     * 音频最大解码帧间隔（毫秒）
     */
    audioFrameDecodeIntervalMax;
    /**
     * 音频最大渲染帧间隔（毫秒）
     */
    audioFrameRenderIntervalMax;
    /**
     * 视频最大解码帧间隔（毫秒）
     */
    videoFrameDecodeIntervalMax;
    /**
     * 视频最大渲染帧间隔（毫秒）
     */
    videoFrameRenderIntervalMax;
    /**
     * 接收带宽
     */
    bandwidth;
    /**
     * 抖动指标
     */
    jitter;
    /**
     * 音频卡顿次数
     */
    audioStutter;
    /**
     * 视频卡顿次数
     */
    videoStutter;
    /**
     * 音频 codec string
     */
    audiocodec;
    /**
     * 视频 codec string
     */
    videocodec;
}
(function (prototype) {
    var map = new Map();
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("audioFrameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("audioPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("audioPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("audioPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("audioDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("audioDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("audioFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("audioFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("audioFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 76, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("keyFrameInterval", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("gop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("videoPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("videoPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("videoPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("videoDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("videoDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("videoFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("videoFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("videoFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("keyFrameCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    map.set("bufferDropBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 168, 8: 0 });
    map.set("bufferReceiveBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 176, 8: 0 });
    map.set("audioBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 184, 8: 0 });
    map.set("videoBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 188, 8: 0 });
    map.set("videoDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("videoRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 196, 8: 0 });
    map.set("videoEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("audioDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 204, 8: 0 });
    map.set("audioRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("audioEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("audioFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("audioFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("videoFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("videoFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 228, 8: 0 });
    map.set("bandwidth", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("jitter", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("audioStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("videoStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 256);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Stats.prototype);


/***/ }),

/***/ "./src/avplayer/AVPlayer.ts":
/*!**********************************!*\
  !*** ./src/avplayer/AVPlayer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPlayer)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _avpipeline_struct_jitter_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../avpipeline/struct/jitter.ts */ "./src/avpipeline/struct/jitter.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! avpipeline/IOPipeline */ "./src/avpipeline/IOPipeline.ts");
/* harmony import */ var avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! avpipeline/DemuxPipeline */ "./src/avpipeline/DemuxPipeline.ts");
/* harmony import */ var avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! avpipeline/VideoDecodePipeline */ "./src/avpipeline/VideoDecodePipeline.ts");
/* harmony import */ var avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! avpipeline/AudioDecodePipeline */ "./src/avpipeline/AudioDecodePipeline.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var common_event_Emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! cheap/webassembly/compiler */ "./src/cheap/webassembly/compiler.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! avpipeline/AudioRenderPipeline */ "./src/avpipeline/AudioRenderPipeline.ts");
/* harmony import */ var avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! avpipeline/VideoRenderPipeline */ "./src/avpipeline/VideoRenderPipeline.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! avrender/pcm/audioWorklet/base/registerProcessor */ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts");
/* harmony import */ var avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! avrender/pcm/AudioSourceWorkletNode */ "./src/avrender/pcm/AudioSourceWorkletNode.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _Controller__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./Controller */ "./src/avplayer/Controller.ts");
/* harmony import */ var _eventType__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./function/supportOffscreenCanvas */ "./src/avplayer/function/supportOffscreenCanvas.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! avrender/pcm/AudioSourceBufferNode */ "./src/avrender/pcm/AudioSourceBufferNode.ts");
/* harmony import */ var common_function_restrain__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! common/function/restrain */ "./src/common/function/restrain.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avpipeline/struct/stats */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./function/createMessageChannel */ "./src/avplayer/function/createMessageChannel.ts");
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var _mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./mse/MSEPipeline */ "./src/avplayer/mse/MSEPipeline.ts");
/* harmony import */ var avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avcodec/function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _StatsController__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./StatsController */ "./src/avplayer/StatsController.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
/* harmony import */ var _JitterBufferController__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./JitterBufferController */ "./src/avplayer/JitterBufferController.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
var cheap__fileName__15 = "src/avplayer/AVPlayer.ts";






















































const ObjectFitMap = {
    [1 /* RenderMode.FILL */]: 'cover',
    [0 /* RenderMode.FIT */]: 'contain'
};
const defaultAVPlayerOptions = {
    enableHardware: true,
    enableWebGPU: true,
    loop: false,
    jitterBufferMax: 10,
    jitterBufferMin: 4,
    lowLatency: false
};
class AVPlayerGlobalData {
    avpacketList;
    avframeList;
    avpacketListMutex;
    avframeListMutex;
    jitterBuffer;
}
(function (prototype) {
    var map = new Map();
    map.set("avpacketList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("avframeList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("avpacketListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("avframeListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("jitterBuffer", { 0: _avpipeline_struct_jitter_ts__WEBPACK_IMPORTED_MODULE_3__.JitterBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_4__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_4__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_4__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructLength, 40);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_4__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructKeysMeta, map);
})(AVPlayerGlobalData.prototype);
const Ext2Format = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'ivf': 4 /* AVFormat.IVF */,
    'opus': 3 /* AVFormat.OGGS */,
    'ogg': 3 /* AVFormat.OGGS */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 7 /* AVFormat.MP3 */,
    'mkv': 5 /* AVFormat.MATROSKA */,
    'mka': 5 /* AVFormat.MATROSKA */,
    'webm': 5 /* AVFormat.WEBM */
};
const Ext2IOLoader = {
    'm3u8': 2 /* IOType.HLS */,
    'm3u': 2 /* IOType.HLS */,
    'mpd': 3 /* IOType.DASH */
};
class AVPlayer extends common_event_Emitter__WEBPACK_IMPORTED_MODULE_6__["default"] {
    static level = common_util_logger__WEBPACK_IMPORTED_MODULE_7__.INFO;
    static DemuxThreadReady;
    static AudioThreadReady;
    static VideoThreadReady;
    static MSEThreadReady;
    // 下面的线程所有 AVPlayer 实例共享
    static IOThread;
    static DemuxerThread;
    static AudioDecoderThread;
    static AudioRenderThread;
    static VideoRenderThread;
    static MSEThread;
    static audioContext;
    // 解码线程每个 player 独占一个
    // TODO 若需要同时播放大量视频，可以考虑实现一个 VideoDecoderThreadPool
    // 来根据各个视频规格做线程解码任务调度，降低系统线程切换开销，这里就不实现了
    VideoDecoderThread;
    // AVPlayer 各个线程间共享的数据
    GlobalData;
    taskId;
    subTaskId;
    ext;
    source;
    options;
    ioloader2DemuxerChannel;
    demuxer2VideoDecoderChannel;
    demuxer2AudioDecoderChannel;
    videoDecoder2VideoRenderChannel;
    audioDecoder2AudioRenderChannel;
    audioRender2AudioWorkletChannel;
    audioSourceNode;
    gainNode;
    streams;
    canvas;
    updateCanvas;
    video;
    audio;
    controller;
    volume;
    playRate;
    renderMode;
    renderRotate;
    flipHorizontal;
    flipVertical;
    useMSE;
    audioEnded;
    videoEnded;
    status;
    lastStatus;
    stats;
    statsController;
    jitterBufferController;
    constructor(options) {
        super(true);
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_8__.extend({}, defaultAVPlayerOptions, options);
        this.taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_9__["default"])();
        this.status = 0 /* AVPlayerStatus.STOPPED */;
        this.volume = 1;
        this.playRate = 1;
        this.renderMode = 0 /* RenderMode.FIT */;
        this.renderRotate = 0;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.stats = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_10__["default"])(avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.statsController = new _StatsController__WEBPACK_IMPORTED_MODULE_12__["default"](this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress]);
        this.GlobalData = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_10__["default"])(AVPlayerGlobalData);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28);
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`create player, taskId: ${this.taskId}`, cheap__fileName__15, 237);
    }
    async checkUseMSE() {
        {
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].mse) {
                return false;
            }
            // 不支持 wasm
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].wasmBaseSupported) {
                return true;
            }
            const videoStream = this.streams.find((stream) => {
                return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */;
            });
            const audioStream = this.streams.find((stream) => {
                return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */;
            });
            // 检查音视频在 MediaSource 里面是否支持，不支持的只能使用 wasm 软解了
            if (videoStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_15__["default"])().isTypeSupported((0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_16__["default"])(videoStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`can not support mse for codec: ${(0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_16__["default"])(videoStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__15, 260);
                return false;
            }
            if (audioStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_15__["default"])().isTypeSupported((0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_17__["default"])(audioStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`can not support mse for codec: ${(0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_17__["default"])(audioStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__15, 264);
                return false;
            }
            if (this.options.checkUseMES) {
                return this.options.checkUseMES(this.streams);
            }
            if (videoStream) {
                // 1080p 以上使用 mse
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 48) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 52) > 2073600) {
                    // 不支持 webcodec
                    if (!common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].videoDecoder) {
                        return true;
                    }
                    let extradata = null;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[20](videoStream.codecpar + 12) !== 0) {
                        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[20](videoStream.codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 16));
                    }
                    // 检查视频格式是否支持硬解，不支持使用 mse
                    const isWebcodecSupport = await VideoDecoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_19__["default"])(videoStream.codecpar),
                        codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 48),
                        codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 52),
                        description: extradata,
                        hardwareAcceleration: (0,avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_20__.getHardwarePreference)(true)
                    });
                    if (!isWebcodecSupport.supported) {
                        return true;
                    }
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 48) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](videoStream.codecpar + 52) === 2073600) {
                    // safari 1080p@30fps 无法在 worker 中解码
                    if (common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true) && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(videoStream.codecpar + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational)) > 30) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    createCanvas() {
        const canvas = document.createElement('canvas');
        canvas.className = 'avplayer-canvas';
        canvas.width = this.options.container.offsetWidth * devicePixelRatio;
        canvas.height = this.options.container.offsetHeight * devicePixelRatio;
        canvas.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        canvas.ondragstart = () => false;
        return canvas;
    }
    createVideo() {
        if (this.video) {
            this.options.container.removeChild(this.video);
        }
        const video = document.createElement('video');
        video.autoplay = true;
        video.className = 'avplayer-video';
        video.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        this.options.container.appendChild(video);
        this.video = video;
    }
    createAudio() {
        if (this.audio) {
            this.options.container.removeChild(this.audio);
        }
        const audio = document.createElement('audio');
        audio.autoplay = true;
        audio.className = 'avplayer-audio';
        this.options.container.appendChild(audio);
        this.audio = audio;
    }
    handleTimeupdate(element) {
        let lastNotifyTime = 0;
        element.ontimeupdate = () => {
            const time = element.currentTime;
            if (Math.abs(time - lastNotifyTime) >= 1) {
                if (this.status === 4 /* AVPlayerStatus.PLAYED */) {
                    this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.TIME, [BigInt(Math.floor(time * 1000))]);
                    AVPlayer.MSEThread.setCurrentTime(this.taskId, time);
                }
                lastNotifyTime = time;
            }
        };
        element.onended = () => {
            this.audioEnded = true;
            this.videoEnded = true;
            this.handleEnded();
        };
        element.onwaiting = () => {
            if (this.audio === element) {
                this.stats.audioStutter++;
            }
            else {
                this.stats.audioStutter++;
                this.stats.videoStutter++;
            }
        };
    }
    async handleEnded() {
        if (this.audioEnded && this.videoEnded) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player ended, taskId: ${this.taskId}`, cheap__fileName__15, 381);
            if (this.options.loop && !this.options.isLive) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`loop play, taskId: ${this.taskId}`, cheap__fileName__15, 385);
                if ( true && (this.ext === 'm3u8' || this.ext === 'm3u')) {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                }
                else if ( true && this.ext === 'mpd') {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    if (this.subTaskId) {
                        await AVPlayer.DemuxerThread.seek(this.subTaskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    }
                }
                else {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 8 /* AVSeekFlags.FRAME */);
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.TIME, [BigInt(0)]);
                if ( true && this.useMSE) {
                    if ((this.video || this.audio)?.src) {
                        URL.revokeObjectURL((this.video || this.audio).src);
                    }
                    await AVPlayer.MSEThread.restart(this.taskId);
                    const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
                    if (mediaSource) {
                        if (common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                            (this.video || this.audio).srcObject = mediaSource;
                        }
                        else {
                            (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                        }
                        if (this.video) {
                            this.video.currentTime = 0;
                            this.video.playbackRate = this.playRate;
                        }
                        else if (this.audio) {
                            this.audio.currentTime = 0;
                            this.audio.playbackRate = this.playRate;
                        }
                        await Promise.all([
                            this.video?.play(),
                            this.audio?.play()
                        ]);
                    }
                }
                else {
                    if (this.audioDecoder2AudioRenderChannel) {
                        await AVPlayer.AudioDecoderThread.resetTask(this.taskId);
                        await AVPlayer.AudioRenderThread.restart(this.taskId);
                    }
                    if (this.audioSourceNode) {
                        await this.audioSourceNode.request('restart');
                        if (AVPlayer.audioContext.state === 'suspended') {
                            await AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        }
                        this.audioEnded = false;
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        await this.VideoDecoderThread.resetTask(this.taskId);
                        await AVPlayer.VideoRenderThread.restart(this.taskId);
                        this.videoEnded = false;
                    }
                }
            }
            else {
                if ((this.video || this.audio)?.src) {
                    URL.revokeObjectURL((this.video || this.audio).src);
                }
                if (this.video) {
                    this.options.container.removeChild(this.video);
                    this.video = null;
                }
                if (this.audio) {
                    this.options.container.removeChild(this.audio);
                    this.audio = null;
                }
                if (this.canvas) {
                    this.options.container.removeChild(this.canvas);
                    this.canvas = null;
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.ENDED);
            }
        }
    }
    async load(source) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call load, taskId: ${this.taskId}`, cheap__fileName__15, 475);
        this.status = 1 /* AVPlayerStatus.LOADING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.LOADING);
        this.controller = new _Controller__WEBPACK_IMPORTED_MODULE_26__["default"](this);
        this.ioloader2DemuxerChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memset)(this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress], 0, 256);
        await AVPlayer.startDemuxPipeline();
        let ext = '';
        let ret = 0;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_28__.string(source)) {
            ext = common_util_url__WEBPACK_IMPORTED_MODULE_29__.parse(source).file.split('.').pop();
            // 注册一个 url io 任务
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: Ext2IOLoader[ext] ?? 0 /* IOType.Fetch */,
                info: {
                    url: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress]
            });
        }
        else {
            this.options.isLive = false;
            ext = source.name.split('.').pop();
            // 注册一个文件 io 任务
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: false
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress]
            });
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`register io task failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 536);
        }
        if ( true && ext === 'mpd') {
            await AVPlayer.IOThread.open(this.taskId);
            const hasAudio = await AVPlayer.IOThread.hasAudio(this.taskId);
            const hasVideo = await AVPlayer.IOThread.hasVideo(this.taskId);
            if (hasAudio && hasVideo) {
                // dash 因为音视频各自独立，因此这里注册两个解封装任务
                this.subTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_9__["default"])();
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2)
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    format: Ext2Format[ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        type: 'audio'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                });
                await AVPlayer.DemuxerThread.registerTask({
                    taskId: this.subTaskId,
                    mainTaskId: this.taskId,
                    format: Ext2Format[ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        type: 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                });
            }
            else {
                // dash 只有一个媒体类型
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2)
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    format: Ext2Format[ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        type: hasAudio ? 'audio' : 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                });
            }
        }
        else {
            await AVPlayer.DemuxerThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port2)
                .invoke({
                taskId: this.taskId,
                leftPort: this.ioloader2DemuxerChannel.port2,
                format: Ext2Format[ext],
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                isLive: this.options.isLive,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
            });
        }
        ret = await AVPlayer.DemuxerThread.openStream(this.taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 607);
        }
        let streams = await AVPlayer.DemuxerThread.analyzeStreams(this.taskId);
        if (!streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`analyze stream failed, ret: ${streams}`, cheap__fileName__15, 611);
        }
        if ( true && this.subTaskId) {
            ret = await AVPlayer.DemuxerThread.openStream(this.subTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 617);
            }
            const subStreams = await AVPlayer.DemuxerThread.analyzeStreams(this.subTaskId);
            if (!subStreams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`analyze stream failed, ret: ${streams}`, cheap__fileName__15, 621);
            }
            streams = streams.concat(subStreams);
        }
        this.streams = streams;
        this.ext = ext;
        this.source = source;
        let info = `
      taskId: ${this.taskId}
      input: ${common_util_is__WEBPACK_IMPORTED_MODULE_28__.string(source) ? source : source.name}
      stream:
    `;
        this.streams.forEach((stream) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                this.stats.audiocodec = (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_30__["default"])(stream.codecpar);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                this.stats.videocodec = (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_19__["default"])(stream.codecpar);
            }
            info += `
        #${stream.index}(und): ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ ? 'Audio' : 'Video'}: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ ? this.stats.audiocodec : this.stats.videocodec}
      `;
        });
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(info, cheap__fileName__15, 647);
        {
            // m3u8 和 dash 的 duration 来自于协议本身
            if (ext === 'm3u8' || ext === 'm3u' || ext === 'mpd') {
                const duration = (await AVPlayer.IOThread.getDuration(this.taskId)) * 1000;
                if (duration > 0) {
                    for (let i = 0; i < this.streams.length; i++) {
                        this.streams[i].duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avRescaleQ)(BigInt(Math.floor(duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_31__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(this.streams[i].timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational));
                    }
                }
            }
        }
        if (this.options.isLive && this.options.lowLatency) {
            const min = Math.max(await AVPlayer.IOThread.getMinBuffer(this.taskId), this.options.jitterBufferMin);
            let max = this.options.jitterBufferMax;
            if (max <= min) {
                max = min + ((ext === 'm3u8' || ext === 'm3u' || ext === 'mpd') ? min : 1);
            }
            this.jitterBufferController = new _JitterBufferController__WEBPACK_IMPORTED_MODULE_32__["default"]({
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 32,
                lowLatencyStart: !(ext === 'm3u8' || ext === 'm3u' || ext === 'mpd'),
                useMse: this.useMSE,
                max,
                min,
                observer: {
                    onCroppingBuffer: (max) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.debug(`cropping buffer by jitter buffer, max: ${max}, taskId: ${this.taskId}`, cheap__fileName__15, 680);
                        AVPlayer.DemuxerThread?.croppingAVPacketQueue(this.taskId, BigInt(max >>> 0));
                    },
                    onSetPlayRate: (rate) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.debug(`set play rate by jitter buffer, rate: ${rate}, taskId: ${this.taskId}`, cheap__fileName__15, 684);
                        if ( true && this.useMSE) {
                            AVPlayer.MSEThread.setPlayRate(this.taskId, rate);
                            if (this.video) {
                                this.video.playbackRate = rate;
                            }
                            else if (this.audio) {
                                this.audio.playbackRate = rate;
                            }
                        }
                        else {
                            if (this.audioDecoder2AudioRenderChannel) {
                                AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, rate);
                            }
                            if (this.videoDecoder2VideoRenderChannel) {
                                AVPlayer.VideoRenderThread.setPlayRate(this.taskId, rate);
                            }
                        }
                    }
                }
            });
        }
        this.status = 2 /* AVPlayerStatus.LOADED */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.LOADED);
    }
    async play(options = {
        audio: true,
        video: true
    }) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call play, options: ${JSON.stringify(options)}, status: ${this.status} taskId: ${this.taskId}`, cheap__fileName__15, 720);
        if (this.status === 4 /* AVPlayerStatus.PLAYED */) {
            return;
        }
        if (!options.audio && !options.video) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`video and audio must play one, ignore options, we will try to play video and audio, taskId: ${this.taskId}`, cheap__fileName__15, 727);
            options.audio = true;
            options.video = true;
        }
        const promises = [];
        if (this.status === 5 /* AVPlayerStatus.PAUSED */) {
            if ( true && this.useMSE) {
                promises.push(AVPlayer.MSEThread.unpause(this.taskId));
                if (this.audio) {
                    this.audio.play();
                }
                else if (this.video) {
                    this.video.play();
                }
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('unpause'));
                    if (AVPlayer.audioContext.state === 'suspended') {
                        promises.push(AVPlayer.AudioRenderThread.unpause(this.taskId));
                    }
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(AVPlayer.VideoRenderThread.unpause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                this.status = 4 /* AVPlayerStatus.PLAYED */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.PLAYED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.start();
                }
            });
        }
        this.status = 3 /* AVPlayerStatus.PLAYING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.PLAYING);
        this.useMSE = await this.checkUseMSE();
        this.audioEnded = true;
        this.videoEnded = true;
        if ( true && this.useMSE) {
            await AVPlayer.startMSEPipeline();
            // 注册一个 mse 处理任务
            await AVPlayer.MSEThread.registerTask.transfer(this.controller.getMuxerRenderControlPort())
                .invoke({
                taskId: this.taskId,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                format: await AVPlayer.DemuxerThread.getFormat(this.taskId),
                controlPort: this.controller.getMuxerRenderControlPort(),
                isLive: this.options.isLive,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                enableJitterBuffer: !!this.jitterBufferController,
                jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 32
            });
            let hasVideo = false;
            for (let i = 0; i < this.streams.length; i++) {
                const stream = this.streams[i];
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */ && options.video) {
                    hasVideo = true;
                    this.videoEnded = false;
                    this.demuxer2VideoDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    await AVPlayer.DemuxerThread.connectStreamTask
                        .transfer(this.demuxer2VideoDecoderChannel.port1)
                        .invoke(this.subTaskId || this.taskId, stream.index, this.demuxer2VideoDecoderChannel.port1);
                    await AVPlayer.MSEThread.addStream.transfer(this.demuxer2VideoDecoderChannel.port2)
                        .invoke(this.taskId, stream.index, stream.codecpar, stream.timeBase, stream.startTime, this.demuxer2VideoDecoderChannel.port2);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ && options.audio) {
                    this.audioEnded = false;
                    this.demuxer2AudioDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    await AVPlayer.DemuxerThread.connectStreamTask
                        .transfer(this.demuxer2AudioDecoderChannel.port1)
                        .invoke(this.taskId, stream.index, this.demuxer2AudioDecoderChannel.port1);
                    await AVPlayer.MSEThread.addStream.transfer(this.demuxer2AudioDecoderChannel.port2)
                        .invoke(this.taskId, stream.index, stream.codecpar, stream.timeBase, stream.startTime, this.demuxer2AudioDecoderChannel.port2);
                }
            }
            if (hasVideo) {
                this.createVideo();
            }
            else {
                this.createAudio();
            }
            const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
            if (mediaSource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                    (this.video || this.audio).srcObject = mediaSource;
                }
                else {
                    (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                }
                this.handleTimeupdate(this.video || this.audio);
            }
        }
        else {
            let audioStartTime = BigInt(0);
            let videoStartTime = BigInt(0);
            for (let i = 0; i < this.streams.length; i++) {
                const stream = this.streams[i];
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */ && options.video) {
                    await this.createVideoDecoderThread();
                    await AVPlayer.startVideoRenderPipeline();
                    videoStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avRescaleQ)(stream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_31__.AV_MILLI_TIME_BASE_Q);
                    this.demuxer2VideoDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    this.videoDecoder2VideoRenderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    const wasmUrl = this.options.getWasm('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4));
                    let resource;
                    if (wasmUrl) {
                        resource = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__["default"])({
                            source: wasmUrl
                        });
                        if (cheap_config__WEBPACK_IMPORTED_MODULE_34__.USE_THREADS && true) {
                            resource.threadModule = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__["default"])({
                                // firefox 使用 arraybuffer 会卡主
                                source: common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].firefox ? wasmUrl : resource.buffer
                            }, {
                                child: true
                            });
                        }
                        delete resource.buffer;
                    }
                    else {
                        if (common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].videoDecoder) {
                            const isSupport = await VideoDecoder.isConfigSupported({
                                codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_19__["default"])(stream.codecpar)
                            });
                            if (!isSupport.supported) {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__15, 891);
                            }
                        }
                        else {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__15, 895);
                        }
                    }
                    // 注册一个视频解码任务
                    await this.VideoDecoderThread.registerTask
                        .transfer(this.demuxer2VideoDecoderChannel.port2, this.videoDecoder2VideoRenderChannel.port1)
                        .invoke({
                        taskId: this.taskId,
                        resource,
                        leftPort: this.demuxer2VideoDecoderChannel.port2,
                        rightPort: this.videoDecoder2VideoRenderChannel.port1,
                        stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                        enableHardware: this.options.enableHardware,
                        avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                        avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                        avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 12,
                        avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28
                    });
                    await this.VideoDecoderThread.open(this.taskId, stream.codecpar);
                    await AVPlayer.DemuxerThread.connectStreamTask
                        .transfer(this.demuxer2VideoDecoderChannel.port1)
                        .invoke(this.subTaskId || this.taskId, stream.index, this.demuxer2VideoDecoderChannel.port1);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ && options.audio) {
                    await AVPlayer.startAudioPipeline();
                    if (AVPlayer.audioContext.state === 'suspended') {
                        await Promise.race([
                            AVPlayer.audioContext.resume(),
                            new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_35__["default"](0.1)
                        ]);
                    }
                    audioStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avRescaleQ)(stream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_31__.AV_MILLI_TIME_BASE_Q);
                    this.demuxer2AudioDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    this.audioDecoder2AudioRenderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_27__["default"])();
                    // 注册一个音频解码任务
                    await AVPlayer.AudioDecoderThread.registerTask
                        .transfer(this.demuxer2AudioDecoderChannel.port2, this.audioDecoder2AudioRenderChannel.port1)
                        .invoke({
                        taskId: this.taskId,
                        resource: await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__["default"])({
                            source: this.options.getWasm('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4))
                        }),
                        leftPort: this.demuxer2AudioDecoderChannel.port2,
                        rightPort: this.audioDecoder2AudioRenderChannel.port1,
                        stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                        avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                        avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24,
                        avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 12,
                        avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28
                    });
                    await AVPlayer.AudioDecoderThread.open(this.taskId, stream.codecpar, stream.timeBase);
                    await AVPlayer.DemuxerThread.connectStreamTask
                        .transfer(this.demuxer2AudioDecoderChannel.port1)
                        .invoke(this.taskId, stream.index, this.demuxer2AudioDecoderChannel.port1);
                }
            }
            if (this.videoDecoder2VideoRenderChannel) {
                this.canvas = this.createCanvas();
                this.options.container.appendChild(this.canvas);
                const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_36__["default"])() && cheap_config__WEBPACK_IMPORTED_MODULE_34__.USE_THREADS && true)
                    ? this.canvas.transferControlToOffscreen()
                    : this.canvas;
                const stream = this.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */;
                });
                // 注册一个视频渲染任务
                await AVPlayer.VideoRenderThread.registerTask
                    .transfer(this.videoDecoder2VideoRenderChannel.port2, this.controller.getVideoRenderControlPort(), canvas)
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.videoDecoder2VideoRenderChannel.port2,
                    controlPort: this.controller.getVideoRenderControlPort(),
                    canvas,
                    renderMode: this.renderMode,
                    renderRotate: this.renderRotate,
                    flipHorizontal: this.flipHorizontal,
                    flipVertical: this.flipVertical,
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4),
                    },
                    viewportWidth: this.options.container.offsetWidth,
                    viewportHeight: this.options.container.offsetHeight,
                    devicePixelRatio: devicePixelRatio,
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    enableWebGPU: this.options.enableWebGPU,
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController && !this.audioDecoder2AudioRenderChannel,
                    jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 32
                });
                this.videoEnded = false;
                await AVPlayer.VideoRenderThread.setPlayRate(this.taskId, this.playRate);
                promises.push(AVPlayer.VideoRenderThread.play(this.taskId));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                const stream = this.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */;
                });
                this.audioRender2AudioWorkletChannel = new MessageChannel();
                // 注册一个音频渲染任务
                await AVPlayer.AudioRenderThread.registerTask
                    .transfer(this.audioDecoder2AudioRenderChannel.port2, this.audioRender2AudioWorkletChannel.port1, this.controller.getAudioRenderControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.audioDecoder2AudioRenderChannel.port2,
                    rightPort: this.audioRender2AudioWorkletChannel.port1,
                    controlPort: this.controller.getAudioRenderControlPort(),
                    playFormat: 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
                    playSampleRate: AVPlayer.audioContext.sampleRate,
                    playChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 140),
                    resamplerResource: await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__["default"])({
                        source: this.options.getWasm('resampler')
                    }),
                    stretchpitcherResource: await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_33__["default"])({
                        source: this.options.getWasm('stretchpitcher')
                    }),
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress],
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4),
                    },
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController,
                    jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 32
                });
                // 创建一个音频源节点
                if (common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].audioWorklet) {
                    this.audioSourceNode = new avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_37__["default"](AVPlayer.audioContext, {
                        onEnded: () => {
                            this.onAudioEnded();
                        },
                        onFirstRendered: () => {
                            this.onFirstAudioRendered();
                        },
                        onStutter: () => {
                            this.onStutter();
                        }
                    }, {
                        numberOfInputs: 1,
                        numberOfOutputs: 1,
                        outputChannelCount: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 140)]
                    });
                }
                else {
                    this.audioSourceNode = new avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_38__["default"](AVPlayer.audioContext, {
                        onEnded: () => {
                            this.onAudioEnded();
                        },
                        onFirstRendered: () => {
                            this.onFirstAudioRendered();
                        },
                        onStutter: () => {
                            this.onStutter();
                        }
                    }, {
                        numberOfInputs: 1,
                        numberOfOutputs: 1,
                        outputChannelCount: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 140)]
                    });
                }
                if (cheap_config__WEBPACK_IMPORTED_MODULE_34__.USE_THREADS
                    && true
                    && common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].audioWorklet
                    && (!common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true))) {
                    await this.audioSourceNode.request('init', {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory
                    });
                }
                await AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, this.playRate);
                this.gainNode = AVPlayer.audioContext.createGain();
                this.gainNode.connect(AVPlayer.audioContext.destination);
                this.audioSourceNode.connect(this.gainNode);
                this.setVolume(this.volume);
                this.audioEnded = false;
                promises.push(this.audioSourceNode.request('start', {
                    port: this.audioRender2AudioWorkletChannel.port2,
                    channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 140)
                }, [this.audioRender2AudioWorkletChannel.port2]));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            }
            else if (this.videoDecoder2VideoRenderChannel) {
                this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            }
            // 开始时间戳超过 10 秒不对齐就不再同步音视频了
            // 这种情况下可视为音频和视频本身就是独立的，各自播放
            if (this.videoDecoder2VideoRenderChannel
                && this.audioDecoder2AudioRenderChannel
                && common_util_bigint__WEBPACK_IMPORTED_MODULE_39__.abs(videoStartTime - audioStartTime) > BigInt(10000)) {
                this.controller.setEnableAudioVideoSync(false);
            }
        }
        let maxQueueLength = 10;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_28__.string(this.source) && !this.options.isLive) {
            this.streams.forEach((stream) => {
                maxQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(stream.codecpar + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational)) * 4), maxQueueLength);
            });
        }
        promises.push(AVPlayer.DemuxerThread.startDemux(this.taskId, this.options.isLive, maxQueueLength));
        if (this.subTaskId) {
            promises.push(AVPlayer.DemuxerThread.startDemux(this.subTaskId, this.options.isLive, maxQueueLength));
        }
        return Promise.all(promises).then(async () => {
            this.status = 4 /* AVPlayerStatus.PLAYED */;
            if ( true && this.useMSE) {
                await Promise.all([
                    this.video?.play(),
                    this.audio?.play()
                ]).catch((error) => {
                    if (this.video) {
                        this.video.muted = true;
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__15, 1153);
                        return this.video.play();
                    }
                    else {
                        throw error;
                    }
                });
            }
            else {
                if (this.audioSourceNode && AVPlayer.audioContext.state === 'suspended') {
                    if (AVPlayer.audioContext.state === 'suspended') {
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__15, 1165);
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
                    }
                    else {
                        // 只有音频无法播放时直接抛错，和 mse 行为保持一致
                        throw new Error('the audioContext was not started. It must be resumed after a user gesture');
                    }
                }
            }
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.PLAYED);
            this.statsController.start();
            if (this.jitterBufferController) {
                this.jitterBufferController.start();
            }
        });
    }
    /**
     * 暂停播放
     */
    async pause() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call pause, taskId: ${this.taskId}`, cheap__fileName__15, 1190);
        if (!this.options.isLive) {
            const promises = [];
            if ( true && this.useMSE) {
                if (this.audio) {
                    this.audio.pause();
                }
                if (this.video) {
                    this.video.pause();
                }
                promises.push(AVPlayer.MSEThread.pause(this.taskId));
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('pause'));
                    // stop fake play
                    if (AVPlayer.audioContext.state === 'suspended') {
                        promises.push(AVPlayer.AudioRenderThread.pause(this.taskId));
                    }
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(AVPlayer.VideoRenderThread.pause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                if (this.status === 6 /* AVPlayerStatus.SEEKING */) {
                    this.lastStatus = 5 /* AVPlayerStatus.PAUSED */;
                }
                else {
                    this.status = 5 /* AVPlayerStatus.PAUSED */;
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.PAUSED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.stop();
                }
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`pause can only used in vod, taskId: ${this.taskId}`, cheap__fileName__15, 1229);
        }
    }
    /**
     * 跳转到指定时间戳位置播放（只支持点播）
     * 某些文件可能不会 seek 成功
     *
     * @param timestamp 毫秒
     */
    async seek(timestamp) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call seek, timestamp: ${timestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1241);
        if (!this.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`cannot found any stream to seek, taskId: ${this.taskId}`, cheap__fileName__15, 1244);
            return;
        }
        if (this.status === 6 /* AVPlayerStatus.SEEKING */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`player is seeking now, taskId: ${this.taskId}`, cheap__fileName__15, 1249);
            return;
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.SEEKING);
        if (!this.options.isLive) {
            this.lastStatus = this.status;
            this.status = 6 /* AVPlayerStatus.SEEKING */;
            const timestampBitInt = BigInt(Math.floor(timestamp));
            if ( true && this.useMSE) {
                await AVPlayer.MSEThread.beforeSeek(this.taskId);
            }
            else {
                await Promise.all([
                    AVPlayer.AudioRenderThread?.beforeSeek(this.taskId),
                    AVPlayer.VideoRenderThread?.beforeSeek(this.taskId)
                ]);
            }
            let seekedTimestamp = -BigInt(1);
            if ( true && (this.ext === 'm3u8' || this.ext === 'm3u')) {
                seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestampBitInt, 16 /* AVSeekFlags.TIMESTAMP */);
            }
            else if ( true && this.ext === 'mpd') {
                seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestampBitInt, 16 /* AVSeekFlags.TIMESTAMP */);
                if (this.subTaskId) {
                    await AVPlayer.DemuxerThread.seek(this.subTaskId, timestampBitInt, 16 /* AVSeekFlags.TIMESTAMP */);
                }
            }
            else {
                seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestampBitInt, 8 /* AVSeekFlags.FRAME */);
            }
            if (seekedTimestamp >= BigInt(0)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.debug(`seeked to packet timestamp: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1286);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`demuxer seek failed, code: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1289);
            }
            if ( true && this.useMSE) {
                if (seekedTimestamp >= BigInt(0)) {
                    const time = await AVPlayer.MSEThread.afterSeek(this.taskId, seekedTimestamp > timestampBitInt ? seekedTimestamp : timestampBitInt);
                    if (this.video) {
                        this.video.currentTime = time;
                    }
                    else if (this.audio) {
                        this.audio.currentTime = time;
                    }
                }
                else {
                    await AVPlayer.MSEThread.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.NOPTS_VALUE_BIGINT);
                }
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.SEEKED);
            }
            else {
                let maxQueueLength = 20;
                this.streams.forEach((stream) => {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        maxQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_23__["default"])(stream.codecpar + 160, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_24__.Rational))), maxQueueLength);
                    }
                });
                if (seekedTimestamp >= BigInt(0)) {
                    await Promise.all([
                        AVPlayer.AudioDecoderThread?.resetTask(this.taskId),
                        this.VideoDecoderThread?.resetTask(this.taskId)
                    ]);
                    await Promise.all([
                        AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestampBitInt ? seekedTimestamp : timestampBitInt, maxQueueLength),
                        AVPlayer.VideoRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestampBitInt ? seekedTimestamp : timestampBitInt, maxQueueLength),
                    ]);
                    await Promise.all([
                        AVPlayer.AudioRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestampBitInt ? seekedTimestamp : timestampBitInt),
                        AVPlayer.VideoRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestampBitInt ? seekedTimestamp : timestampBitInt),
                    ]);
                }
                else {
                    await Promise.all([
                        AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.NOPTS_VALUE_BIGINT, maxQueueLength),
                        AVPlayer.VideoRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.NOPTS_VALUE_BIGINT, maxQueueLength),
                    ]);
                    await Promise.all([
                        AVPlayer.AudioRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.NOPTS_VALUE_BIGINT),
                        AVPlayer.VideoRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.NOPTS_VALUE_BIGINT),
                    ]);
                }
                this.status = this.lastStatus;
                if (this.jitterBufferController) {
                    this.jitterBufferController.reset();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`seek can only used in vod, taskId: ${this.taskId}`, cheap__fileName__15, 1355);
        }
    }
    getStreams() {
        return this.streams;
    }
    /**
     * 获取总时长（毫秒）
     *
     * @returns
     */
    getDuration() {
        if (!this.options.isLive) {
            let max = BigInt(0);
            this.streams.forEach((stream) => {
                const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_22__.avRescaleQ)(stream.duration, {
                    den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4),
                    num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase)
                }, avutil_constant__WEBPACK_IMPORTED_MODULE_31__.AV_MILLI_TIME_BASE_Q);
                if (duration > max) {
                    max = duration;
                }
            });
            return max;
        }
        return BigInt(0);
    }
    async stop() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call stop, taskId: ${this.taskId}`, cheap__fileName__15, 1391);
        if (this.status === 0 /* AVPlayerStatus.STOPPED */) {
            return;
        }
        if (this.audioSourceNode) {
            await this.audioSourceNode.request('stop');
            this.audioSourceNode.disconnect();
            this.audioSourceNode = null;
        }
        if (AVPlayer.VideoRenderThread) {
            await AVPlayer.VideoRenderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.unregisterTask(this.taskId);
        }
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.MSEThread) {
            await AVPlayer.MSEThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.unregisterTask(this.taskId);
            if (this.subTaskId) {
                await AVPlayer.DemuxerThread.unregisterTask(this.subTaskId);
            }
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.unregisterTask(this.taskId);
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
            this.gainNode = null;
        }
        if (this.controller) {
            this.controller.destroy();
        }
        if ((this.video || this.audio)?.src) {
            URL.revokeObjectURL((this.video || this.audio).src);
        }
        if (this.video) {
            this.options.container.removeChild(this.video);
            this.video = null;
        }
        if (this.audio) {
            this.options.container.removeChild(this.audio);
            this.audio = null;
        }
        if (this.canvas) {
            this.options.container.removeChild(this.canvas);
            this.canvas = null;
        }
        this.ioloader2DemuxerChannel = null;
        this.demuxer2VideoDecoderChannel = null;
        this.demuxer2AudioDecoderChannel = null;
        this.videoDecoder2VideoRenderChannel = null;
        this.audioDecoder2AudioRenderChannel = null;
        this.audioRender2AudioWorkletChannel = null;
        this.status = 0 /* AVPlayerStatus.STOPPED */;
        this.statsController.stop();
        if (this.jitterBufferController) {
            this.jitterBufferController.stop();
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.STOPPED);
    }
    /*
    * 设置播放速率（只支持点播）
    *
    * @param rate
    */
    setPlaybackRate(rate) {
        if (!this.options.isLive) {
            this.playRate = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_40__["default"])(rate, 0.5, 2);
            if ( true && this.useMSE) {
                AVPlayer.MSEThread.setPlayRate(this.taskId, this.playRate);
                if (this.video) {
                    this.video.playbackRate = this.playRate;
                }
                else if (this.audio) {
                    this.audio.playbackRate = this.playRate;
                }
            }
            else {
                AVPlayer.AudioRenderThread?.setPlayTempo(this.taskId, this.playRate);
                AVPlayer.VideoRenderThread?.setPlayRate(this.taskId, this.playRate);
                this.VideoDecoderThread?.setPlayRate(this.taskId, this.playRate);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call setPlaybackRate, set ${this.playRate}, taskId: ${this.taskId}`, cheap__fileName__15, 1488);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn(`setPlaybackRate can only used in playback, taskId: ${this.taskId}`, cheap__fileName__15, 1491);
        }
    }
    /**
     * 获取倍数值
     *
     * @returns
     */
    getPlaybackRate() {
        return this.playRate;
    }
    /**
     * resume 音频
     */
    async resume() {
        if (AVPlayer.audioContext?.state === 'suspended') {
            await Promise.race([
                AVPlayer.audioContext.resume(),
                new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_35__["default"](0.1)
            ]);
            if (AVPlayer.audioContext.state === 'suspended') {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.warn('the audioContext was not allowed to start. It must be resumed after a user gesture', cheap__fileName__15, 1514);
            }
            else {
                if (this.audioSourceNode) {
                    this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
                }
                if (this.video) {
                    this.video.muted = false;
                }
            }
        }
        if (this.video) {
            this.video.muted = false;
            if (!this.video.played) {
                await this.video.play();
            }
        }
        else if (this.audio) {
            this.audio.muted = false;
            if (!this.audio.played) {
                await this.audio.play();
            }
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call resume, taskId: ${this.taskId}`, cheap__fileName__15, 1538);
    }
    /**
     * 获取播放音量
     *
     * @returns
     */
    getVolume() {
        return this.volume;
    }
    /**
     * 设置播放音量
     *
     * @param volume [0, 3]
     *
     */
    setVolume(volume, force = false) {
        this.volume = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_40__["default"])(volume, 0, 3);
        if (this.gainNode && AVPlayer.audioContext) {
            this.gainNode.gain.cancelScheduledValues(AVPlayer.audioContext.currentTime);
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].firefox && !force) {
                this.gainNode.gain.setValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
            }
            else {
                if (this.gainNode.gain.value === 0 || this.volume === 0 || force) {
                    this.gainNode.gain.value = this.volume;
                }
                else {
                    this.gainNode.gain.exponentialRampToValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
                }
            }
        }
        if (this.video) {
            this.video.volume = this.volume;
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call setVolume, set ${volume}, used ${this.volume}, taskId: ${this.taskId}`, cheap__fileName__15, 1577);
    }
    /**
     *
     * 获取渲染模式
     *
     * @param mode
     * @returns
     */
    getRenderMode() {
        return this.renderMode;
    }
    /**
     * 设置画面填充模式
     *
     * - 0 自适应
     * - 1 填充
     *
     * @param mode
     */
    setRenderMode(mode) {
        this.renderMode = mode;
        if ( true && this.useMSE && this.video) {
            this.video.style['object-fit'] = ObjectFitMap[this.renderMode];
        }
        else {
            AVPlayer.VideoRenderThread?.setRenderMode(this.taskId, mode);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call setRenderMode, mode: ${mode}, taskId: ${this.taskId}`, cheap__fileName__15, 1607);
    }
    getVideoTransformContext() {
        let text = '';
        if (this.renderRotate !== 0) {
            text += `rotateZ(${this.renderRotate}deg)`;
        }
        if (this.flipHorizontal) {
            text += `${text.length ? ' ' : ''}scaleX(-1)`;
        }
        if (this.flipVertical) {
            text += `${text.length ? ' ' : ''}scaleY(-1)`;
        }
        return text;
    }
    /**
     * 设置视频渲染旋转角度
     *
     * @param angle
     */
    setRotate(angle) {
        this.renderRotate = angle;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.setRenderRotate(this.taskId, angle);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call setRotate, angle: ${angle}, taskId: ${this.taskId}`, cheap__fileName__15, 1637);
    }
    enableHorizontalFlip(enable) {
        this.flipHorizontal = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.enableHorizontalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call enableHorizontalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 1648);
    }
    enableVerticalFlip(enable) {
        this.flipVertical = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.enableVerticalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call enableVerticalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 1659);
    }
    /**
     * 设置是否循环播放
     *
     * @param enable
     */
    setLoop(enable) {
        this.options.loop = enable;
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`call setLoop, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 1671);
    }
    /**
     * 重置渲染视图大小
     *
     * @param width
     * @param height
     */
    resize(width, height) {
        if (!this.useMSE) {
            AVPlayer.VideoRenderThread?.resize(this.taskId, width, height);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call resize, width: ${width}, height: ${height}, taskId: ${this.taskId}`, cheap__fileName__15, 1684);
    }
    isMSE() {
        return this.useMSE;
    }
    async getVideoList() {
        return AVPlayer.IOThread?.getVideoList(this.taskId);
    }
    async getAudioList() {
        return AVPlayer.IOThread?.getAudioList(this.taskId);
    }
    async getSubtitleList() {
        return AVPlayer.IOThread?.getSubtitleList(this.taskId);
    }
    async selectVideo(index) {
        return AVPlayer.IOThread?.selectVideo(this.taskId, index);
    }
    async selectAudio(index) {
        return AVPlayer.IOThread?.selectAudio(this.taskId, index);
    }
    async selectSubtitle(index) {
        return AVPlayer.IOThread?.selectSubtitle(this.taskId, index);
    }
    /**
     * 全屏
     */
    enterFullscreen() {
        const element = this.useMSE ? this.video : this.canvas;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        }
        else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        }
        else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        }
        else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call enterFullscreen, taskId: ${this.taskId}`, cheap__fileName__15, 1732);
    }
    /**
     * 退出全屏
     */
    exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.mozExitFullScreen) {
            document.mozExitFullScreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`player call exitFullscreen, taskId: ${this.taskId}`, cheap__fileName__15, 1748);
    }
    /**
     * 获取截图
     *
     * @param type 生成图片格式
     * @param quality 生成图片质量
     */
    snapshot(type = 'png', quality = 1) {
        if ( true && this.useMSE && this.video) {
            const canvas = document.createElement('canvas');
            canvas.width = this.video.videoWidth;
            canvas.height = this.video.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(this.video, 0, 0);
            return canvas.toDataURL(`image/${type}`, quality);
        }
        else if (this.canvas) {
            return this.canvas.toDataURL(`image/${type}`, quality);
        }
    }
    getStats() {
        return this.stats;
    }
    async destroy() {
        await this.stop();
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_41__["default"])(this.stats);
        this.stats = null;
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(this.VideoDecoderThread);
            this.VideoDecoderThread = null;
        }
        if (this.GlobalData) {
            this.GlobalData.avframeList.clear((avframe) => {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_43__.unrefAVFrame)(avframe);
            }, 20);
            this.GlobalData.avpacketList.clear((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_44__.unrefAVPacket)(avpacket);
            }, 20);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 24);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_5__.symbolStructAddress] + 28);
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_41__["default"])(this.GlobalData);
            this.GlobalData = null;
        }
    }
    onVideoEnded() {
        this.videoEnded = true;
        this.handleEnded();
    }
    onAudioEnded() {
        this.audioEnded = true;
        this.handleEnded();
    }
    onCanvasUpdated() {
        this.updateCanvas = this.createCanvas();
        const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_36__["default"])() && cheap_config__WEBPACK_IMPORTED_MODULE_34__.USE_THREADS && true)
            ? this.updateCanvas.transferControlToOffscreen()
            : this.updateCanvas;
        AVPlayer.VideoRenderThread.updateCanvas
            .transfer(canvas)
            .invoke(this.taskId, canvas);
    }
    onFirstVideoRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`first video frame rendered, taskId: ${this.taskId}`, cheap__fileName__15, 1823);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.FIRST_VIDEO_RENDERED);
    }
    onFirstAudioRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`first audio frame rendered, taskId: ${this.taskId}`, cheap__fileName__15, 1828);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.FIRST_VIDEO_RENDERED);
    }
    onStutter() {
        this.stats.audioStutter++;
    }
    onFirstVideoRenderedAfterUpdateCanvas() {
        if (this.updateCanvas) {
            if (this.canvas) {
                this.options.container.removeChild(this.canvas);
            }
            this.canvas = this.updateCanvas;
            this.options.container.appendChild(this.canvas);
            this.updateCanvas = null;
        }
    }
    onTimeUpdate(pts) {
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_25__.TIME, [pts]);
    }
    onMSESeek(time) {
        if (this.audio) {
            this.audio.currentTime = time;
        }
        else if (this.video) {
            this.video.currentTime = time;
        }
    }
    async createVideoDecoderThread() {
        if (this.VideoDecoderThread) {
            return;
        }
        this.VideoDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_45__["default"], {
            name: 'VideoDecoderThread',
            disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true)
        }, /*require.resolve*/(/*! ../avpipeline/VideoDecodePipeline.ts */ "./src/avpipeline/VideoDecodePipeline.ts")).run();
        this.VideoDecoderThread.setLogLevel(AVPlayer.level);
        this.VideoDecoderThread.setLogLevel(AVPlayer.level);
    }
    static async startDemuxPipeline() {
        if (AVPlayer.DemuxThreadReady) {
            return AVPlayer.DemuxThreadReady;
        }
        return AVPlayer.DemuxThreadReady = new Promise(async (resolve) => {
            AVPlayer.IOThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_46__["default"], {
                name: 'IOThread'
            }, /*require.resolve*/(/*! ../avpipeline/IOPipeline.ts */ "./src/avpipeline/IOPipeline.ts")).run();
            AVPlayer.IOThread.setLogLevel(AVPlayer.level);
            AVPlayer.DemuxerThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_47__["default"], {
                name: 'DemuxerThread'
            }, /*require.resolve*/(/*! ../avpipeline/DemuxPipeline.ts */ "./src/avpipeline/DemuxPipeline.ts")).run();
            AVPlayer.DemuxerThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startAudioPipeline() {
        if (AVPlayer.AudioThreadReady) {
            return AVPlayer.AudioThreadReady;
        }
        return AVPlayer.AudioThreadReady = new Promise(async (resolve) => {
            AVPlayer.audioContext = new (AudioContext || webkitAudioContext)();
            if (common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].audioWorklet) {
                await (0,avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_48__["default"])(AVPlayer.audioContext,  true && cheap_config__WEBPACK_IMPORTED_MODULE_34__.USE_THREADS && (!common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true))
                    ? /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor2 */ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts")
                    : /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor */ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts"));
            }
            AVPlayer.AudioDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_49__["default"], {
                name: 'AudioDecoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/AudioDecodePipeline.ts */ "./src/avpipeline/AudioDecodePipeline.ts")).run();
            AVPlayer.AudioDecoderThread.setLogLevel(AVPlayer.level);
            AVPlayer.AudioRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_50__["default"], {
                name: 'AudioRenderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_21__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/AudioRenderPipeline.ts */ "./src/avpipeline/AudioRenderPipeline.ts")).run();
            AVPlayer.AudioRenderThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startVideoRenderPipeline() {
        if (AVPlayer.VideoThreadReady) {
            return AVPlayer.VideoThreadReady;
        }
        return AVPlayer.VideoThreadReady = new Promise(async (resolve) => {
            AVPlayer.VideoRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_51__["default"], {
                name: 'VideoRenderThread',
                disableWorker: !(0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_36__["default"])()
            }, /*require.resolve*/(/*! ../avpipeline/VideoRenderPipeline.ts */ "./src/avpipeline/VideoRenderPipeline.ts")).run();
            AVPlayer.VideoRenderThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startMSEPipeline() {
        {
            if (AVPlayer.MSEThreadReady) {
                return AVPlayer.MSEThreadReady;
            }
            return AVPlayer.MSEThreadReady = new Promise(async (resolve) => {
                AVPlayer.MSEThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.createThreadFromClass)(_mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_52__["default"], {
                    name: 'MSEThread',
                    disableWorker: !common_util_support__WEBPACK_IMPORTED_MODULE_13__["default"].workerMSE
                }, /*require.resolve*/(/*! ./mse/MSEPipeline.ts */ "./src/avplayer/mse/MSEPipeline.ts")).run();
                AVPlayer.MSEThread.setLogLevel(AVPlayer.level);
                resolve();
            });
        }
    }
    static async startPipelines() {
        await AVPlayer.startDemuxPipeline();
        await AVPlayer.startAudioPipeline();
        await AVPlayer.startVideoRenderPipeline();
        await AVPlayer.startMSEPipeline();
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info('AVPlayer pipelines started', cheap__fileName__15, 1961);
    }
    static async stopPipelines() {
        if (AVPlayer.VideoRenderThread) {
            await AVPlayer.VideoRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.VideoRenderThread);
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.AudioRenderThread);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.AudioDecoderThread);
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.DemuxerThread);
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.IOThread);
        }
        {
            if (AVPlayer.MSEThread) {
                await AVPlayer.MSEThread.clear();
                (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_42__.closeThread)(AVPlayer.MSEThread);
            }
        }
        AVPlayer.AudioDecoderThread = null;
        AVPlayer.DemuxerThread = null;
        AVPlayer.IOThread = null;
        AVPlayer.audioContext = null;
        AVPlayer.MSEThread = null;
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info('AVPlayer pipelines stopped', cheap__fileName__15, 1998);
    }
    static setLogLevel(level) {
        AVPlayer.level = level;
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.setLevel(level);
        if (AVPlayer.IOThread) {
            AVPlayer.IOThread.setLogLevel(level);
        }
        if (AVPlayer.DemuxerThread) {
            AVPlayer.DemuxerThread.setLogLevel(level);
        }
        if (AVPlayer.AudioDecoderThread) {
            AVPlayer.AudioDecoderThread.setLogLevel(level);
        }
        if (AVPlayer.AudioRenderThread) {
            AVPlayer.AudioRenderThread.setLogLevel(level);
        }
        if (AVPlayer.VideoRenderThread) {
            AVPlayer.VideoRenderThread.setLogLevel(level);
        }
        if (AVPlayer.MSEThread) {
            AVPlayer.MSEThread.setLogLevel(level);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info(`set log level: ${level}`, cheap__fileName__15, 2025);
    }
}


/***/ }),

/***/ "./src/avplayer/Controller.ts":
/*!************************************!*\
  !*** ./src/avplayer/Controller.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function/createMessageChannel */ "./src/avplayer/function/createMessageChannel.ts");
/*
 * libmedia AVPlayer Controller
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class Controller {
    videoRenderControlChannel;
    audioRenderControlChannel;
    muxerControlChannel;
    videoRenderControlIPCPort;
    audioRenderControlIPCPort;
    muxerControlIPCPort;
    observer;
    visibilityHidden;
    onVisibilityChange;
    timeUpdateListenType;
    enableAudioVideoSync;
    constructor(observer) {
        this.observer = observer;
        this.videoRenderControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this.audioRenderControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this.muxerControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this.videoRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](this.videoRenderControlChannel.port2);
        this.audioRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](this.audioRenderControlChannel.port2);
        this.muxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](this.muxerControlChannel.port2);
        this.enableAudioVideoSync = true;
        this.videoRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onVideoEnded();
                    break;
                case 'updateCanvas':
                    this.observer.onCanvasUpdated();
                    break;
                case 'firstRendered':
                    this.observer.onFirstVideoRendered();
                    break;
                case 'firstRenderedAfterUpdateCanvas':
                    this.observer.onFirstVideoRenderedAfterUpdateCanvas();
                    break;
                case 'syncPts':
                    if (this.timeUpdateListenType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
            }
        });
        this.audioRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.NOTIFY, (request) => {
            switch (request.method) {
                case 'syncPts':
                    if (this.enableAudioVideoSync) {
                        this.videoRenderControlIPCPort.notify('syncPts', request.params);
                    }
                    if (this.timeUpdateListenType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
                case 'ended':
                    this.observer.onAudioEnded();
                    break;
            }
        });
        this.muxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.NOTIFY, (request) => {
            switch (request.method) {
                case 'seek':
                    this.observer.onMSESeek(request.params.time);
                    break;
            }
        });
        this.onVisibilityChange = (event) => {
            this.visibilityHidden = document.visibilityState === 'hidden';
            this.videoRenderControlIPCPort.notify('skipRender', {
                skipRender: this.visibilityHidden
            });
        };
        this.visibilityHidden = document.visibilityState === 'hidden';
        document.addEventListener('visibilitychange', this.onVisibilityChange);
    }
    getVideoRenderControlPort() {
        return this.videoRenderControlChannel.port1;
    }
    getAudioRenderControlPort() {
        return this.audioRenderControlChannel.port1;
    }
    getMuxerRenderControlPort() {
        return this.muxerControlChannel.port1;
    }
    setTimeUpdateListenType(type) {
        this.timeUpdateListenType = type;
    }
    setEnableAudioVideoSync(enable) {
        this.enableAudioVideoSync = enable;
    }
    destroy() {
        if (this.videoRenderControlIPCPort) {
            this.videoRenderControlIPCPort.destroy();
        }
        if (this.audioRenderControlIPCPort) {
            this.audioRenderControlIPCPort.destroy();
        }
        if (this.muxerControlIPCPort) {
            this.muxerControlIPCPort.destroy();
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
        this.videoRenderControlIPCPort = this.audioRenderControlIPCPort = this.muxerControlIPCPort = this.videoRenderControlChannel = this.audioRenderControlChannel = this.muxerControlChannel = null;
    }
}


/***/ }),

/***/ "./src/avplayer/JitterBufferController.ts":
/*!************************************************!*\
  !*** ./src/avplayer/JitterBufferController.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitterBufferController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/timer/WorkerTimer */ "./src/common/timer/WorkerTimer.ts");




const QUEUE_MAX = 10;
const BUFFER_STEP = 200;
const RATE_STEP = 0.01;
class JitterBufferController {
    timer;
    interval;
    data;
    lastIncomingPacketCount;
    shutterCount;
    lastShutterCount;
    isFirst;
    max;
    min;
    targetPlaybackRate;
    currentPlaybackRate;
    playbackRateTimer;
    options;
    constructor(options) {
        this.options = options;
        this.interval = 1000;
        this.isFirst = true;
        this.data = [];
        this.lastIncomingPacketCount = BigInt(0);
        this.shutterCount = 0;
        this.lastShutterCount = 0;
        this.max = (options.max * 1000) >>> 0;
        this.min = (options.min * 1000) >>> 0;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, this.min);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.max);
        if (options.lowLatencyStart) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.min + BUFFER_STEP);
        }
        this.targetPlaybackRate = 1;
        this.currentPlaybackRate = 1;
        this.playbackRateTimer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_1__["default"](() => {
            if (this.currentPlaybackRate > this.targetPlaybackRate) {
                const rate = Math.max(this.targetPlaybackRate, this.currentPlaybackRate - RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else if (this.currentPlaybackRate < this.targetPlaybackRate) {
                const rate = Math.min(this.targetPlaybackRate, this.currentPlaybackRate + RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else {
                this.playbackRateTimer.stop();
            }
        }, 0, 200);
        this.timer = new common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_2__["default"](this.onTimer.bind(this), 1000, this.interval);
    }
    start() {
        this.timer.start();
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 104);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 252) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 248);
        this.computePlayRate();
    }
    stop() {
        this.timer.stop();
        this.data.length = 0;
        this.isFirst = true;
        if (this.playbackRateTimer.isStarted()) {
            this.playbackRateTimer.stop();
            this.targetPlaybackRate = this.currentPlaybackRate = 1;
            this.options.observer.onSetPlayRate(1);
        }
    }
    reset() {
        this.data.length = 0;
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 104);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 252) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 248);
        this.targetPlaybackRate = this.currentPlaybackRate = 1;
    }
    setPlayRate(rate) {
        this.targetPlaybackRate = rate;
        if (this.options.useMse) {
            this.options.observer.onSetPlayRate(this.targetPlaybackRate);
            this.currentPlaybackRate = this.targetPlaybackRate;
        }
        else {
            if (this.currentPlaybackRate !== rate && !this.playbackRateTimer.isStarted()) {
                this.playbackRateTimer.start();
            }
        }
    }
    computePlayRate() {
        let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 212) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 212) * 1000)
            : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 200) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 112) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 200) * 1000)
                : 0);
        if ((buffer < (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) >> 1)) && buffer < 2) {
            this.setPlayRate(0.8);
        }
        else if ((buffer < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP) && buffer < 2) {
            this.setPlayRate(0.95);
        }
        else if (buffer > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP) {
            this.setPlayRate(1.05);
        }
        else {
            this.setPlayRate(1);
        }
        if (buffer > (this.max << 1)) {
            this.options.observer.onCroppingBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4));
        }
    }
    process() {
        const average = this.data.reduce((prev, value, index) => {
            return prev + value * (index + 1);
        }, 0) / (QUEUE_MAX * (QUEUE_MAX + 1) / 2);
        const variance = this.data.reduce((pre, value) => {
            return pre + Math.pow(value - average, 2);
        }, 0) / this.data.length;
        const jitter = Math.sqrt(variance);
        const incomingFramerate = Math.round(average / (this.interval / 1000));
        const needFramerate = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 200) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 212);
        if ((incomingFramerate < (needFramerate >> 1)) || this.shutterCount > 3) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) * 2, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) * 2, this.max));
        }
        else if (incomingFramerate >= needFramerate && jitter < 50) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
        }
        else if (jitter > 100) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
        }
        else if (jitter < 20) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) === this.min) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            }
        }
        else {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) === this.max) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
            }
        }
        this.computePlayRate();
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[19](this.options.stats + 240, jitter);
    }
    onTimer() {
        const count = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](this.options.stats + 104);
        if (this.isFirst) {
            this.isFirst = false;
        }
        else {
            this.data.push((Number(count - this.lastIncomingPacketCount & 0xffffffffn) >> 0));
        }
        this.lastIncomingPacketCount = count;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 252) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 248) > this.lastShutterCount) {
            this.shutterCount++;
        }
        else {
            this.shutterCount = 0;
        }
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 252) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.options.stats + 248);
        if (this.data.length > QUEUE_MAX) {
            this.data.shift();
        }
        if (this.data.length === QUEUE_MAX) {
            this.process();
        }
    }
}


/***/ }),

/***/ "./src/avplayer/StatsController.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/StatsController.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StatsController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");



class StatsController {
    stats;
    timer;
    videoFrameRenderCount;
    videoFrameDecodeCount;
    audioFrameRenderCount;
    audioFrameDecodeCount;
    videoPacketBytes;
    audioPacketBytes;
    bufferReceiveBytes;
    constructor(stats) {
        this.stats = stats;
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_0__["default"](this.onTimer.bind(this), 1000, 1000);
    }
    reset() {
        this.videoFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 144);
        this.videoFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 136);
        this.audioFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 64);
        this.audioFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 56);
        this.videoPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 96);
        this.audioPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 16);
        this.bufferReceiveBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 176);
    }
    start() {
        this.reset();
        this.timer.start();
    }
    stop() {
        this.timer.stop();
    }
    onTimer() {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 216, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 220, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 224, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 228, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 196, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 144) - this.videoFrameRenderCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 192, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 136) - this.videoFrameDecodeCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 208, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 64) - this.audioFrameRenderCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 204, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 56) - this.audioFrameDecodeCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 188, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 96) - this.videoPacketBytes & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 184, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 16) - this.audioPacketBytes & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 232, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](this.stats + 176) - this.bufferReceiveBytes & 0xffffffffn) >> 0));
        if (document.visibilityState === 'visible'
            && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.stats + 196) < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.stats + 200) * 0.5
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.stats + 228) > 6000 / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.stats + 200))) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.stats + 252, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.stats + 252) + 1);
        }
        this.reset();
    }
}


/***/ }),

/***/ "./src/avplayer/eventType.ts":
/*!***********************************!*\
  !*** ./src/avplayer/eventType.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   FIRST_VIDEO_RENDERED: () => (/* binding */ FIRST_VIDEO_RENDERED),
/* harmony export */   LOADED: () => (/* binding */ LOADED),
/* harmony export */   LOADING: () => (/* binding */ LOADING),
/* harmony export */   PAUSED: () => (/* binding */ PAUSED),
/* harmony export */   PLAYED: () => (/* binding */ PLAYED),
/* harmony export */   PLAYING: () => (/* binding */ PLAYING),
/* harmony export */   RESUME: () => (/* binding */ RESUME),
/* harmony export */   SEEKED: () => (/* binding */ SEEKED),
/* harmony export */   SEEKING: () => (/* binding */ SEEKING),
/* harmony export */   STOPPED: () => (/* binding */ STOPPED),
/* harmony export */   TIME: () => (/* binding */ TIME)
/* harmony export */ });
/* unused harmony exports TIMEOUT, ERROR, STATS, FIRST_AUDIO_RENDERED */
/*
 * libmedia AVPlayer eventType
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const LOADING = 'loading';
const LOADED = 'loaded';
const PLAYING = 'playing';
const PLAYED = 'played';
const PAUSED = 'paused';
const STOPPED = 'stopped';
const ENDED = 'ended';
const SEEKING = 'seeking';
const SEEKED = 'seeked';
const TIMEOUT = 'timeout';
const ERROR = 'error';
const STATS = 'stats';
const TIME = 'time';
const RESUME = 'resume';
const FIRST_AUDIO_RENDERED = 'firstAudioRendered';
const FIRST_VIDEO_RENDERED = 'firstVideoRendered';


/***/ }),

/***/ "./src/avplayer/function/createMessageChannel.ts":
/*!*******************************************************!*\
  !*** ./src/avplayer/function/createMessageChannel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMessageChannel)
/* harmony export */ });
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/FakeMessageChannel */ "./src/common/network/FakeMessageChannel.ts");
/*
 * libmedia create MessageChannel
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function createMessageChannel() {
    if (cheap_config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS && true) {
        return new MessageChannel();
    }
    return new common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"]();
}


/***/ }),

/***/ "./src/avplayer/function/getMediaSource.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/function/getMediaSource.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMediaSource)
/* harmony export */ });
/*
 * libmedia get MediaSource
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getMediaSource() {
    if (typeof MediaSource === 'function') {
        return MediaSource;
    }
    else if (typeof ManagedMediaSource === 'function') {
        return ManagedMediaSource;
    }
    else {
        throw new Error('not support mse');
    }
}


/***/ }),

/***/ "./src/avplayer/function/supportOffscreenCanvas.ts":
/*!*********************************************************!*\
  !*** ./src/avplayer/function/supportOffscreenCanvas.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ supportOffscreenCanvas)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia support OffscreenCanvas
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function supportOffscreenCanvas() {
    let result = common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].offscreenCanvas;
    // webgl with offscreencanvas only supported for Safari 17+ on Mac OS Sonoma
    if (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].mac && common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].safari && (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].version < '12' || common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].version < '17')) {
        result = false;
    }
    return result;
}


/***/ }),

/***/ "./src/avplayer/mse/MSEPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/mse/MSEPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MSEPipeline)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avpipeline/Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var avformat_mux__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avformat/mux */ "./src/avformat/mux.ts");
/* harmony import */ var avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avformat/formats/OMovFormat */ "./src/avformat/formats/OMovFormat.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var avrender_track_Track__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avrender/track/Track */ "./src/avrender/track/Track.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var common_io_SeekableWriteBufferQueue__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! common/io/SeekableWriteBufferQueue */ "./src/common/io/SeekableWriteBufferQueue.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_common__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! avutil/util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avformat_function_mktag__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! avformat/function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
var cheap__fileName__19 = "src/avplayer/mse/MSEPipeline.ts";







/*
 * libmedia MSEPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




























const BUFFER_MIN = 0.5;
const BUFFER_MAX = 1;
function checkExtradataChanged(old, oldSize, newer, newSize) {
    if (oldSize !== newSize) {
        return true;
    }
    let change = false;
    for (let i = 0; i < oldSize; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](old + i) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](newer + i)) {
            change = true;
            break;
        }
    }
    return change;
}
class MSEPipeline extends avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
    }
    async syncToKeyframe(task) {
        let firstIsKeyframe = true;
        if (task.video) {
            // 寻找下一个关键帧
            while (true) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket < 0) {
                    task.video.packetEnded = true;
                    task.video.backPacket = 0;
                    break;
                }
                // 跳过 pts 小于当前视频 pts 的音频 packet
                if (task.audio
                    && !task.audio.packetEnded
                    && (!task.audio.backPacket
                        || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.audio.backPacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)
                            < (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.video.backPacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q))) {
                    while (true) {
                        if (task.audio.backPacket > 0) {
                            task.avpacketPool.release(task.audio.backPacket);
                        }
                        task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                        if (task.audio.backPacket < 0) {
                            task.audio.packetEnded = true;
                            task.audio.backPacket = 0;
                            break;
                        }
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.audio.backPacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)
                            > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.video.backPacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)) {
                            break;
                        }
                    }
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.video.backPacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    break;
                }
                firstIsKeyframe = false;
                task.avpacketPool.release(task.video.backPacket);
            }
        }
        return firstIsKeyframe;
    }
    getSourceOpenHandler(task) {
        return async () => {
            await this.syncToKeyframe(task);
            const promises = [];
            if (task.audio) {
                task.audio.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.audio.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress]));
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.open(task.audio.oformatContext, {
                        paddingZero: true
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.writeHeader(task.audio.oformatContext);
                }
                promises.push(this.startMux(task.audio, task));
            }
            if (task.video) {
                task.video.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.video.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress]));
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.open(task.video.oformatContext, {
                        paddingZero: true
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.writeHeader(task.video.oformatContext);
                }
                promises.push(this.startMux(task.video, task));
            }
            await Promise.all(promises);
            let startAudioLoop = false;
            let startVideoLoop = false;
            if (task.audio) {
                task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                if (task.audio.backPacket > 0) {
                    startAudioLoop = true;
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket > 0) {
                        task.audio.frontBuffered = true;
                    }
                    else {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                    }
                }
                else {
                    task.audio.packetEnded = true;
                }
                if (!task.audio.enableRawMpeg) {
                    task.audio.oformatContext.ioWriter.flush();
                }
                task.audio.track.addBuffer(task.audio.bufferQueue.flush());
            }
            if (task.video) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket > 0) {
                    startVideoLoop = true;
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket > 0) {
                        task.video.frontBuffered = true;
                    }
                    else {
                        task.video.frontPacket = 0;
                        task.video.packetEnded = true;
                    }
                }
                else {
                    task.video.packetEnded = true;
                }
                if (!task.video.enableRawMpeg) {
                    task.video.oformatContext.ioWriter.flush();
                }
                task.video.track.addBuffer(task.video.bufferQueue.flush());
            }
            if (task.audio) {
                if (startAudioLoop) {
                    this.createLoop(task.audio, task);
                    task.audio.loop.start();
                }
                else {
                    task.audio.track.end();
                }
            }
            if (task.video) {
                if (startVideoLoop) {
                    this.createLoop(task.video, task);
                    task.video.loop.start();
                }
                else {
                    task.video.track.end();
                }
            }
            // 等待一定的缓冲
            await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_8__["default"](0.1);
            let min = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
            }
            // safari 播放某些视频会卡主，开始时间不是从 0 开始的 seek 到 min buffer 处
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_9__["default"].safari || min > 0.2) {
                task.controlIPCPort.notify('seek', {
                    time: min
                });
            }
        };
    }
    createSourceBuffer(mediaSource, codecpar) {
        let mimeType = '';
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            mimeType = (0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_10__["default"])(codecpar);
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            mimeType = (0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_11__["default"])(codecpar);
        }
        if (!mimeType) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('invalid stream', cheap__fileName__19, 343);
        }
        return mediaSource.addSourceBuffer(mimeType);
    }
    // TODO avpacket extradata 混入码流
    mixExtradata(avpacket, resource, extradata, extradataSize) {
        const codecId = resource.oformatContext.streams[0].codecpar.codecId;
        if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || codecId === 173 /* AVCodecID.AV_CODEC_ID_H265 */
            || codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        }
        const codecpar = resource.oformatContext.streams[0].codecpar;
        if (codecpar.extradata) {
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_13__.avFree)(codecpar.extradata);
        }
        codecpar.extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_13__.avMalloc)(extradataSize);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__.memcpy)(codecpar.extradata, extradata, extradataSize);
        codecpar.extradataSize = extradataSize;
    }
    async pullAVPacket(resource, task) {
        const pullQueue = resource.pullQueue;
        if (pullQueue.ended && !pullQueue.queue.length) {
            return -1048576 /* IOError.END */;
        }
        const avpacket = pullQueue.queue.length
            ? pullQueue.queue.shift()
            : (await resource.pullIPC.request('pull'));
        if (avpacket < 0) {
            pullQueue.ended = true;
            return -1048576 /* IOError.END */;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) < pullQueue.lastDTS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`got packet with dts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16)}, which is earlier then the last packet(${pullQueue.lastDTS})`, cheap__fileName__19, 386);
        }
        // 音频直接让 pts 等于 dts，dts 是递增的可以保证 mse 不会卡主（但声音可能会出现嗒嗒声）
        if (resource.type === 'audio') {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16));
        }
        // 某些视频关键帧的 pts 会倒退，这里纠正一下（特别是 m3u8 和 dash 切片转 mp4 flv 格式的视频容易出现）
        // TODO 若是非关键帧出现 pts 不对的情况可能需要其他手段去纠正，否则 mse 因为 duration 不对会卡主
        // 对于没有 B 帧的编码格式可以让 pts 等于 dts，当有 B 帧时可以根据帧类型得到一个最短 pts 递增序列来纠正 pts
        // 直播我们就不去纠正了，一般这种错误出现在老旧视频文件里面，直播不太可能出现，真出现了那也是直播流服务器的问题，应该去修改服务器的问题
        else if (resource.type === 'video' && !task.isLive) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) < pullQueue.lastPTS) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`got packet with pts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8)}, which is earlier then the last packet(${pullQueue.lastPTS}), try to fix it!`, cheap__fileName__19, 400);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 8, pullQueue.lastPTS + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS));
                    const next = await resource.pullIPC.request('pull');
                    if (next < 0) {
                        pullQueue.ended = true;
                    }
                    else {
                        pullQueue.queue.push(next);
                        // 判断下一个 gop pts 是否需要整体往后移
                        // 找到下一个最短递增序列的最小 pts
                        let nextMinPts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](next + 8);
                        // I 帧后面的的 P 帧 一定是下一个最短递增序列的最大 pts
                        const max = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](next + 8);
                        while (true) {
                            const next2 = await resource.pullIPC.request('pull');
                            if (next2 < 0) {
                                pullQueue.ended = true;
                                break;
                            }
                            pullQueue.queue.push(next2);
                            // 当前的 pts 比最大 pts 都大了说明当前的最短递增序列已结束
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](next2 + 8) > max) {
                                break;
                            }
                            nextMinPts = common_util_bigint__WEBPACK_IMPORTED_MODULE_16__.min(nextMinPts, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](next2 + 8));
                        }
                        if (nextMinPts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8)) {
                            pullQueue.diff = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS;
                        }
                    }
                }
                else {
                    pullQueue.diff = BigInt(0);
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) + pullQueue.diff);
            }
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) > pullQueue.lastPTS) {
            pullQueue.lastPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8);
        }
        pullQueue.lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16);
        // 使用 sampleRate 作为时间基
        // 这里需要根据当前已经处理的 samples count 调整时间基
        // 并将 avpacket 的时间基调整为采样率
        if (resource.type === 'audio' && pullQueue.useSampleRateTimeBase) {
            if (pullQueue.frameCount === avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT) {
                pullQueue.frameCount = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), resource.oformatContext.streams[0].timeBase);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            else {
                pullQueue.frameCount = pullQueue.frameCount + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](resource.codecpar + 116) >>> 0);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__.memcpy)(avpacket + 72, resource.oformatContext.streams[0].timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress], 8);
        }
        return avpacket;
    }
    writeAVPacket(avpacket, resource, flush = false) {
        if (resource.enableRawMpeg) {
            if (!resource.timestampOffsetUpdated) {
                const offset = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                resource.track.updateTimestampOffset((Number(offset & 0xffffffffn) >> 0) / 1000);
                resource.timestampOffsetUpdated = true;
            }
            resource.bufferQueue.push((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)).slice());
        }
        else {
            avformat_mux__WEBPACK_IMPORTED_MODULE_7__.writeAVPacket(resource.oformatContext, avpacket);
            if (flush) {
                resource.oformatContext.ioWriter.flush();
            }
        }
    }
    swap(resource, task) {
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
        }
        resource.backPacket = 0;
        if (resource.frontBuffered) {
            resource.backPacket = resource.frontPacket;
            resource.frontPacket = 0;
        }
        else {
            return false;
        }
        resource.frontBuffered = false;
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
        this.pullAVPacket(resource, task).then((packet) => {
            if (packet < 0) {
                resource.packetEnded = true;
                resource.frontPacket = 0;
                return;
            }
            const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])() - now;
            // 超过 5 毫秒认为是网卡了，对齐一下时间
            if (cost > 5) {
                resource.startTimestamp += BigInt(Math.floor(cost));
            }
            resource.frontPacket = packet;
            resource.frontBuffered = true;
            if (resource.seekSync) {
                resource.seekSync();
                resource.seekSync = null;
            }
            if (!resource.backPacket) {
                this.swap(resource, task);
            }
        });
        return true;
    }
    createLoop(resource, task) {
        resource.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_18__["default"](() => {
            const canPlayBufferTime = resource.track.getBufferedEnd() - (task.currentTime + ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])() - task.currentTimeNTP) / 1000);
            if (canPlayBufferTime > BUFFER_MAX * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                resource.loop.emptyTask();
                return;
            }
            if (!resource.backPacket) {
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_7__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                }
                else {
                    resource.loop.emptyTask();
                }
                return;
            }
            let avpacket = resource.backPacket;
            const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 212) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 212) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 200) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 112) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 200) * 1000)
                        : 0);
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.jitterBuffer)) {
                    this.setPlayRate(task.taskId, 1);
                }
            }
            const diff = dts * BigInt(100) / task.playRate + resource.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])()));
            if (diff <= 0 || canPlayBufferTime < BUFFER_MIN * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                if (resource.track.isPaused()) {
                    resource.track.enqueue();
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_19__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](extradata + 4));
                }
                this.writeAVPacket(avpacket, resource, true);
                resource.track.addBuffer(resource.bufferQueue.flush());
                const codecType = resource.oformatContext.streams[0].codecpar.codecType;
                if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 136) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                }
                else if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[17](task.stats + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 64) + BigInt(1));
                }
                if (task.playRate !== task.targetRate) {
                    resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])())) - (dts * BigInt(100) / task.targetRate);
                    task.playRate = task.targetRate;
                }
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_7__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                    return;
                }
                this.swap(resource, task);
            }
            else {
                resource.loop.emptyTask();
            }
        }, 0, 0);
    }
    async startMux(resource, task) {
        let startDTS = avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
        let startPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
        let lastDTS = BigInt(0);
        let avpacket;
        const timeBase = resource.oformatContext.streams[0].timeBase;
        if (resource.backPacket > 0) {
            startDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](resource.backPacket + 16);
            startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](resource.backPacket + 8);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](resource.backPacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(resource.backPacket, resource);
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        while (startDTS < BigInt(0) || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)((lastDTS - startDTS), timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) < task.cacheDuration) {
            avpacket = await this.pullAVPacket(resource, task);
            if (avpacket < 0) {
                resource.packetEnded = true;
                break;
            }
            lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16);
            if (startDTS < BigInt(0)) {
                startDTS = lastDTS;
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8);
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) < startPTS) {
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8);
            }
            if (task.video && task.video.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32)) {
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_19__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](extradata + 4));
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(avpacket, resource);
            task.avpacketPool.release(avpacket);
        }
        if (startPTS !== avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT && resource.startPTS <= BigInt(0)) {
            resource.startPTS = startPTS;
        }
        resource.pullQueue.diff = BigInt(0);
        task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
        task.currentTime = 0;
        resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])())) - (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(lastDTS, timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) * BigInt(100) / task.playRate;
    }
    resetResource(resource, task) {
        resource.bufferQueue.flush();
        const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_20__["default"]({
            fragmentMode: 1 /* FragmentMode.FRAME */,
            fragment: true,
            fastOpen: true,
            movMode: 0 /* MovMode.MP4 */,
            defaultBaseIsMoof: true
        });
        resource.oformatContext.oformat = oformat;
        const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_21__["default"]();
        track.onQuotaExceededError = () => {
            resource.startTimestamp -= BigInt(100);
        };
        track.onEnded = () => {
            if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                task.mediaSource.endOfStream();
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 718);
            }
        };
        resource.track = track;
        resource.packetEnded = false;
        resource.ended = false;
        resource.startTimestamp = BigInt(0);
        resource.frontBuffered = false;
        resource.seekSync = null;
        if (resource.loop) {
            resource.loop.destroy();
            resource.loop = null;
        }
        if (resource.frontPacket) {
            task.avpacketPool.release(resource.frontPacket);
            resource.frontPacket = 0;
        }
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        resource.pullQueue.ended = false;
        resource.pullQueue.index = 0;
        resource.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
        resource.pullQueue.lastPTS = BigInt(0);
        resource.pullQueue.lastDTS = BigInt(0);
        resource.pullQueue.diff = BigInt(0);
    }
    async addStream(taskId, streamIndex, codecpar, timeBase, startPTS, pullIPCPort) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_22__["default"](1048576);
            const oformatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_23__.createAVOFormatContext)();
            const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_20__["default"]({
                fragmentMode: 1 /* FragmentMode.FRAME */,
                fragment: true,
                fastOpen: true,
                movMode: 0 /* MovMode.MP4 */,
                defaultBaseIsMoof: true
            });
            const bufferQueue = new common_io_SeekableWriteBufferQueue__WEBPACK_IMPORTED_MODULE_24__["default"]();
            ioWriter.onFlush = (buffer) => {
                bufferQueue.push(buffer.slice());
                return 0;
            };
            ioWriter.onSeek = (pos) => {
                return bufferQueue.seek(pos) ? 0 : avutil_error__WEBPACK_IMPORTED_MODULE_25__.INVALID_OPERATE;
            };
            const stream = oformatContext.createStream();
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress], codecpar);
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                stream.codecpar.codecTag = (0,avformat_function_mktag__WEBPACK_IMPORTED_MODULE_27__["default"])('.mp3');
            }
            const useSampleRateTimeBase = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 116)
                && !task.isLive
                && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D2)(timeBase) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D)({ num: 1, den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 108) });
            // 点播 frameSize 有并且时间基精度小于采样率精度则使用 sampleRate 作为时间基
            // 避免一些 mp4 ts 转为 flv 因为时间基精度损失导致的 pts 抖动
            // 当 pts 抖动时 mse 播放会有颤音
            if (useSampleRateTimeBase) {
                stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 108);
                stream.timeBase.num = 1;
            }
            else {
                stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase + 4);
                stream.timeBase.num = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase);
            }
            oformatContext.oformat = oformat;
            oformatContext.ioWriter = ioWriter;
            const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_21__["default"]();
            const resource = {
                type: 'audio',
                codecpar,
                ioWriter,
                oformatContext,
                oformat,
                track,
                bufferQueue,
                streamIndex,
                pullIPC: new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_28__["default"](pullIPCPort),
                loop: null,
                frontPacket: 0,
                backPacket: 0,
                frontBuffered: false,
                startTimestamp: BigInt(0),
                packetEnded: false,
                ended: false,
                seekSync: null,
                startPTS,
                pullQueue: {
                    queue: [],
                    index: 0,
                    frameCount: avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT,
                    diff: BigInt(0),
                    lastPTS: BigInt(0),
                    lastDTS: BigInt(0),
                    ended: false,
                    useSampleRateTimeBase
                },
                enableRawMpeg: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_9__["default"].firefox,
                timestampOffsetUpdated: false
            };
            track.onQuotaExceededError = () => {
                resource.startTimestamp -= BigInt(100);
            };
            track.onEnded = () => {
                if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                    task.mediaSource.endOfStream();
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 851);
                }
            };
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                task.audio = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 108));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 140));
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                resource.type = 'video';
                task.video = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.stats + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.stats + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52));
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 76) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 80) > 8294400 && common_util_browser__WEBPACK_IMPORTED_MODULE_9__["default"].safari) {
                    task.cacheDuration = common_util_bigint__WEBPACK_IMPORTED_MODULE_16__.max(BigInt(3000), task.cacheDuration);
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 872);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has not played', cheap__fileName__19, 880);
            }
            task.pausing = true;
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
            task.audio?.loop.stop();
            task.video?.loop.stop();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 888);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task has not played', cheap__fileName__19, 896);
            }
            task.pausing = false;
            if (!task.seeking) {
                if (task.audio) {
                    task.audio.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])() - task.pauseTimestamp));
                    task.audio.loop.start();
                }
                if (task.video) {
                    task.video.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])() - task.pauseTimestamp));
                    task.video.loop.start();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 913);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            // 当前正在 pull frontFrame，等待其结束
            const promise = [];
            if (task.audio) {
                if (!task.audio.ended && !task.audio.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.audio.seekSync = resolve;
                    }));
                }
            }
            if (task.video) {
                if (!task.video.ended && !task.video.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.video.seekSync = resolve;
                    }));
                }
            }
            await Promise.all(promise);
            task.seeking = true;
            task.audio?.loop.stop();
            task.video?.loop.stop();
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.audio.oformatContext);
                }
                task.audio.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_9__["default"].safari) {
                    await new Promise((resolve) => {
                        task.audio.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.audio.track.reset();
                task.audio.packetEnded = false;
                task.audio.timestampOffsetUpdated = false;
                if (task.audio.backPacket) {
                    task.avpacketPool.release(task.audio.backPacket);
                    task.audio.backPacket = 0;
                }
                if (task.audio.frontPacket) {
                    task.avpacketPool.release(task.audio.frontPacket);
                    task.audio.frontPacket = 0;
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.audio.pullQueue.queue.length = 0;
                task.audio.pullQueue.ended = false;
                task.audio.pullQueue.index = 0;
                task.audio.pullQueue.lastPTS = BigInt(0);
                task.audio.pullQueue.lastDTS = BigInt(0);
                task.audio.pullQueue.diff = BigInt(0);
                task.audio.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.video.oformatContext);
                }
                task.video.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_9__["default"].safari) {
                    await new Promise((resolve) => {
                        task.video.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.video.track.reset();
                task.video.packetEnded = false;
                task.video.timestampOffsetUpdated = false;
                if (task.video.backPacket) {
                    task.avpacketPool.release(task.video.backPacket);
                    task.video.backPacket = 0;
                }
                if (task.video.frontPacket) {
                    task.avpacketPool.release(task.video.frontPacket);
                    task.video.frontPacket = 0;
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.video.pullQueue.queue.length = 0;
                task.video.pullQueue.ended = false;
                task.video.pullQueue.index = 0;
                task.video.pullQueue.diff = BigInt(0);
                task.video.pullQueue.lastPTS = BigInt(0);
                task.video.pullQueue.lastDTS = BigInt(0);
            }
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            let realTimestamp = timestamp;
            let firstIsKeyframe = await this.syncToKeyframe(task);
            if (task.audio && task.audio.backPacket > 0) {
                if (timestamp < BigInt(0)) {
                    realTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                this.writeAVPacket(task.audio.backPacket, task.audio);
                task.avpacketPool.release(task.audio.backPacket);
                task.audio.backPacket = 0;
            }
            if (task.video && task.video.backPacket > 0) {
                if (!firstIsKeyframe || timestamp < BigInt(0)) {
                    realTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                this.writeAVPacket(task.video.backPacket, task.video);
                task.avpacketPool.release(task.video.backPacket);
                task.video.backPacket = 0;
            }
            // 缓存一定的 buffer
            while (true) {
                if (task.audio && !task.audio.packetEnded) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                        if (!task.video || task.video.packetEnded) {
                            break;
                        }
                    }
                    if (realTimestamp < BigInt(0)) {
                        realTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q);
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                        this.writeAVPacket(task.audio.backPacket, task.audio);
                        if (!task.audio.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.audio.oformatContext);
                        }
                        task.audio.track.addBuffer(task.audio.bufferQueue.flush());
                        task.avpacketPool.release(task.audio.backPacket);
                        task.audio.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
                if (task.video && !task.video.packetEnded) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                        if (!task.audio || task.audio.packetEnded) {
                            break;
                        }
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_15__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                        this.writeAVPacket(task.video.backPacket, task.video);
                        if (!task.video.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.video.oformatContext);
                        }
                        task.video.track.addBuffer(task.video.bufferQueue.flush());
                        task.avpacketPool.release(task.video.backPacket);
                        task.video.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
            }
            const promises = [];
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.audio.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.audio.track.addBuffer(task.audio.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_7__.flush(task.video.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.video.track.addBuffer(task.video.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            await Promise.all(promises);
            if (task.audio && !task.audio.packetEnded) {
                if (task.audio.backPacket <= 0) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                    }
                }
                if (!task.audio.packetEnded) {
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket < 0) {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                        task.audio.frontBuffered = false;
                    }
                    else {
                        task.audio.packetEnded = false;
                        task.audio.frontBuffered = true;
                    }
                    task.audio.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])())) - (realTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(task.audio.startPTS, task.audio.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
                    }
                    else {
                        task.audio.loop.start();
                    }
                }
            }
            if (task.video && !task.video.packetEnded) {
                if (task.video.backPacket <= 0) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                    }
                }
                if (!task.video.packetEnded) {
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.frontBuffered = false;
                        task.video.frontPacket = 0;
                    }
                    else {
                        task.video.packetEnded = false;
                        task.video.frontBuffered = true;
                    }
                    task.video.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])())) - (realTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(task.video.startPTS, task.video.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
                    }
                    else {
                        task.video.loop.start();
                    }
                }
            }
            if (!firstIsKeyframe) {
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_8__["default"](0.5);
            }
            let min = 0;
            let max = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                    max = Math.min(task.audio.track.getBufferedEnd(), task.video.track.getBufferedEnd());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                    max = task.audio.track.getBufferedEnd();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
                max = task.video.track.getBufferedEnd();
            }
            let seekTime = (0,avutil_util_common__WEBPACK_IMPORTED_MODULE_29__.milliSecond2Second)(realTimestamp);
            if (!(seekTime >= min && seekTime <= max)) {
                seekTime = Math.abs(seekTime - min) > Math.abs(seekTime - max) ? max : min;
            }
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
            task.currentTime = seekTime;
            task.seeking = false;
            return seekTime;
        }
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 212) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 212) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 200) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 112) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 200) * 1000)
                        : 0);
                if (buffer && buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
            if (!task.enableJitterBuffer) {
                if (task.audio) {
                    task.audio.loop.resetInterval();
                }
                if (task.video) {
                    task.video.loop.resetInterval();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 1269);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                this.resetResource(task.audio, task);
            }
            if (task.video) {
                this.resetResource(task.video, task);
            }
            const mediaSource = new ((0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_30__["default"])())();
            mediaSource.onsourceopen = this.getSourceOpenHandler(task);
            task.mediaSource = mediaSource;
        }
    }
    async setCurrentTime(taskId, time) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                task.audio.track.removeBuffer(time);
            }
            if (task.video) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 84) > 0) {
                    task.video.track.setMediaBufferMax(Math.max(task.video.track.getMediaBufferMax(), Math.ceil(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 84) / 1000 * 1.5), 10));
                    task.video.track.removeBuffer(time);
                }
            }
            task.currentTime = time;
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_17__["default"])();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 1311);
        }
    }
    async getMediaSource(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.mediaSource.handle) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_31__.array(arguments[arguments.length - 1])) {
                    arguments[arguments.length - 1].push(task.mediaSource.handle);
                }
                return task.mediaSource.handle;
            }
            else {
                return task.mediaSource;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('task not found', cheap__fileName__19, 1329);
        }
    }
    createTask(options) {
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_28__["default"](options.controlPort);
        const mediaSource = new MediaSource() || new ManagedMediaSource();
        const task = {
            ...options,
            mediaSource,
            audio: null,
            video: null,
            playRate: BigInt(100),
            targetRate: BigInt(100),
            pauseTimestamp: 0,
            seeking: false,
            pausing: false,
            controlIPCPort,
            currentTime: 0,
            currentTimeNTP: 0,
            cacheDuration: BigInt(Math.floor(BUFFER_MIN * 1000)),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_32__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_33__["default"]), options.avpacketListMutex)
        };
        this.tasks.set(options.taskId, task);
        mediaSource.onsourceopen = this.getSourceOpenHandler(task);
        return 0;
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_25__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            if (task.audio) {
                if (task.audio.loop) {
                    task.audio.oformatContext.destroy();
                    task.audio.loop.destroy();
                }
                if (task.audio.pullIPC) {
                    task.audio.pullIPC.destroy();
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.audio.pullQueue.queue.length = 0;
                }
            }
            if (task.video) {
                if (task.video.loop) {
                    task.video.oformatContext.destroy();
                    task.video.loop.destroy();
                }
                if (task.video.pullIPC) {
                    task.video.pullIPC.destroy();
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.video.pullQueue.queue.length = 0;
                }
            }
            if (task.controlIPCPort) {
                task.controlIPCPort.destroy();
            }
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/Canvas2dRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/Canvas2dRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasImageRender)
/* harmony export */ });
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/*
 * libmedia Canvas2dRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class CanvasImageRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    context;
    paddingLeft;
    paddingTop;
    constructor(canvas, options) {
        super(canvas, options);
        this.paddingLeft = 0;
        this.paddingTop = 0;
    }
    async init() {
        this.context = this.canvas.getContext('2d');
    }
    clear() {
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.context.clearRect(0, 0, this.canvasWidth * this.options.devicePixelRatio, this.canvasHeight * this.options.devicePixelRatio);
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.context.drawImage(frame, this.paddingLeft, this.paddingTop, this.canvasWidth * this.options.devicePixelRatio - 2 * this.paddingLeft, this.canvasHeight * this.options.devicePixelRatio - 2 * this.paddingTop);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        let basePaddingLeft = 0;
        let basePaddingTop = 0;
        if (this.rotate === 90 || this.rotate === 270) {
            basePaddingTop = Math.floor((canvasHeight - canvasWidth) / 2);
            basePaddingLeft = Math.floor((canvasWidth - canvasHeight) / 2);
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.paddingTop = (Math.floor(paddingTop / 2 * canvasHeight) + basePaddingTop) * this.options.devicePixelRatio;
            this.paddingLeft = basePaddingLeft * this.options.devicePixelRatio;
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.paddingLeft = (Math.floor(paddingLeft / 2 * canvasWidth) + basePaddingLeft) * this.options.devicePixelRatio;
            this.paddingTop = basePaddingTop * this.options.devicePixelRatio;
        }
        if (this.context) {
            let flipX = 1;
            let flipY = 1;
            if (this.flipHorizontal) {
                flipX = -1;
            }
            if (this.flipVertical) {
                flipY = -1;
            }
            this.context.scale(flipX, flipY);
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.clear();
        this.rotate = angle;
        if (this.context) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.layout();
    }
    destroy() {
        this.context = null;
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame || frame instanceof ImageBitmap;
    }
}


/***/ }),

/***/ "./src/avrender/image/ImageRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/ImageRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageRender)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/*
 * libmedia ImageRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class ImageRender {
    canvas;
    options;
    textureWidth;
    videoWidth;
    videoHeight;
    canvasWidth;
    canvasHeight;
    rotate;
    renderMode;
    format;
    lost;
    destroyed;
    srcColorSpace;
    dstColorSpace;
    flipHorizontal;
    flipVertical;
    constructor(canvas, options) {
        this.canvas = canvas;
        this.options = options;
        this.canvasWidth = canvas.width;
        this.canvasHeight = canvas.height;
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.textureWidth = 0;
        this.rotate = 0;
        this.renderMode = options.renderMode;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.lost = false;
        this.destroyed = false;
        if (options.dstColorSpace) {
            this.dstColorSpace = options.dstColorSpace;
        }
        else {
            this.dstColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__["default"](1 /* AVColorSpace.AVCOL_SPC_BT709 */, 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */, 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */, 1 /* AVColorRange.AVCOL_RANGE_MPEG */);
        }
    }
    getRotateMatrix(angle) {
        angle = Math.PI * angle / 180;
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        return [
            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    }
    setRenderMode(mode) {
        if (this.renderMode !== mode) {
            this.renderMode = mode;
            this.layout();
            this.clear();
        }
    }
    enableHorizontalFlip(enable) {
        if (this.flipHorizontal !== enable) {
            this.flipHorizontal = enable;
            this.layout();
            this.clear();
        }
    }
    enableVerticalFlip(enable) {
        if (this.flipVertical !== enable) {
            this.flipVertical = enable;
            this.layout();
            this.clear();
        }
    }
    viewport(width, height) {
        const devicePixelRatio = this.options.devicePixelRatio;
        this.canvasWidth = width;
        this.canvasHeight = height;
        this.canvas.width = width * devicePixelRatio;
        this.canvas.height = height * devicePixelRatio;
        if (this.videoWidth && this.videoHeight) {
            this.layout();
        }
    }
    getVideoWidth() {
        return this.videoWidth;
    }
    getVideoHeight() {
        return this.videoHeight;
    }
    destroy() {
        this.canvas = null;
        this.destroyed = true;
    }
    setDstColorSpace(space) {
        this.dstColorSpace = space;
    }
    static isSupport(frame) {
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/WebGLRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src/avrender/image/WebGLRender.ts";
/*
 * libmedia WebGLRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGLRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    gl;
    // 顶点缓冲区
    VAO;
    program;
    vertex;
    webglContextLostTimer;
    onWebglContextLost;
    onWebglContextRestored;
    fragmentSource;
    vertexSource;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init() {
        this.gl = this.canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: this.options.preserveDrawingBuffer
        });
        if (!this.gl) {
            this.gl = this.canvas.getContext('webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            this.gl = this.canvas.getContext('experimental-webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('can not support webgl, got WebGLRenderingContext failed', cheap__fileName__0, 96);
        }
        this.VAO = this.gl.createBuffer();
        if (!this.VAO) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('create vao buffer failed', cheap__fileName__0, 101);
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VAO);
        this.gl.enable(this.gl.BLEND);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clearDepth(1.0);
        this.viewport(this.canvasWidth || this.canvas.width, this.canvasHeight || this.canvas.height);
        this.onWebglContextLost = (event) => {
            if (this.destroyed) {
                return;
            }
            this.webglContextLostTimer = setTimeout(() => {
                this.lost = true;
                this.webglContextLostTimer = null;
                common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error('webgl context lost', cheap__fileName__0, 118);
                if (this.options.onRenderContextLost) {
                    this.options.onRenderContextLost();
                }
            }, 3000);
        };
        this.onWebglContextRestored = (event) => {
            if (this.webglContextLostTimer) {
                clearTimeout(this.webglContextLostTimer);
                this.webglContextLostTimer = null;
            }
        };
        this.canvas.addEventListener('webglcontextlost', this.onWebglContextLost);
        this.canvas.addEventListener('webglcontextrestored', this.onWebglContextRestored);
    }
    viewport(width, height) {
        this.gl.viewport(0, 0, width * this.options.devicePixelRatio, height * this.options.devicePixelRatio);
        super.viewport(width, height);
    }
    useProgram() {
        this.program.link(this.gl);
        this.program.bind();
        this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
    }
    clear() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_2__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        if (this.gl) {
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertex), this.gl.STATIC_DRAW);
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        if (this.gl) {
            this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
        }
        this.layout();
        this.clear();
    }
    destroy() {
        if (this.program) {
            this.program.stop();
        }
        this.gl = null;
        this.VAO = null;
        this.vertex = null;
        if (this.onWebglContextLost) {
            this.canvas.removeEventListener('webglcontextlost', this.onWebglContextLost);
            this.onWebglContextLost = null;
        }
        if (this.onWebglContextRestored) {
            this.canvas.removeEventListener('webglcontextrestored', this.onWebglContextRestored);
            this.onWebglContextRestored = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV16Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGLYUV16Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV16Render)
/* harmony export */ });
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./struct/HdrMetadata */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgl/program/YUV16Program */ "./src/avrender/image/webgl/program/YUV16Program.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");













class WebGLYUV16Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    hdrMetadata;
    ext;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(_struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    async init() {
        await super.init();
        this.ext = this.gl.getExtension('EXT_texture_norm16');
        if (!this.ext) {
            throw Error('not support');
        }
    }
    generateFragmentSource(descriptor, colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        this.fragmentSource = `
      precision highp float;

      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      
      uniform float v_max;

      uniform float offset;
      uniform float multiplier;
      uniform float pq_tonemap_a;
      uniform float pq_tonemap_b;
      uniform float hlg_ootf_gamma_minus_one;
      uniform float hlg_dst_max_luminance_relative;
      uniform float nits_to_sdr_relative_factor;
      uniform float sdr_relative_to_nits_factor;

      ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
        float swap(float x) {
          int value = int(x * 65535.0);
          int low = value & 0xff;
          int high = (value >> 8) & 0xff;
          value = (low << 8) | high;
          return float(value) / v_max;
        }
      ` : ''}
      
      void main () {
      
        float y = texture2D(y_Sampler, v_color.xy).x;
        float u = texture2D(u_Sampler, v_color.xy).x;
        float v = texture2D(v_Sampler, v_color.xy).x;
        
        ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
          y = swap(y);
          u = swap(u);
          v = swap(v);
        ` : `
          y = y * 65535.0 / v_max;
          u = u * 65535.0 / v_max;
          v = v * 65535.0 / v_max;
        `}
        
        vec4 color = vec4(y, u, v, 1.0);

        if (color.a > 0.0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        const bytesPerPix = (descriptor.depth + 7) >>> 3;
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) / bytesPerPix) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80) !== this.format) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 248), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 240), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 244), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 236));
            const colorTransformOptions = {
                type: 0 /* GLType.kWebGL */,
                bitDepth: descriptor.depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(descriptor, colorTransformOptions);
            this.program = new _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_9__["default"](this.fragmentSource);
            this.useProgram();
            this.program.setMetaData(this.hdrMetadata);
            this.yTexture.setFormat(this.gl.RED);
            this.yTexture.setInternalformat(this.ext.R16_EXT);
            this.yTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.uTexture.setFormat(this.gl.RED);
            this.uTexture.setInternalformat(this.ext.R16_EXT);
            this.uTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.vTexture.setFormat(this.gl.RED);
            this.vTexture.setInternalformat(this.ext.R16_EXT);
            this.vTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            this.program.setMax(descriptor.max);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    destroy() {
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_11__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        super.destroy();
    }
    static isSupport(frame) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return ((info.depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV8Render.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGLYUV8Render.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/program/YUV8Program */ "./src/avrender/image/webgl/program/YUV8Program.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");

/*
 * libmedia WebGLYUV8Render
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







class WebGLYUV8Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource() {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_1__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 0 /* GLType.kWebGL */,
            outputRGB: true
        });
        this.fragmentSource = `
      precision highp float;
      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      void main () {
        vec4 color = vec4(texture2D(y_Sampler, v_color.xy).x, texture2D(u_Sampler, v_color.xy).x, texture2D(v_Sampler, v_color.xy).x, 1);
        ${steps.reduce((pre, current) => pre + current, '')}
        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 248), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 240), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 244), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 236));
            this.generateFragmentSource();
            this.program = new _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__["default"](this.fragmentSource);
            this.useProgram();
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    static isSupport(frame) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return ((info.depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUVRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/WebGLYUVRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUVRender)
/* harmony export */ });
/* harmony import */ var _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/texture/YUVTexture */ "./src/avrender/image/webgl/texture/YUVTexture.ts");
/* harmony import */ var _WebGLRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRender */ "./src/avrender/image/WebGLRender.ts");
/*
 * libmedia WebGLYUVRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGLYUVRender extends _WebGLRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    yTexture;
    uTexture;
    vTexture;
    constructor(canvas, options) {
        super(canvas, options);
    }
    useProgram() {
        super.useProgram();
        this.yTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl);
        this.yTexture.bind(0);
        this.yTexture.init();
        this.program.bindYTexture(0);
        this.uTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl);
        this.uTexture.bind(1);
        this.uTexture.init();
        this.program.bindUTexture(1);
        this.vTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl);
        this.vTexture.bind(2);
        this.vTexture.init();
        this.program.bindVTexture(2);
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
            this.yTexture = null;
        }
        if (this.uTexture) {
            this.uTexture.destroy();
            this.uTexture = null;
        }
        if (this.vTexture) {
            this.vTexture.destroy();
            this.vTexture = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUExternalRender.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/WebGPUExternalRender.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUExternalRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgpu/wgsl/fragment/external.wgsl */ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUExternalRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGPUExternalRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_1__["default"];
        this.fragmentSource = _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_2__["default"];
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
            this.generatePipeline();
        }
    }
    generateBindGroup() {
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    externalTexture: {}
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'filtering'
                    }
                }
            ]
        });
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const bindGroup = this.device.createBindGroup({
            layout: this.renderPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.rotateMatrixBuffer,
                        size: Float32Array.BYTES_PER_ELEMENT * 16
                    }
                },
                {
                    binding: 1,
                    resource: this.device.importExternalTexture({
                        source: frame
                    })
                },
                {
                    binding: 2,
                    resource: this.sampler
                }
            ]
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPassDescriptor = {
            colorAttachments: [
                {
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
        };
        const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPass.setPipeline(this.renderPipeline);
        renderPass.setBindGroup(0, bindGroup);
        renderPass.setVertexBuffer(0, this.vbo);
        renderPass.draw(4, 4, 0, 0);
        renderPass.end();
        this.device.queue.submit([commandEncoder.finish()]);
    }
    destroy() {
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURender.ts":
/*!********************************************!*\
  !*** ./src/avrender/image/WebGPURender.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src/avrender/image/WebGPURender.ts";
/*
 * libmedia WebGPURender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class WebGPURender extends _ImageRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    adapter;
    device;
    context;
    vsModule;
    fsModule;
    rotateMatrixBuffer;
    renderPipeline;
    rotateMatrix;
    vbo;
    sampler;
    vertex;
    fragmentSource;
    vertexSource;
    renderBundleEncoder;
    renderBundle;
    bindGroupLayout;
    bindGroup;
    pipelineLayout;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init(requiredFeatures) {
        this.adapter = await navigator.gpu.requestAdapter({
            powerPreference: this.options.powerPreference ?? 'high-performance'
        });
        const canRequiredFeatures = [];
        common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(requiredFeatures, (feature) => {
            if (this.adapter.features.has(feature)) {
                canRequiredFeatures.push(feature);
            }
        });
        this.device = await this.adapter.requestDevice({
            requiredFeatures: canRequiredFeatures.length ? canRequiredFeatures : undefined
        });
        this.device.lost.then(() => {
            if (this.destroyed) {
                return;
            }
            this.lost = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error('gpu device lost', cheap__fileName__0, 101);
            if (this.options?.onRenderContextLost) {
                this.options.onRenderContextLost();
            }
        });
        this.context = this.canvas.getContext('webgpu');
        if (!this.context) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('can not support webgpu, got GPUCanvasContext failed', cheap__fileName__0, 110);
        }
        this.context.configure({
            device: this.device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: 'premultiplied'
        });
        this.sampler = this.device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear'
        });
        this.vbo = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 28,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        this.rotateMatrixBuffer = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.setRotateMatrix(this.getRotateMatrix(0));
    }
    generatePipeline() {
        this.generateBindGroup();
        this.pipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.bindGroupLayout]
        });
        this.vsModule = this.device.createShaderModule({
            code: this.vertexSource
        });
        this.fsModule = this.device.createShaderModule({
            code: this.fragmentSource
        });
        this.renderPipeline = this.device.createRenderPipeline({
            layout: this.pipelineLayout,
            vertex: {
                module: this.vsModule,
                entryPoint: 'main',
                buffers: [
                    {
                        arrayStride: 28,
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: 'float32x3'
                            },
                            {
                                shaderLocation: 1,
                                offset: 12,
                                format: 'float32x4'
                            }
                        ]
                    }
                ]
            },
            fragment: {
                module: this.fsModule,
                entryPoint: 'main',
                targets: [{
                        format: navigator.gpu.getPreferredCanvasFormat()
                    }]
            },
            primitive: {
                topology: 'triangle-strip'
            }
        });
    }
    generateRenderBundleEncoder() {
        if (!this.renderPipeline) {
            return;
        }
        this.renderBundleEncoder = this.device.createRenderBundleEncoder({
            colorFormats: [navigator.gpu.getPreferredCanvasFormat()]
        });
        this.renderBundleEncoder.setPipeline(this.renderPipeline);
        this.renderBundleEncoder.setBindGroup(0, this.bindGroup);
        this.renderBundleEncoder.setVertexBuffer(0, this.vbo);
        this.renderBundleEncoder.draw(4, 4, 0, 0);
        this.renderBundle = this.renderBundleEncoder.finish();
    }
    setRotateMatrix(rotateMatrix) {
        this.rotateMatrix = rotateMatrix;
        const buffer = new Float32Array(this.rotateMatrix);
        this.device.queue.writeBuffer(this.rotateMatrixBuffer, 0, 
        // 传递 ArrayBuffer
        buffer.buffer, 
        // 从哪里开始
        buffer.byteOffset, 
        // 取多长
        buffer.byteLength);
    }
    setVertices() {
        const buffer = new Float32Array(this.vertex);
        this.device.queue.writeBuffer(this.vbo, 0, 
        // 传递 ArrayBuffer
        buffer.buffer, 
        // 从哪里开始
        buffer.byteOffset, 
        // 取多长
        buffer.byteLength);
    }
    clear() {
        this.context.getCurrentTexture().destroy();
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_3__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        this.setVertices();
    }
    viewport(width, height) {
        super.viewport(width, height);
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        this.setRotateMatrix(this.getRotateMatrix(angle));
        this.layout();
        this.clear();
    }
    destroy() {
        this.sampler = null;
        if (this.vbo) {
            this.vbo.destroy();
        }
        if (this.rotateMatrixBuffer) {
            this.rotateMatrixBuffer.destroy();
        }
        this.bindGroupLayout = null;
        this.bindGroup = null;
        this.pipelineLayout = null;
        this.renderBundle = null;
        this.renderBundleEncoder = null;
        this.fsModule = null;
        this.vsModule = null;
        this.renderPipeline = null;
        this.rotateMatrix = null;
        this.vertex = null;
        this.context = null;
        this.options = null;
        this.destroyed = true;
        if (this.device) {
            this.device.destroy();
            this.device = null;
        }
        if (this.adapter) {
            this.adapter = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV16Render.ts":
/*!*************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV16Render.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV16Render)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatLE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatBE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./struct/HdrMetadata */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");















class WebGPUYUV16Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    metaYBuffer;
    metaUBuffer;
    metaVBuffer;
    computeBindGroupLayout;
    computeBindGroupY;
    computeBindGroupU;
    computeBindGroupV;
    computePipelineLayout;
    computePipeline;
    inputYTexture;
    inputUTexture;
    inputVTexture;
    computeModule;
    uint2Float;
    hdrMetadata;
    hdrMetadataBuffer;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(_struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    generateFragmentSource(colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        this.fragmentSource = `
      struct HdrMetadata {
        offset: f32,
        multiplier: f32,
        pqTonemapA: f32,
        pqTonemapB: f32,
        hlgOOTFGammaMinusOne: f32,
        hlgDstMaxLuminanceRelative: f32,
        nitsToSdrRelativeFactor: f32,
        sdrRelativeToNitsFactor: f32
      };

      @group(0) @binding(1) var yTexture: texture_2d<f32>;
      @group(0) @binding(2) var uTexture: texture_2d<f32>;
      @group(0) @binding(3) var vTexture: texture_2d<f32>;
      @group(0) @binding(4) var s: sampler;
      @group(0) @binding(5) var<uniform> hdrMetadata: HdrMetadata;

      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {

        let offset = hdrMetadata.offset;
        let multiplier = hdrMetadata.multiplier;
        let pq_tonemap_a = hdrMetadata.pqTonemapA;
        let pq_tonemap_b = hdrMetadata.pqTonemapB;
        let hlg_ootf_gamma_minus_one = hdrMetadata.hlgOOTFGammaMinusOne;
        let hlg_dst_max_luminance_relative = hdrMetadata.hlgDstMaxLuminanceRelative;
        let nits_to_sdr_relative_factor = hdrMetadata.nitsToSdrRelativeFactor;
        let sdr_relative_to_nits_factor = hdrMetadata.sdrRelativeToNitsFactor;

        var color = vec4(textureSample(yTexture, s, in_texcoord.xy).x, textureSample(uTexture, s, in_texcoord.xy).x, textureSample(vTexture, s, in_texcoord.xy).x, 1.0);

        if (color.a > 0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        return color;
      }
    `;
    }
    async init() {
        await super.init(['float32-filterable']);
        this.metaYBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaUBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaVBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.hdrMetadataBuffer = this.device.createBuffer({
            size: (47) & ~15,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    }
    generateComputeBindGroup() {
        this.computeBindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        sampleType: 'uint'
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    storageTexture: {
                        format: 'r32float'
                    }
                }
            ]
        });
        this.computeBindGroupY = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaYBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputYTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.yTexture.createView()
                }
            ]
        });
        this.computeBindGroupU = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaUBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputUTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.uTexture.createView()
                }
            ]
        });
        this.computeBindGroupV = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaVBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputVTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.vTexture.createView()
                }
            ]
        });
    }
    generateComputePipeline() {
        this.generateComputeBindGroup();
        this.computePipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.computeBindGroupLayout]
        });
        this.computeModule = this.device.createShaderModule({
            code: this.uint2Float
        });
        this.computePipeline = this.device.createComputePipeline({
            layout: this.computePipelineLayout,
            compute: {
                module: this.computeModule,
                entryPoint: 'main'
            }
        });
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'filtering'
                    }
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: 'uniform'
                    }
                }
            ]
        });
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.rotateMatrixBuffer,
                        size: this.rotateMatrixBuffer.size
                    }
                },
                {
                    binding: 1,
                    resource: this.yTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.uTexture.createView()
                },
                {
                    binding: 3,
                    resource: this.vTexture.createView()
                },
                {
                    binding: 4,
                    resource: this.sampler
                },
                {
                    binding: 5,
                    resource: {
                        buffer: this.hdrMetadataBuffer,
                        size: this.hdrMetadataBuffer.size
                    }
                }
            ]
        });
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) >>> 1) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80) !== this.format) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            if (this.inputYTexture) {
                this.inputYTexture.destroy();
            }
            if (this.inputUTexture) {
                this.inputUTexture.destroy();
            }
            if (this.inputVTexture) {
                this.inputVTexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            this.vTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            this.inputYTexture = this.device.createTexture({
                size: [this.yTexture.width, this.yTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            this.inputUTexture = this.device.createTexture({
                size: [this.uTexture.width, this.uTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            this.inputVTexture = this.device.createTexture({
                size: [this.vTexture.width, this.vTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            const yBuffer = new Uint32Array([descriptor.max, this.inputYTexture.width, this.inputYTexture.height]);
            this.device.queue.writeBuffer(this.metaYBuffer, 0, yBuffer.buffer, yBuffer.byteOffset, yBuffer.byteLength);
            const uBuffer = new Uint32Array([descriptor.max, this.inputUTexture.width, this.inputUTexture.height]);
            this.device.queue.writeBuffer(this.metaUBuffer, 0, uBuffer.buffer, uBuffer.byteOffset, uBuffer.byteLength);
            const vBuffer = new Uint32Array([descriptor.max, this.inputVTexture.width, this.inputVTexture.height]);
            this.device.queue.writeBuffer(this.metaVBuffer, 0, vBuffer.buffer, vBuffer.byteOffset, vBuffer.byteLength);
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 248), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 240), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 244), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 236));
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80);
            const colorTransformOptions = {
                type: 1 /* GLType.kWebGPU */,
                bitDepth: descriptor.depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(colorTransformOptions);
            this.uint2Float = (descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_9__["default"] : _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_10__["default"];
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
            this.generateComputePipeline();
            const hdrBuffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__.mapUint8Array)(this.hdrMetadata[cheap_symbol__WEBPACK_IMPORTED_MODULE_12__.symbolStructAddress], 32).slice();
            this.device.queue.writeBuffer(this.hdrMetadataBuffer, 0, hdrBuffer.buffer, hdrBuffer.byteOffset, hdrBuffer.byteLength);
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const commandEncoder = this.device.createCommandEncoder();
        const computePass = commandEncoder.beginComputePass({});
        computePass.setPipeline(this.computePipeline);
        computePass.setBindGroup(0, this.computeBindGroupY);
        this.device.queue.writeTexture({
            texture: this.inputYTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame), (this.inputYTexture.width * this.inputYTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputYTexture.width << 1,
            rowsPerImage: this.inputYTexture.height
        }, {
            width: this.inputYTexture.width,
            height: this.inputYTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputYTexture.width + 7) >>> 3, (this.inputYTexture.height + 7) >>> 3);
        computePass.setBindGroup(0, this.computeBindGroupU);
        this.device.queue.writeTexture({
            texture: this.inputUTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame + 4), (this.inputUTexture.width * this.inputUTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputUTexture.width << 1,
            rowsPerImage: this.inputUTexture.height
        }, {
            width: this.inputUTexture.width,
            height: this.inputUTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputUTexture.width + 7) >>> 3, (this.inputUTexture.height + 7) >>> 3);
        computePass.setBindGroup(0, this.computeBindGroupV);
        this.device.queue.writeTexture({
            texture: this.inputVTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](frame + 8), (this.inputVTexture.width * this.inputVTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputVTexture.width << 1,
            rowsPerImage: this.inputVTexture.height
        }, {
            width: this.inputVTexture.width,
            height: this.inputVTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputVTexture.width + 7) >>> 3, (this.inputVTexture.height + 7) >>> 3);
        computePass.end();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    destroy() {
        if (this.inputYTexture) {
            this.inputYTexture.destroy();
            this.inputYTexture = null;
        }
        if (this.inputUTexture) {
            this.inputUTexture.destroy();
            this.inputUTexture = null;
        }
        if (this.inputVTexture) {
            this.inputVTexture.destroy();
            this.inputVTexture = null;
        }
        if (this.metaYBuffer) {
            this.metaYBuffer.destroy();
            this.metaYBuffer = null;
        }
        if (this.metaUBuffer) {
            this.metaUBuffer.destroy();
            this.metaUBuffer = null;
        }
        if (this.metaVBuffer) {
            this.metaVBuffer.destroy();
            this.metaVBuffer = null;
        }
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_13__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        this.computeModule = null;
        this.computeBindGroupY = null;
        this.computeBindGroupU = null;
        this.computeBindGroupV = null;
        this.computeBindGroupLayout = null;
        this.computePipelineLayout = null;
        this.computePipeline = null;
        super.destroy();
    }
    static isSupport(frame) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return ((info.depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV8Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV8Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");







class WebGPUYUV8Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource() {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_1__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 1 /* GLType.kWebGPU */,
            outputRGB: true
        });
        this.fragmentSource = `
      @group(0) @binding(1) var yTexture: texture_2d<f32>;
      @group(0) @binding(2) var uTexture: texture_2d<f32>;
      @group(0) @binding(3) var vTexture: texture_2d<f32>;
      @group(0) @binding(4) var s: sampler;
      
      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {
        var color = vec4(textureSample(yTexture, s, in_texcoord.xy).x, textureSample(uTexture, s, in_texcoord.xy).x, textureSample(vTexture, s, in_texcoord.xy).x, 1.0);
        ${steps.reduce((pre, current) => pre + current, '')}
        return color;
      }
    `;
    }
    checkFrame(frame) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.vTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 248), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 240), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 244), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 236));
            this.generateFragmentSource();
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80);
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.device.queue.writeTexture({
            texture: this.yTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height), {
            offset: 0,
            bytesPerRow: this.yTexture.width,
            rowsPerImage: this.yTexture.height
        }, {
            width: this.yTexture.width,
            height: this.yTexture.height,
            depthOrArrayLayers: 1
        });
        this.device.queue.writeTexture({
            texture: this.uTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height), {
            offset: 0,
            bytesPerRow: this.uTexture.width,
            rowsPerImage: this.uTexture.height
        }, {
            width: this.uTexture.width,
            height: this.uTexture.height,
            depthOrArrayLayers: 1
        });
        this.device.queue.writeTexture({
            texture: this.vTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height), {
            offset: 0,
            bytesPerRow: this.vTexture.width,
            rowsPerImage: this.vTexture.height
        }, {
            width: this.vTexture.width,
            height: this.vTexture.height,
            depthOrArrayLayers: 1
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    static isSupport(frame) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.number(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return ((info.depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUVRender.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGPUYUVRender.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUVRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUYUVRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGPUYUVRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    yTexture;
    uTexture;
    vTexture;
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_1__["default"];
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'float'
                    }
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'filtering'
                    }
                }
            ]
        });
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.rotateMatrixBuffer,
                        size: Float32Array.BYTES_PER_ELEMENT * 16
                    }
                },
                {
                    binding: 1,
                    resource: this.yTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.uTexture.createView()
                },
                {
                    binding: 3,
                    resource: this.vTexture.createView()
                },
                {
                    binding: 4,
                    resource: this.sampler
                }
            ]
        });
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
        }
        if (this.uTexture) {
            this.uTexture.destroy();
        }
        if (this.vTexture) {
            this.vTexture.destroy();
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/ColorSpace.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/colorSpace/ColorSpace.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorSpace)
/* harmony export */ });
/* harmony import */ var common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var _transferFns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transferFns */ "./src/avrender/image/colorSpace/transferFns.ts");
/* harmony import */ var _primaries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primaries */ "./src/avrender/image/colorSpace/primaries.ts");
/*
 * libmedia ColorSpace
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class ColorSpace {
    matrixId;
    primaryId;
    transferId;
    rangeId;
    constructor(matrixId, primaryId, transferId, rangeId) {
        this.matrixId = matrixId;
        this.primaryId = primaryId;
        this.transferId = transferId;
        this.rangeId = rangeId;
    }
    getMatrixId() {
        return this.matrixId;
    }
    getPrimaryId() {
        return this.primaryId;
    }
    getTransferId() {
        return this.transferId;
    }
    getRangeId() {
        return this.rangeId;
    }
    isWide() {
        if (this.primaryId === 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */
            || this.primaryId === 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */
            || this.primaryId === 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */) {
            return true;
        }
        return false;
    }
    isHDR() {
        return this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */;
    }
    isToneMappedByDefault() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    isAffectedBySDRWhiteLevel() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    fullRangeEncodedValues() {
        return this.transferId === 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */
            || this.transferId === 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */;
    }
    getTransferMatrix(bitDepth) {
        const chroma05 = (1 << (bitDepth - 1)) / ((1 << bitDepth) - 1);
        let Kr = 0;
        let Kb = 0;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */:
                Kr = 0.2126;
                Kb = 0.0722;
                break;
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
                Kr = 0.30;
                Kb = 0.11;
                break;
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
                Kr = 0.299;
                Kb = 0.114;
                break;
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
                Kr = 0.212;
                Kb = 0.087;
                break;
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */: {
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.25, 0.5, 0.25, 0.0,
                    // Cg
                    -0.25, 0.5, -0.25, chroma05,
                    // Co
                    0.5, 0.0, -0.5, chroma05,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            // BT2020_CL is a special case.
            // Basically we return a matrix that transforms RYB values
            // to YUV values. (Note that the green component have been replaced
            // with the luminance.)
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */: {
                Kr = 0.2627;
                Kb = 0.0593;
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // R
                    1.0, 0.0, 0.0, 0.0,
                    // Y
                    Kr, 1.0 - Kr - Kb, Kb, 0.0,
                    // B
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
                Kr = 0.2627;
                Kb = 0.0593;
                break;
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.0, 1.0, 0.0, 0.0,
                    // DX or DZ
                    0.0, -0.5,
                    0.493283,
                    0.5,
                    // DZ or DX
                    0.5, -0.991902 / 2.0, 0.0, 0.5,
                    0.0, 0.0, 0.0, 1.0,
                ]);
        }
        let Kg = 1.0 - Kr - Kb;
        let um = 0.5 / (1.0 - Kb);
        let vm = 0.5 / (1.0 - Kr);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            // Y
            Kr, Kg, Kb, 0.0,
            // U
            um * -Kr, um * -Kg, um * (1.0 - Kb), 0.5,
            // V
            vm * (1.0 - Kr), vm * -Kg, vm * -Kb, 0.5,
            0.0, 0.0, 0.0, 1.0,
        ]);
    }
    getRangeAdjustMatrix(bitDepth) {
        switch (this.rangeId) {
            case 2 /* AVColorRange.AVCOL_RANGE_JPEG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorRange.AVCOL_RANGE_MPEG */:
                break;
        }
        // See ITU-T H.273 (2016), Section 8.3. The following is derived from
        // Equations 20-31.
        const shift = bitDepth - 8;
        const ay = 219 << shift;
        const c = (1 << bitDepth) - 1;
        const scaleY = c / ay;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleY, scaleY]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, -16.0 / 219.0, -16.0 / 219.0]));
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */:
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */: {
                const aUV = 224 << shift;
                const scaleUV = c / aUV;
                const translateUV = (aUV - c) / (2.0 * aUV);
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleUV, scaleUV]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, translateUV, translateUV]));
            }
        }
        return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    getTransferFunction_() {
        switch (this.transferId) {
            case 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnLinear;
            case 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemM;
            case 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemBG;
            case 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPTEST240;
            case 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */:
            case 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */:
            case 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */:
            case 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSRGB;
            case 17 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPETST428_1;
            case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
            case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
            case 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */:
                return null;
        }
    }
    getTransferFunction(sdrWhiteLevel) {
        switch (this.transferId) {
            default:
                return this.getTransferFunction_();
        }
    }
    getInverseTransferFunction(sdrWhiteLevel) {
        const fn = this.getTransferFunction(sdrWhiteLevel);
        if (fn) {
            const fnInv = {
                a: 0,
                b: 0,
                c: 0,
                d: 0,
                e: 0,
                f: 0,
                g: 0
            };
            if (fn.a > 0 && fn.g > 0) {
                const aToG = Math.pow(fn.a, fn.g);
                fnInv.a = 1.0 / aToG;
                fnInv.b = -fn.e / aToG;
                fnInv.g = 1.0 / fn.g;
            }
            fnInv.d = fn.c * fn.d + fn.f;
            fnInv.e = -fn.b / fn.a;
            if (fn.c != 0) {
                fnInv.c = 1.0 / fn.c;
                fnInv.f = -fn.f / fn.c;
            }
            return fnInv;
        }
    }
    hasExtendedSkTransferFn() {
        return this.matrixId === 0 /* AVColorSpace.AVCOL_SPC_RGB */;
    }
    isValid() {
        return this.matrixId !== 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */
            && this.primaryId !== 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */
            && this.transferId !== 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */
            && this.rangeId !== 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    }
    getColorSpacePrimaries() {
        const pri = _primaries__WEBPACK_IMPORTED_MODULE_3__.Invalid;
        switch (this.primaryId) {
            case 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec709;
            case 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemM;
            case 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemBG;
            case 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_240;
            case 8 /* AVColorPrimaries.AVCOL_PRI_FILM */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.GenericFilm;
            case 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec2020;
            case 10 /* AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_428_1;
            case 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_RP_431_2;
            case 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_EG_432_1;
        }
        return pri;
    }
    getPrimaryMatrix() {
        const pri = this.getColorSpacePrimaries();
        const toXYZD50 = _primaries__WEBPACK_IMPORTED_MODULE_3__.primariesToXYZD50(pri);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            toXYZD50.rc(0, 0), toXYZD50.rc(0, 1), toXYZD50.rc(0, 2), 0,
            toXYZD50.rc(1, 0), toXYZD50.rc(1, 1), toXYZD50.rc(1, 2), 0,
            toXYZD50.rc(2, 0), toXYZD50.rc(2, 1), toXYZD50.rc(2, 2), 0,
            0, 0, 0, 1
        ]);
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/primaries.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/colorSpace/primaries.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenericFilm: () => (/* binding */ GenericFilm),
/* harmony export */   Invalid: () => (/* binding */ Invalid),
/* harmony export */   Rec2020: () => (/* binding */ Rec2020),
/* harmony export */   Rec470SystemBG: () => (/* binding */ Rec470SystemBG),
/* harmony export */   Rec470SystemM: () => (/* binding */ Rec470SystemM),
/* harmony export */   Rec709: () => (/* binding */ Rec709),
/* harmony export */   SMPTE_EG_432_1: () => (/* binding */ SMPTE_EG_432_1),
/* harmony export */   SMPTE_RP_431_2: () => (/* binding */ SMPTE_RP_431_2),
/* harmony export */   SMPTE_ST_240: () => (/* binding */ SMPTE_ST_240),
/* harmony export */   SMPTE_ST_428_1: () => (/* binding */ SMPTE_ST_428_1),
/* harmony export */   primariesToXYZD50: () => (/* binding */ primariesToXYZD50)
/* harmony export */ });
/* unused harmony exports Rec601, ITU_T_H273_VALUE22, SRGB, P3, A98RGB, ProPhotoRGB, XYZD50, XYZD65, AppleGenericRGB, WideGamutColorSpin */
/* harmony import */ var common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var common_math_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/math/matrix */ "./src/common/math/matrix.ts");
/* harmony import */ var common_math_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/math/vector */ "./src/common/math/vector.ts");
/*
 * libmedia primary defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




// Rec. ITU-R BT.709-6, value 1.
const Rec709 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06, 0.3127, 0.329];
// Rec. ITU-R BT.470-6 System M (historical), value 4.
const Rec470SystemM = [0.67, 0.33, 0.21, 0.71, 0.14, 0.08, 0.31, 0.316];
// Rec. ITU-R BT.470-6 System B, G (historical), value 5.
const Rec470SystemBG = [0.64, 0.33, 0.29, 0.60, 0.15, 0.06, 0.3127, 0.3290];
// Rec. ITU-R BT.601-7 525, value 6.
const Rec601 = [0.630, 0.340, 0.310, 0.595, 0.155, 0.070, 0.3127, 0.3290];
// SMPTE ST 240, value 7 (functionally the same as value 6).
const SMPTE_ST_240 = Rec601;
// Generic film (colour filters using Illuminant C), value 8.
const GenericFilm = [0.681, 0.319, 0.243, 0.692, 0.145, 0.049, 0.310, 0.316];
// Rec. ITU-R BT.2020-2, value 9.
const Rec2020 = [0.708, 0.292, 0.170, 0.797, 0.131, 0.046, 0.3127, 0.3290];
// SMPTE ST 428-1, value 10.
const SMPTE_ST_428_1 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3333333333333333, 0.3333333333333333];
// SMPTE RP 431-2, value 11.
const SMPTE_RP_431_2 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.314, 0.351];
// SMPTE EG 432-1, value 12.
const SMPTE_EG_432_1 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.3127, 0.3290];
// No corresponding industry specification identified, value 22.
// This is sometimes referred to as EBU 3213-E, but that document doesn't
// specify these values.
const ITU_T_H273_VALUE22 = [0.630, 0.340, 0.295, 0.605, 0.155, 0.077, 0.3127, 0.3290];
// CSS Color Level 4 predefined and xyz color spaces.
// 'srgb'
const SRGB = Rec709;
// 'display-p3' (and also 'p3' as a color gamut).
const P3 = SMPTE_EG_432_1;
// 'a98-rgb'
const A98RGB = [0.64, 0.33, 0.21, 0.71, 0.15, 0.06, 0.3127, 0.3290];
// 'prophoto-rgb'
const ProPhotoRGB = [0.7347, 0.2653, 0.1596, 0.8404, 0.0366, 0.0001, 0.34567, 0.35850];
// 'rec2020' (as both a predefined color space and color gamut).
// The value kRec2020 is already defined above.
// 'xyzd50'
const XYZD50 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.34567, 0.35850];
// 'xyz' and 'xyzd65'
const XYZD65 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3127, 0.3290];
// //////////////////////////////////////////////////////////////////////////////
// Additional helper color primaries.
// Invalid primaries, initialized to zero.
const Invalid = [0, 0, 0, 0, 0, 0, 0, 0];
// The GenericRGB space on macOS.
const AppleGenericRGB = [0.63002, 0.34000, 0.29505, 0.60498, 0.15501, 0.07701, 0.3127, 0.3290];
// Primaries where the colors are rotated and the gamut is huge. Good for
// testing.
const WideGamutColorSpin = [0.01, 0.98, 0.01, 0.01, 0.98, 0.01, 0.3127, 0.3290];
function adaptToXYZ50(wx, wy) {
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([wx / wy, 1, (1 - wx - wy) / wy]);
    const wXYZD50 = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([0.96422, 1.0, 0.82521]);
    const xyzToLms = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__["default"].RowMajor([
        0.8951, 0.2664, -0.1614,
        -0.7502, 1.7135, 0.0367,
        0.0389, -0.0685, 1.0296
    ]);
    const lmsToXyz = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__["default"].RowMajor([
        0.9869929, -0.1470543, 0.1599627,
        0.4323053, 0.5183603, 0.0492912,
        -0.0085287, 0.0400428, 0.9684867
    ]);
    const srcCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_2__.mvMul)(xyzToLms, wXYZ);
    const dstCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_2__.mvMul)(xyzToLms, wXYZD50);
    let toXYZD50 = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__["default"]([
        dstCone.x / srcCone.x, 0, 0,
        0, dstCone.y / srcCone.y, 0,
        0, 0, dstCone.z / srcCone.z
    ]);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_3__.concat3x3)(toXYZD50, xyzToLms);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_3__.concat3x3)(lmsToXyz, toXYZD50);
    return toXYZD50;
}
function primariesToXYZD50(pri) {
    const matrix3 = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__["default"].RowMajor([
        pri[0], pri[2], pri[4],
        pri[1], pri[3], pri[5],
        1 - pri[0] - pri[1], 1 - pri[2] - pri[3], 1 - pri[4] - pri[5]
    ]);
    const matrix3Inv = matrix3.copy().invert();
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([pri[6] / pri[7], 1, (1 - pri[6] - pri[7]) / pri[7]]);
    const XYZ = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_2__.mvMul)(matrix3Inv, wXYZ);
    let toXYZ = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_1__["default"]([
        XYZ.x, 0, 0,
        0, XYZ.y, 0,
        0, 0, XYZ.z
    ]);
    toXYZ = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_3__.concat3x3)(matrix3, toXYZ);
    const dxToD50 = adaptToXYZ50(pri[6], pri[7]);
    return (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_3__.concat3x3)(dxToD50, toXYZ);
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/transferFns.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorSpace/transferFns.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransferFn470SystemBG: () => (/* binding */ TransferFn470SystemBG),
/* harmony export */   TransferFn470SystemM: () => (/* binding */ TransferFn470SystemM),
/* harmony export */   TransferFnLinear: () => (/* binding */ TransferFnLinear),
/* harmony export */   TransferFnSMPETST428_1: () => (/* binding */ TransferFnSMPETST428_1),
/* harmony export */   TransferFnSMPTEST240: () => (/* binding */ TransferFnSMPTEST240),
/* harmony export */   TransferFnSRGB: () => (/* binding */ TransferFnSRGB)
/* harmony export */ });
/* unused harmony exports TransferFnRec709, TransferFn2Dot2, TransferFnRec2020, TransferFnPQ, TransferFnHLG */
/*
 * libmedia transfer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const TransferFnRec709 = {
    g: 2.222222222222, a: 0.909672415686, b: 0.090327584314, c: 0.222222222222, d: 0.081242858299, e: 0.0, f: 0.0
};
const TransferFn470SystemM = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn470SystemBG = {
    g: 2.8, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSMPTEST240 = {
    g: 2.222222222222, a: 0.899626676224, b: 0.100373323776, c: 0.25, d: 0.091286342118, e: 0.0, f: 0.0
};
const TransferFnLinear = {
    g: 1.0, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSRGB = {
    g: 2.4, a: 0.9478672985781991, b: 0.05213270142180095, c: 0.07739938080495357, d: 0.04045, e: 0.0, f: 0.0
};
// eslint-disable-next-line camelcase
const TransferFnSMPETST428_1 = {
    g: 2.6, a: 1.034080527699, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn2Dot2 = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnRec2020 = {
    g: 2.22222, a: 0.909672, b: 0.0903276, c: 0.222222, d: 0.0812429, e: 0.0, f: 0.0
};
const TransferFnPQ = {
    g: -2.0, a: -107 / 128.0, b: 1.0, c: 0.012683313515655966, d: 18.8515625, e: -2392 / 128, f: 6.277394636015326
};
const TransferFnHLG = {
    g: -3.0, a: 2.0, b: 2.0, c: 5.591816309728916, d: 0.28466892, e: 0.55991073, f: 0.0
};


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeHLGToneMapConstants: () => (/* binding */ computeHLGToneMapConstants),
/* harmony export */   "default": () => (/* binding */ colorTransformHLGOOTF)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia hlg ootf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

// The luminance vector in rec2020 linear space.
const kLr = 0.2627;
const kLg = 0.6780;
const kLb = 0.0593;
function computeHLGToneMapConstants(options) {
    options.metadata.hlgDstMaxLuminanceRelative = options.dstMaxLuminanceRelative;
    const dstMaxLuminanceNits = options.dstSdrMaxLuminanceNits * options.dstMaxLuminanceRelative;
    options.metadata.hlgOOTFGammaMinusOne = 1.2 + 0.42 * Math.log10(dstMaxLuminanceNits / _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits) / Math.log10(10.0) - 1.0;
}
function colorTransformHLGOOTF(options) {
    if (options.type === 0 /* GLType.kWebGL */) {
        return `
      {
        vec4 luma_vec = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        float L = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        return `
      {
        let luma_vec: vec4<f32> = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        let L: f32 = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    return '';
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformMatrix.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformMatrix.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformMatrix)
/* harmony export */ });
/*
 * libmedia color transform matrix
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformMatrix(matrix, options) {
    let mat4String = '';
    let vec4String = '';
    if (options.type === 0 /* GLType.kWebGL */) {
        mat4String = 'mat4';
        vec4String = 'vec4';
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        mat4String = 'mat4x4';
        vec4String = 'vec4';
    }
    if (!mat4String || !vec4String) {
        return '';
    }
    let source = `
      color = ${mat4String}(
        ${matrix.rc(0, 0)}, ${matrix.rc(1, 0)}, ${matrix.rc(2, 0)}, 0,
        ${matrix.rc(0, 1)}, ${matrix.rc(1, 1)}, ${matrix.rc(2, 1)}, 0,
        ${matrix.rc(0, 2)}, ${matrix.rc(1, 2)}, ${matrix.rc(2, 2)}, 0,
        0, 0, 0, 1
      ) * color;
    `;
    if (matrix.rc(0, 3) !== 0 || matrix.rc(1, 3) !== 0 || matrix.rc(2, 3) !== 0) {
        source += `
        color += ${vec4String}(${matrix.rc(0, 3)}, ${matrix.rc(1, 3)}, ${matrix.rc(2, 3)}, 0);
      `;
    }
    return source;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeSdrRelativeToNitsFactor: () => (/* binding */ computeSdrRelativeToNitsFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSdrToDstNitsRelative)
/* harmony export */ });
/*
 * libmedia color transform sdr to dst nits relative
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function computeSdrRelativeToNitsFactor(unityNits, options) {
    options.metadata.sdrRelativeToNitsFactor = options.dstSdrMaxLuminanceNits / unityNits;
}
function colorTransformSdrToDstNitsRelative(options) {
    return `
    color.r *= sdr_relative_to_nits_factor;
    color.g *= sdr_relative_to_nits_factor;
    color.b *= sdr_relative_to_nits_factor;
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeNitsToSdrRelativeFactor: () => (/* binding */ computeNitsToSdrRelativeFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSrcNitsToSdrRelative)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia color transform src nits to sdr relative
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeNitsToSdrRelativeFactor(unityNits, useSrcSdrWhite, options) {
    let sdrWhiteNits = options.dstSdrMaxLuminanceNits;
    if (useSrcSdrWhite) {
        sdrWhiteNits = _options__WEBPACK_IMPORTED_MODULE_0__.DefaultSDRWhiteLevel;
        if (options.ndwl) {
            sdrWhiteNits = options.ndwl;
        }
    }
    options.metadata.nitsToSdrRelativeFactor = unityNits / sdrWhiteNits;
}
function colorTransformSrcNitsToSdrRelative(options) {
    return `
    color.r *= nits_to_sdr_relative_factor;
    color.g *= nits_to_sdr_relative_factor;
    color.b *= nits_to_sdr_relative_factor;
  `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts":
/*!***********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeTonemapAB: () => (/* binding */ computeTonemapAB),
/* harmony export */   "default": () => (/* binding */ colorTransformToneMapInRec2020Linear)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia colorTransform tone map in rec2020 linear
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeSrcMaxLumRelative(src, options) {
    let srcMaxLumNits = _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits;
    if (src.getTransferId() !== 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */) {
        if (options.maxContentLightLevel > 0) {
            srcMaxLumNits = options.maxContentLightLevel;
        }
    }
    return srcMaxLumNits / options.dstSdrMaxLuminanceNits;
}
function computeTonemapAB(src, options) {
    const srcMaxLumRelative = computeSrcMaxLumRelative(src, options);
    if (srcMaxLumRelative > options.dstMaxLuminanceRelative) {
        options.metadata.pqTonemapA = options.dstMaxLuminanceRelative /
            (srcMaxLumRelative * srcMaxLumRelative);
        options.metadata.pqTonemapB = 1.0 / options.dstMaxLuminanceRelative;
    }
    else {
        options.metadata.pqTonemapA = 0;
        options.metadata.pqTonemapB = 0;
    }
}
function colorTransformToneMapInRec2020Linear(options) {
    return `
    {
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let maximum: f32' : 'float maximum'} = max(color.r, max(color.g, color.b));
      if (maximum > 0.0) {
        color.r *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.g *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.b *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
      }
    }
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/function/toFloatString.ts":
/*!*********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/function/toFloatString.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toFloatString)
/* harmony export */ });
/*
 * libmedia to float string
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function toFloatString(v) {
    if (v === (v >>> 0)) {
        return `${v}.0`;
    }
    return v.toString();
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/generateSteps.ts":
/*!************************************************************!*\
  !*** ./src/avrender/image/colorTransform/generateSteps.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateSteps)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformMatrix */ "./src/avrender/image/colorTransform/colorTransformMatrix.ts");
/* harmony import */ var _transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transferFn/hlgInvOETF */ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts");
/* harmony import */ var _transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transferFn/pq2Linear */ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts");
/* harmony import */ var _transferFn_transferFn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transferFn/transferFn */ "./src/avrender/image/colorTransform/transferFn/transferFn.ts");
/* harmony import */ var _transferFn_toLinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transferFn/toLinear */ "./src/avrender/image/colorTransform/transferFn/toLinear.ts");
/* harmony import */ var _colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorTransformHLGOOTF */ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts");
/* harmony import */ var _colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransformSrcNitsToSdrRelative */ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts");
/* harmony import */ var _colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./colorTransformToneMapInRec2020Linear */ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts");
/* harmony import */ var _colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colorTransformSdrToDstNitsRelative */ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts");
/* harmony import */ var _transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transferFn/hlgOETF */ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts");
/* harmony import */ var _transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transferFn/pqFromLinear */ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts");
/* harmony import */ var _transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./transferFn/fromLinear */ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts");
/*
 * libmedia generate fragment steps
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function generateSteps(src, dst, options) {
    const steps = [];
    const srcMatrixIsIdentityOrYcgco = src.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
    // 1. limited range 转 full range
    const srcRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(src.getRangeAdjustMatrix(options.bitDepth), options);
    if (!srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
        // BT2020 CL is a special case.
        // not to do
    }
    else {
        // 2. 反变换 ColorSpace Matrix，YCbCr 转 RGB
        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
    }
    if (srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (dst.isValid()) {
        if ( true && src.isHDR()) {
            switch (src.getTransferId()) {
                // 3. 如果是 HLG 视频，应用 HLG 反向 OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    steps.push((0,_transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_1__["default"])(options));
                    break;
                // 3. 如果是 PQ 视频，将 PQ 曲线转线性曲线。
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    steps.push((0,_transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_2__["default"])(options));
                    break;
                default:
                    const fn = src.getTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_3__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_toLinear__WEBPACK_IMPORTED_MODULE_4__["default"])(src.getTransferId(), options));
                    }
            }
            if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
            }
            // 4. RGB 空间转 XYZ 空间
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(src.getPrimaryMatrix(), options));
            const rec2020Linear = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_5__["default"](0 /* AVColorSpace.AVCOL_SPC_RGB */, 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */, 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */, 2 /* AVColorRange.AVCOL_RANGE_JPEG */);
            switch (src.getTransferId()) {
                // HLG
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    if (options.toneMapPQAndHlgToDst) {
                        (0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_6__.computeHLGToneMapConstants)(options);
                        steps.push((0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_6__["default"])(options));
                    }
                    else {
                        (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_7__.computeNitsToSdrRelativeFactor)(12.0 / _options__WEBPACK_IMPORTED_MODULE_8__.DefaultSDRWhiteLevel, false, options);
                        steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_7__["default"])(options));
                    }
                    break;
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_7__.computeNitsToSdrRelativeFactor)(_options__WEBPACK_IMPORTED_MODULE_8__.PQRefMaxLumNits, true, options);
                    steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_7__["default"])(options));
                    if (options.toneMapPQAndHlgToDst) {
                        // 5. XYZ 转 Rec2020。
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(rec2020Linear.getPrimaryMatrix().invert(), options));
                        (0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__.computeTonemapAB)(src, options);
                        // 6. 基于显示器最高亮度 + UI 白点亮度，进行 Tone Mapping
                        steps.push((0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__["default"])(options));
                        // 7. Rec2020 转为 XYZ
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(rec2020Linear.getPrimaryMatrix(), options));
                    }
                    break;
                default:
                    break;
            }
            // 8. XYZ 转 RGB
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(dst.getPrimaryMatrix().invert(), options));
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            switch (dst.getTransferId()) {
                // 9. 如果是 HLG 视频，应用 HLG 转 OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_8__.DefaultSDRWhiteLevel, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__["default"])(options));
                    break;
                // 9 如果是 PQ 视频，将线性曲线转 PQ 曲线。
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_8__.PQRefMaxLumNits, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__["default"])(options));
                default:
                    const fn = dst.getInverseTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_3__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__["default"])(src.getTransferId(), options));
                    }
                    break;
            }
        }
        /**
         * 下面的步骤是把 RGB 转到目标颜色空间，判断是否需要
         * 片段着色器输出的颜色应该是 RGB 非线性空间？（此处存疑，未找到相关资料，但找到的其他类似项目均未转换为线性空间，显示器会根据输出做相应的电光转换？） 全色域颜色
         * 但如果后续需要处理颜色（如混合、差值），需要将非线性空间转换为线性空间，在线性空间中处理
         */
        if (!options.outputRGB) {
            const dstMatrixIsIdentityOrYcgco = dst.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
            // 10. Range 反变换
            const dstRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(dst.getRangeAdjustMatrix(options.bitDepth).invert(), options);
            if (dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                // not to do
            }
            else {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_0__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            if (!dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
        }
    }
    return steps;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/options.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorTransform/options.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultSDRWhiteLevel: () => (/* binding */ DefaultSDRWhiteLevel),
/* harmony export */   HLGRefMaxLumNits: () => (/* binding */ HLGRefMaxLumNits),
/* harmony export */   PQRefMaxLumNits: () => (/* binding */ PQRefMaxLumNits)
/* harmony export */ });
/*
 * libmedia ColorTransformOptions defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DefaultSDRWhiteLevel = 203.0;
// The maximum brightness of the reference display for HLG computations.
const HLGRefMaxLumNits = 1000.0;
// The maximum reference brightness of a PQ signal.
const PQRefMaxLumNits = 10000.0;


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts":
/*!********************************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformPerChannelTransferFn)
/* harmony export */ });
/*
 * libmedia colorTransformPerChannelTransferFn
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformPerChannelTransferFn(fn, extended, options) {
    if (extended) {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.r);
        ${fn()}
        color.r = sign(color.r) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.g);
        ${fn()}
        color.g = sign(color.g) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.b);
        ${fn()}
        color.b = sign(color.b) * v;
      }
    `;
    }
    else {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.r;
        ${fn()}
        color.r = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.g;
        ${fn()}
        color.g = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.b;
        ${fn()}
        color.b = v;
      }
    `;
    }
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/fromLinear.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function fromLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v =  1.0 + log(v) / log(10.0) / 2.0;
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < sqrt(10.0) / 1000.0)
            v = 0.0;
          }
          else {
            v = 1.0 + log(v) / log(10.0) / 2.5;
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'}= 0.018053968510807;
          if (v < -b) {
            v = -a * pow(-v, 0.45) + (a - 1.0);
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.018;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let l: f32' : 'float l'} = 0.0045;

          if (v < -l) {
            v = -(a * pow(-4.0 * v, 0.45) + (a - 1.0)) / 4.0;
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgInvOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgInvOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 0.5) {
        v = v * v + 4.0;
      }
      else {
        v = exp((v - c) / a) + b;
      }
      v = v / 12.0;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgOETF.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 1.0) {
        v = 0.5 * sqrt(v);
      }
      else {
        v = a * log(v - b) + c;
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pq2Linear.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pq2Linear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq eotf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pq2Linear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      
      ${options.type === 0 /* GLType.kWebGL */ ? `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        highp float v2 = v;
        #else
        float v2 = v;
        #endif
      ` : 'var v2: f32 = v;'}
  
      v2 = pow(max(pow(v2, 1.0 / m2) - c1, 0.0) / (c2 - c3 * pow(v2, 1.0 / m2)), 1.0 / m1);
      v = v2;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts":
/*!**********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pqFromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pqFromLinear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      v =  pow((c1 + c2 * pow(v, m1)) / (1.0 + c3 * pow(v, m1)), m2);
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/toLinear.ts":
/*!******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/toLinear.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear eotf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function toLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.0);
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.5);
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_a: f32' : 'float from_linear_neg_a'} = -1.047844;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081243;
          if (v < from_linear_neg_a) {
            v = -pow((a - 1.0 - v) / a, 1.0 / 0.45);
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_l: f32' : 'float from_linear_neg_l'} = -0.020250;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081000;
          if (v < from_linear_neg_l) {
            v = -pow((1.0 - a - v * 4.0) / a, 1.0 / 0.45) / 4.0;
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/transferFn.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/transferFn.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transferFn)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/* harmony import */ var _function_toFloatString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/toFloatString */ "./src/avrender/image/colorTransform/function/toFloatString.ts");
/*
 * libmedia transfer fn
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function transferFn(tfn, extended, options) {
    function fn() {
        let epsilon = 0.0009765625;
        let linear = 'v';
        if (Math.abs(tfn.c - 1.0) > epsilon) {
            linear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.c)} * ${linear}`;
        }
        if (Math.abs(tfn.f) > epsilon) {
            linear = `${linear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.f)}`;
        }
        let nonlinear = 'v';
        if (Math.abs(tfn.a = 1.0) > epsilon) {
            nonlinear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.a)} * ${nonlinear}`;
        }
        if (Math.abs(tfn.b) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.b)}`;
        }
        if (Math.abs(tfn.g - 1.0) > epsilon) {
            nonlinear = `pow(${nonlinear}, ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.g)})`;
        }
        if (Math.abs(tfn.e) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.e)}`;
        }
        let source = `
      if (v < ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_0__["default"])(tfn.d)}) {
        v = ${linear};
      }
      else {
        v = ${nonlinear};
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_1__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/function/flipVertex.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/function/flipVertex.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ flipVertex)
/* harmony export */ });
/*
 * libmedia flip vertex
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function flipVertex(vertex, flipHorizontal, flipVertical) {
    if (flipHorizontal) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[17];
        vertex[4] = vertex[18];
        vertex[17] = x;
        vertex[18] = y;
        x = vertex[10];
        y = vertex[11];
        vertex[10] = vertex[24];
        vertex[11] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
    if (flipVertical) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[10];
        vertex[4] = vertex[11];
        vertex[10] = x;
        vertex[11] = y;
        x = vertex[17];
        y = vertex[18];
        vertex[17] = vertex[24];
        vertex[18] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
}


/***/ }),

/***/ "./src/avrender/image/struct/HdrMetadata.ts":
/*!**************************************************!*\
  !*** ./src/avrender/image/struct/HdrMetadata.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HdrMetadata)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia HdrMetadata defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class HdrMetadata {
    offset;
    multiplier;
    pqTonemapA;
    pqTonemapB;
    hlgOOTFGammaMinusOne;
    hlgDstMaxLuminanceRelative;
    nitsToSdrRelativeFactor;
    sdrRelativeToNitsFactor;
}
(function (prototype) {
    var map = new Map();
    map.set("offset", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("multiplier", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("pqTonemapA", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pqTonemapB", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("hlgOOTFGammaMinusOne", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("hlgDstMaxLuminanceRelative", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nitsToSdrRelativeFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("sdrRelativeToNitsFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(HdrMetadata.prototype);


/***/ }),

/***/ "./src/avrender/image/webgl/program/BaseProgram.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/BaseProgram.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseProgram)
/* harmony export */ });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Program */ "./src/avrender/image/webgl/program/Program.ts");
/*
 * libmedia BaseProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class BaseProgram extends _Program__WEBPACK_IMPORTED_MODULE_0__["default"] {
    enableColor;
    aPoint;
    aColor;
    constructor(vertexShader, fragmentShader, enableColor = true) {
        super(vertexShader, fragmentShader);
        this.enableColor = enableColor;
    }
    link(gl) {
        super.link(gl);
        this.aPoint = this.gl.getAttribLocation(this.program, 'point');
        this.aColor = this.gl.getAttribLocation(this.program, 'color');
        if (this.enableColor) {
            this.gl.enableVertexAttribArray(this.aPoint);
            this.gl.enableVertexAttribArray(this.aColor);
        }
        else {
            this.gl.enableVertexAttribArray(this.aPoint);
        }
    }
    bind() {
        super.bind();
        if (this.enableColor) {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
            this.gl.vertexAttribPointer(this.aColor, 4, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
        }
        else {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/Program.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/program/Program.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Program)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avrender/image/webgl/program/Program.ts";

class Program {
    gl;
    _program;
    vertexShader;
    fragmentShader;
    constructor(vertexShader, fragmentShader) {
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
    }
    link(gl) {
        this.gl = gl;
        if (this.vertexShader) {
            this.vertexShader.compile(this.gl);
        }
        if (this.fragmentShader) {
            this.fragmentShader.compile(this.gl);
        }
        // 创建程序对象
        this._program = this.gl.createProgram();
        this.gl.attachShader(this._program, this.vertexShader.shader);
        this.gl.attachShader(this._program, this.fragmentShader.shader);
        this.gl.linkProgram(this._program);
        if (true) {
            if (!this.gl.getProgramParameter(this._program, this.gl.LINK_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(this.gl.getProgramInfoLog(this._program), cheap__fileName__0, 62);
            }
        }
    }
    stop() {
        this.vertexShader.stop(this.gl);
        this.fragmentShader.stop(this.gl);
        this.gl.deleteProgram(this._program);
        this.vertexShader = null;
        this.fragmentShader = null;
        this._program = null;
    }
    bind() {
        this.gl.useProgram(this._program);
    }
    get program() {
        return this._program;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/VideoProgram.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/VideoProgram.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoProgram)
/* harmony export */ });
/* harmony import */ var _BaseProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseProgram */ "./src/avrender/image/webgl/program/BaseProgram.ts");
/* harmony import */ var _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/VertexShader */ "./src/avrender/image/webgl/shader/VertexShader.ts");
/* harmony import */ var _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader/FragmentShader */ "./src/avrender/image/webgl/shader/FragmentShader.ts");
/* harmony import */ var _glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glsl/vertex.vert */ "./src/avrender/image/webgl/glsl/vertex.vert");
/*
 * libmedia VideoProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class VideoProgram extends _BaseProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rotateMatrixLocation;
    constructor(yuvFragmentSource) {
        super(new _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__["default"](_glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_2__["default"]), new _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_3__["default"](yuvFragmentSource));
    }
    link(gl) {
        super.link(gl);
        this.rotateMatrixLocation = this.gl.getUniformLocation(this.program, 'rotateMatrix');
    }
    setRotateMatrix(matrix) {
        this.gl.uniformMatrix4fv(this.rotateMatrixLocation, false, new Float32Array(matrix));
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV16Program.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV16Program.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV16Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV16Program
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV16Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    maxUniformLocation;
    offsetLocation;
    multiplierLocation;
    pqTonemapALocation;
    pqTonemapBLocation;
    hlgOOTFGammaMinusOneLocation;
    hlgDstMaxLuminanceRelativeLocation;
    nitsToSdrRelativeFactorLocation;
    sdrRelativeToNitsFactorLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.maxUniformLocation = this.gl.getUniformLocation(this.program, 'v_max');
        this.offsetLocation = this.gl.getUniformLocation(this.program, 'offset');
        this.multiplierLocation = this.gl.getUniformLocation(this.program, 'multiplier');
        this.pqTonemapALocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_a');
        this.pqTonemapBLocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_b');
        this.hlgOOTFGammaMinusOneLocation = this.gl.getUniformLocation(this.program, 'hlg_ootf_gamma_minus_one');
        this.hlgDstMaxLuminanceRelativeLocation = this.gl.getUniformLocation(this.program, 'hlg_dst_max_luminance_relative');
        this.nitsToSdrRelativeFactorLocation = this.gl.getUniformLocation(this.program, 'nits_to_sdr_relative_factor');
        this.sdrRelativeToNitsFactorLocation = this.gl.getUniformLocation(this.program, 'sdr_relative_to_nits_factor');
    }
    setMax(max) {
        this.gl.uniform1f(this.maxUniformLocation, max);
    }
    setMetaData(data) {
        this.gl.uniform1f(this.offsetLocation, data.offset);
        this.gl.uniform1f(this.multiplierLocation, data.multiplier);
        this.gl.uniform1f(this.pqTonemapALocation, data.pqTonemapA);
        this.gl.uniform1f(this.pqTonemapBLocation, data.pqTonemapB);
        this.gl.uniform1f(this.hlgOOTFGammaMinusOneLocation, data.hlgOOTFGammaMinusOne);
        this.gl.uniform1f(this.hlgDstMaxLuminanceRelativeLocation, data.hlgDstMaxLuminanceRelative);
        this.gl.uniform1f(this.nitsToSdrRelativeFactorLocation, data.nitsToSdrRelativeFactor);
        this.gl.uniform1f(this.sdrRelativeToNitsFactorLocation, data.sdrRelativeToNitsFactor);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV8Program.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV8Program.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV8Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV8Program
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV8Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUVProgram.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUVProgram.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVProgram)
/* harmony export */ });
/* harmony import */ var _VideoProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VideoProgram */ "./src/avrender/image/webgl/program/VideoProgram.ts");
/*
 * libmedia YUVProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVProgram extends _VideoProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    ySamplerLocation;
    uSamplerLocation;
    vSamplerLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.ySamplerLocation = this.gl.getUniformLocation(this.program, 'y_Sampler');
        this.uSamplerLocation = this.gl.getUniformLocation(this.program, 'u_Sampler');
        this.vSamplerLocation = this.gl.getUniformLocation(this.program, 'v_Sampler');
    }
    bindYTexture(unit = 0) {
        this.gl.uniform1i(this.ySamplerLocation, unit);
    }
    bindUTexture(unit = 0) {
        this.gl.uniform1i(this.uSamplerLocation, unit);
    }
    bindVTexture(unit = 0) {
        this.gl.uniform1i(this.vSamplerLocation, unit);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/FragmentShader.ts":
/*!***********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/FragmentShader.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FragmentShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia FragmentShader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class FragmentShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(1 /* ShaderType.FRAGMENT */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/Shader.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/shader/Shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avrender/image/webgl/shader/Shader.ts";
/*
 * libmedia Shader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Shader {
    type;
    _shader;
    _source;
    compiled;
    constructor(type, source) {
        this.type = type;
        this._shader = null;
        this._source = source;
        this.compiled = false;
    }
    compile(gl) {
        if (this.compiled) {
            return;
        }
        this._shader = gl.createShader(this.type === 0 /* ShaderType.VERTEX */ ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        gl.shaderSource(this._shader, this._source);
        gl.compileShader(this._shader);
        if (true) {
            if (!gl.getShaderParameter(this._shader, gl.COMPILE_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(gl.getShaderInfoLog(this._shader), cheap__fileName__0, 60);
            }
        }
        this.compiled = true;
    }
    stop(gl) {
        gl.deleteShader(this._shader);
        this._shader = null;
    }
    get shader() {
        return this._shader;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/VertexShader.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/VertexShader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VertexShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia VertexShader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class VertexShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(0 /* ShaderType.VERTEX */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/Texture.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/texture/Texture.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia Texture
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Texture {
    gl;
    width;
    height;
    texture;
    constructor(gl, width, height) {
        this.gl = gl;
        this.width = width;
        this.height = height;
        this.texture = this.gl.createTexture();
    }
    getTexture() {
        return this.texture;
    }
    bind(unit) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(unit)) {
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * 设置对齐字节数
     */
    setUnpackAlignment() {
        if (this.width % 8 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 8);
        }
        else if (this.width % 4 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4);
        }
        else if (this.width % 2 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2);
        }
        else {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        }
    }
    destroy() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/YUVTexture.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/texture/YUVTexture.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVTexture)
/* harmony export */ });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture */ "./src/avrender/image/webgl/texture/Texture.ts");
/*
 * libmedia YUVTexture
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVTexture extends _Texture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    data;
    filter;
    format;
    internalformat;
    dataType;
    constructor(gl, data, width, height) {
        super(gl, width, height);
        this.data = data;
        this.format = this.gl.LUMINANCE;
        this.filter = this.gl.LINEAR;
        this.internalformat = this.gl.LUMINANCE;
        this.dataType = this.gl.UNSIGNED_BYTE;
    }
    init() {
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
    setFormat(format) {
        this.format = format;
    }
    setInternalformat(format) {
        this.internalformat = format;
    }
    setDataType(type) {
        this.dataType = type;
    }
    setFilter(filter) {
        this.filter = filter;
    }
    fill(data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.setUnpackAlignment();
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.internalformat, this.width, this.height, 0, this.format, this.dataType, data);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceBufferNode.ts":
/*!***************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceBufferNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceBufferNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
var cheap__fileName__14 = "src/avrender/pcm/AudioSourceBufferNode.ts";


/*
 * libmedia AudioSourceBufferNode
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_LENGTH = 10;
class AudioSourceBufferNode {
    context;
    observer;
    options;
    pullIPC;
    buffer;
    channels;
    ended;
    float32;
    buffered;
    pause;
    startTime;
    dest;
    queue;
    firstRendered;
    constructor(context, observer, options = {}) {
        this.context = context;
        this.observer = observer;
        this.options = options;
    }
    async request(method, params, transfer) {
        switch (method) {
            case 'init': {
                break;
            }
            case 'start': {
                const { port, channels } = params;
                this.channels = channels;
                this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
                this.buffer = this.allocBuffer();
                this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer);
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffering();
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffered = true;
                this.process();
                break;
            }
            case 'restart': {
                if (!this.ended) {
                    return;
                }
                this.buffer = this.allocBuffer();
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffering();
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffered = true;
                this.process();
                break;
            }
            case 'stop': {
                this.freeBuffer(this.buffer);
                this.buffer = null;
                this.ended = true;
                this.pullIPC.destroy();
                break;
            }
            case 'clear': {
                this.queue.forEach((buffer) => {
                    buffer.disconnect();
                });
                this.queue.length = 0;
                break;
            }
            case 'pause': {
                this.pause = true;
                break;
            }
            case 'unpause': {
                this.pause = false;
                if (!this.queue.length) {
                    this.process();
                }
                break;
            }
        }
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](buffer + 8, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buffer);
    }
    async pull() {
        this.buffered = false;
        const ret = await this.pullIPC.request('pull', {
            buffer: this.buffer
        });
        if (ret < 0) {
            this.ended = true;
        }
        else {
            this.buffered = true;
            if (!this.queue.length) {
                this.process();
            }
        }
    }
    buffering() {
        if (!this.float32.length) {
            this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer);
        }
        const audioBuffer = this.context.createBuffer(this.channels, BUFFER_LENGTH * 128, this.context.sampleRate);
        for (let i = 0; i < this.channels; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](this.buffer) + (i * 4))) {
                let pos = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](this.buffer) + (i * 4)) >>> 2;
                if (audioBuffer.copyToChannel && !cheap_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS) {
                    audioBuffer.copyToChannel(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), i, 0);
                }
                else {
                    const audioData = audioBuffer.getChannelData(i);
                    audioData.set(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), 0);
                }
            }
        }
        const bufferSource = this.context.createBufferSource();
        bufferSource.buffer = audioBuffer;
        bufferSource.onended = () => {
            this.queue.shift();
            if (this.ended && !this.queue.length) {
                this.freeBuffer(this.buffer);
                common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info('audio source ended', cheap__fileName__14, 229);
                this.observer.onEnded();
                return;
            }
            this.process();
            if (!this.queue.length) {
                this.observer.onStutter();
            }
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.observer.onFirstRendered();
            }
        };
        if (this.startTime === 0) {
            this.startTime = this.context.currentTime;
        }
        bufferSource.start(this.startTime);
        if (this.dest) {
            bufferSource.connect(this.dest);
        }
        this.startTime += bufferSource.buffer.duration;
        this.queue.push(bufferSource);
    }
    connect(dest) {
        this.dest = dest;
    }
    disconnect() {
        for (let i = 0; i < this.queue.length; i++) {
            this.queue[i].disconnect();
        }
        this.dest = null;
        this.queue.length = 0;
    }
    process() {
        if (this.buffer && !this.pause && this.buffered) {
            this.buffering();
            this.pull();
        }
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletNode.ts":
/*!****************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceWorkletNode)
/* harmony export */ });
/* harmony import */ var _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletNodeBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts");
/*
 * libmedia AudioSourceWorkletNode
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioSourceWorkletNode extends _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, observer, options = {}) {
        super(context, observer, 'audio-source-processor', options);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avrender/pcm/AudioSourceWorkletProcessor.ts";
/*
 * libmedia AudioSourceWorkletProcessor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




const BUFFER_LENGTH = 10;
class AudioSourceWorkletProcessor extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    pause;
    firstRendered;
    constructor() {
        super();
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    this.ended = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    async pull(data) {
        const buffer = await this.pullIPC.request('pullBuffer', {
            nbSamples: BUFFER_LENGTH * 128
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.number(buffer)) {
            this.ended = true;
        }
        else {
            const float = new Float32Array(buffer);
            for (let i = 0; i < this.channels; i++) {
                data[i] = float.subarray(i * BUFFER_LENGTH * 128, (i + 1) * BUFFER_LENGTH * 128);
            }
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            this.backBuffer = this.frontBuffer;
            this.backBufferOffset = 0;
            this.frontBuffer = [];
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull(this.frontBuffer).then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.backBuffer = null;
                    this.frontBuffer = null;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_3__.info('audio source ended', cheap__fileName__0, 178);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.backBuffer[i].subarray(this.backBufferOffset * 128, (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor);


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor2.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__10 = "src/avrender/pcm/AudioSourceWorkletProcessor2.ts";


/*
 * libmedia AudioSourceWorkletProcessor in share memory
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_LENGTH = 10;
class AudioSourceWorkletProcessor2 extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    firstRendered;
    float32;
    pause;
    constructor() {
        super();
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    const { memory } = request.params;
                    await (0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.initThread)({
                        memory,
                        disableAsm: true
                    });
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__["default"](port);
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    this.ended = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](buffer + 8, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(buffer);
    }
    async pull() {
        const ret = await this.pullIPC.request('pull', {
            buffer: this.frontBuffer
        });
        if (ret < 0) {
            this.ended = true;
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            const backBuffer = this.backBuffer;
            this.backBuffer = this.frontBuffer;
            this.frontBuffer = backBuffer;
            this.backBufferOffset = 0;
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull().then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info('audio source ended', cheap__fileName__10, 217);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.float32.subarray((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + this.backBufferOffset * 128, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor2);


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletNodeBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia AudioWorkletNodeBase
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class AudioWorkletNodeBase {
    audioWorkletNode;
    ipcPort;
    observer;
    constructor(context, observer, processor, options = {}) {
        this.observer = observer;
        this.audioWorkletNode = new AudioWorkletNode(context, processor, options);
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.audioWorkletNode.port);
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onEnded();
                    break;
                case 'firstRendered':
                    this.observer.onFirstRendered();
                    break;
                case 'stutter':
                    this.observer.onStutter();
                    break;
            }
        });
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    connect(audioNode) {
        this.audioWorkletNode.connect(audioNode);
    }
    getNode() {
        return this.audioWorkletNode;
    }
    disconnect() {
        this.audioWorkletNode.disconnect();
    }
    getParameters(type) {
        const parameters = this.audioWorkletNode.parameters;
        // @ts-ignore
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(parameters.get)) {
            // @ts-ignore
            return parameters.get(type);
        }
        parameters.forEach((value, key) => {
            if (key === type) {
                return value;
            }
        });
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts":
/*!*************************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletProcessorBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/*
 * libmedia AudioWorkletProcessorBase
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioWorkletProcessorBase extends AudioWorkletProcessor {
    ipcPort;
    constructor() {
        super();
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.port);
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    notify(method, params, transfer) {
        this.ipcPort.notify(method, params, transfer);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/registerProcessor.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ registerProcessor)
/* harmony export */ });
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/*
 * libmedia registerProcessor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

async function registerProcessor(audioContext, moduleId) {
    const source = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(moduleId, {
        varName: 'processor'
    });
    const blob = new Blob([source], { type: 'text/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(workerUrl);
}


/***/ }),

/***/ "./src/avrender/track/Track.ts":
/*!*************************************!*\
  !*** ./src/avrender/track/Track.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Track)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avrender/track/Track.ts";
/*
 * libmedia Track
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


var Operator;
(function (Operator) {
    Operator[Operator["ADD"] = 0] = "ADD";
    Operator[Operator["REMOVE"] = 1] = "REMOVE";
    Operator[Operator["UPDATE_TIMESTAMP_OFFSET"] = 2] = "UPDATE_TIMESTAMP_OFFSET";
})(Operator || (Operator = {}));
const defaultTrackOptions = {
    mediaBufferMax: 10
};
class Track {
    sourceBuffer;
    operatorQueue;
    updating;
    lastRemoveTime;
    paddingCallback;
    options;
    ending;
    onQuotaExceededError;
    onEnded;
    constructor(options = {}) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, defaultTrackOptions, options);
        this.operatorQueue = [];
        this.updating = false;
        this.lastRemoveTime = 0;
        this.ending = false;
    }
    setSourceBuffer(sourceBuffer) {
        this.sourceBuffer = sourceBuffer;
        this.sourceBuffer.addEventListener('updateend', () => {
            if (this.paddingCallback) {
                this.paddingCallback();
                this.paddingCallback = null;
            }
            if (this.operatorQueue && this.operatorQueue.length) {
                this.enqueue();
            }
            else {
                this.updating = false;
                if (this.ending) {
                    if (this.onEnded) {
                        this.onEnded();
                    }
                }
            }
        });
        this.sourceBuffer.addEventListener('error', (error) => {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error('track update buffer error', cheap__fileName__0, 102);
        });
    }
    changeMimeType(type) {
        if (this.sourceBuffer) {
            this.sourceBuffer.changeType(type);
        }
    }
    addBuffer(buffer, callback) {
        if (!buffer) {
            if (callback) {
                callback();
            }
            return;
        }
        if (!this.updating && !this.operatorQueue.length) {
            try {
                this.sourceBuffer.appendBuffer(buffer);
                this.updating = true;
                if (callback) {
                    this.paddingCallback = callback;
                }
            }
            catch (error) {
                if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                    // buffer 满了，返回队列重新操作
                    this.operatorQueue.push({
                        operator: Operator.ADD,
                        buffer,
                        callback
                    });
                    if (this.onQuotaExceededError) {
                        this.onQuotaExceededError();
                    }
                }
                else {
                    throw error;
                }
            }
        }
        else {
            this.operatorQueue.push({
                operator: Operator.ADD,
                buffer,
                callback
            });
        }
    }
    updateTimestampOffset(timestampOffset, callback) {
        if (!this.updating && !this.operatorQueue.length) {
            this.sourceBuffer.timestampOffset = timestampOffset;
            if (callback) {
                callback();
            }
            this.enqueue();
        }
        else {
            this.operatorQueue.push({
                operator: Operator.UPDATE_TIMESTAMP_OFFSET,
                timestampOffset,
                callback
            });
        }
    }
    end() {
        this.ending = true;
        if (!this.updating && !this.operatorQueue.length) {
            if (this.onEnded) {
                this.onEnded();
            }
        }
    }
    isPaused() {
        return !this.updating && this.operatorQueue.length;
    }
    getQueueLength() {
        return this.operatorQueue.length;
    }
    enqueue() {
        if (this.operatorQueue.length) {
            const operator = this.operatorQueue.shift();
            if (operator.operator === Operator.ADD) {
                try {
                    this.sourceBuffer.appendBuffer(operator.buffer);
                    this.updating = true;
                    if (operator.callback) {
                        this.paddingCallback = operator.callback;
                    }
                }
                catch (error) {
                    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                        // buffer 满了，返回队列重新操作
                        this.operatorQueue.unshift(operator);
                        if (this.onQuotaExceededError) {
                            this.onQuotaExceededError();
                        }
                        this.updating = false;
                    }
                    else {
                        throw error;
                    }
                }
            }
            else if (operator.operator === Operator.REMOVE) {
                this.sourceBuffer.remove(operator.start, operator.end);
                this.updating = true;
                if (operator.callback) {
                    this.paddingCallback = operator.callback;
                }
            }
            else if (operator.operator === Operator.UPDATE_TIMESTAMP_OFFSET) {
                this.sourceBuffer.timestampOffset = operator.timestampOffset;
                if (operator.callback) {
                    operator.callback();
                }
                this.enqueue();
            }
        }
    }
    removeBuffer(time, callback) {
        if (this.ending) {
            return;
        }
        time = Math.floor(time);
        if (time - this.lastRemoveTime < this.options.mediaBufferMax << 1) {
            return;
        }
        if (!this.updating && !this.operatorQueue.length) {
            this.sourceBuffer.remove(this.lastRemoveTime, time - this.options.mediaBufferMax);
            this.updating = true;
            if (callback) {
                this.paddingCallback = callback;
            }
        }
        else {
            this.operatorQueue.push({
                operator: Operator.REMOVE,
                start: this.lastRemoveTime,
                end: time - this.options.mediaBufferMax,
                callback
            });
        }
        this.lastRemoveTime = time - this.options.mediaBufferMax;
    }
    stop() {
        if (this.sourceBuffer) {
            try {
                this.sourceBuffer.abort();
                this.updating = false;
            }
            catch (error) { }
            try {
                if (this.sourceBuffer.buffered.length) {
                    if (!this.updating) {
                        this.sourceBuffer.remove(this.sourceBuffer.buffered.start(0), this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1));
                        this.updating = true;
                    }
                    else {
                        this.operatorQueue.push({
                            operator: Operator.REMOVE,
                            start: this.sourceBuffer.buffered.start(0),
                            end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1)
                        });
                    }
                }
                if (this.paddingCallback) {
                    this.paddingCallback();
                    this.paddingCallback = null;
                }
            }
            catch (error) { }
        }
    }
    removeAllBuffer(callback) {
        if (this.sourceBuffer.buffered.length) {
            if (!this.updating) {
                this.sourceBuffer.remove(this.sourceBuffer.buffered.start(0), this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1));
                this.updating = true;
                if (callback) {
                    this.paddingCallback = callback;
                }
            }
            else {
                this.operatorQueue.push({
                    operator: Operator.REMOVE,
                    start: this.sourceBuffer.buffered.start(0),
                    end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1),
                    callback
                });
            }
        }
        else if (callback) {
            callback();
        }
    }
    reset() {
        this.stop();
        this.operatorQueue.length = 0;
        this.ending = false;
    }
    getBufferedTime() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1) - this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedStart() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedEnd() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1);
        }
        return 0;
    }
    getSourceBuffer() {
        return this.sourceBuffer;
    }
    setMediaBufferMax(max) {
        this.options.mediaBufferMax = max;
    }
    getMediaBufferMax() {
        return this.options.mediaBufferMax;
    }
    destroy() {
        this.stop();
        this.operatorQueue = null;
        this.sourceBuffer = null;
    }
}


/***/ }),

/***/ "./src/avrender/track/function/getAudioMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getAudioMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioMimeType)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");

/*
 * libmedia get audio mimetype
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function getAudioMimeType(codecpar) {
    let mimeType = '';
    // firefox supports 'audio/mp4, codecs="mp3"', use 'audio/mpeg' for chrome, safari
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_1__["default"].firefox) {
        mimeType = 'audio/mpeg';
    }
    else {
        mimeType = `audio/mp4; codecs="${(0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(codecpar)}"`;
    }
    return mimeType;
}


/***/ }),

/***/ "./src/avrender/track/function/getVideoMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getVideoMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoMimeType)
/* harmony export */ });
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/*
 * libmedia get video mimetype
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getVideoMimeType(codecpar) {
    return `video/mp4; codecs="${(0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__["default"])(codecpar)}"`;
}


/***/ }),

/***/ "./src/avutil/constant.ts":
/*!********************************!*\
  !*** ./src/avutil/constant.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_MILLI_TIME_BASE_Q: () => (/* binding */ AV_MILLI_TIME_BASE_Q),
/* harmony export */   AV_TIME_BASE: () => (/* binding */ AV_TIME_BASE),
/* harmony export */   AV_TIME_BASE_Q: () => (/* binding */ AV_TIME_BASE_Q),
/* harmony export */   INT32_MAX: () => (/* binding */ INT32_MAX),
/* harmony export */   NOPTS_VALUE: () => (/* binding */ NOPTS_VALUE),
/* harmony export */   NOPTS_VALUE_BIGINT: () => (/* binding */ NOPTS_VALUE_BIGINT),
/* harmony export */   UINT16_MAX: () => (/* binding */ UINT16_MAX),
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX)
/* harmony export */ });
/* unused harmony exports AV_MILLI_TIME_BASE, AV_TIME_BASE1_Q, INT8_MAX, INT16_MAX, INT8_MIN, INT16_MIN, INT32_MIN, UINT8_MAX */
/* harmony import */ var _struct_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./struct/rational */ "./src/avutil/struct/rational.ts");
/*
 * libmedia constant
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const NOPTS_VALUE_BIGINT = -BigInt(1);
const NOPTS_VALUE = -1;
const AV_TIME_BASE = 1000000;
const AV_MILLI_TIME_BASE = 1000;
/**
 * 微秒时间基
 */
const AV_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_TIME_BASE, num: 1 });
/**
 * 毫秒时间基
 */
const AV_MILLI_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_MILLI_TIME_BASE, num: 1 });
/**
 * 秒时间基
 */
const AV_TIME_BASE1_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: 1, num: 1 });
const INT8_MAX = 127;
const INT16_MAX = 32767;
const INT32_MAX = 2147483647;
const INT8_MIN = -128;
const INT16_MIN = -32768;
const INT32_MIN = -INT32_MAX - 1;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;
const UINT32_MAX = 4294967295;


/***/ }),

/***/ "./src/avutil/error.ts":
/*!*****************************!*\
  !*** ./src/avutil/error.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_INVALID: () => (/* binding */ DATA_INVALID),
/* harmony export */   FORMAT_NOT_SUPPORT: () => (/* binding */ FORMAT_NOT_SUPPORT),
/* harmony export */   INVALID_ARGUMENT: () => (/* binding */ INVALID_ARGUMENT),
/* harmony export */   INVALID_OPERATE: () => (/* binding */ INVALID_OPERATE),
/* harmony export */   NO_MEMORY: () => (/* binding */ NO_MEMORY)
/* harmony export */ });
/* unused harmony export EAGAIN */
/*
 * libmedia error defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const FORMAT_NOT_SUPPORT = -1;
const DATA_INVALID = -2;
const INVALID_ARGUMENT = -3;
const NO_MEMORY = -4;
const INVALID_OPERATE = -5;
const EAGAIN = -6;


/***/ }),

/***/ "./src/avutil/implement/AVFramePoolImpl.ts":
/*!*************************************************!*\
  !*** ./src/avutil/implement/AVFramePoolImpl.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVFramePoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");


/*
 * libmedia AVFrame pool implement
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





class AVFramePoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avframe = this.list.find((avframe) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(avframe + 360, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avframe) {
            avframe = (0,_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(368);
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.getAVFrameDefault)(avframe);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[16](avframe + 360, 1);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avframe, 20);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avframe;
    }
    release(avframe) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(avframe + 360, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(avframe + 360, 1, 16, 2) === 1) {
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.unrefAVFrame)(avframe);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(avframe + 360, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPCMBufferPoolImpl.ts":
/*!*****************************************************!*\
  !*** ./src/avutil/implement/AVPCMBufferPoolImpl.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBufferPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");


/*
 * libmedia AVPCMBuffer pool implement
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class AVPCMBufferPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let buffer = this.list.find((buffer) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(buffer + 40, -1, 1, 16, 2) === -1;
        }, 20);
        if (!buffer) {
            buffer = (0,_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(48);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[16](buffer + 40, 1);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock(this.mutex);
            }
            this.list.push(buffer, 20);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(this.mutex);
            }
        }
        return buffer;
    }
    release(buffer) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(buffer + 40, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(buffer + 40, 1, 16, 2) === 1) {
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(buffer + 40, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPacketPoolImpl.ts":
/*!**************************************************!*\
  !*** ./src/avutil/implement/AVPacketPoolImpl.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPacketPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");







class AVPacketPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avpacket = this.list.find((avpacket) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(avpacket + 88, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avpacket) {
            avpacket = (0,_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(96);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketDefault)(avpacket);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[16](avpacket + 88, 1);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avpacket, 20);
            if ( true && this.mutex) {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avpacket;
    }
    release(avpacket) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(avpacket + 88, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(avpacket + 88, 1, 16, 2) === 1) {
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.unrefAVPacket)(avpacket);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(avpacket + 88, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/pixelFormatDescriptor.ts":
/*!*********************************************!*\
  !*** ./src/avutil/pixelFormatDescriptor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelFormatDescriptorsMap: () => (/* binding */ PixelFormatDescriptorsMap)
/* harmony export */ });
/* unused harmony export chromaLocation2Pos */
/*
 * libmedia pixel format descriptor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const PixelFormatDescriptorsMap = {
    /**
     * 1 字节
     */
    [0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [12 /* AVPixelFormat.AV_PIX_FMT_YUVJ420P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [13 /* AVPixelFormat.AV_PIX_FMT_YUVJ422P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [14 /* AVPixelFormat.AV_PIX_FMT_YUVJ444P */]: {
        depth: 8,
        max: 255,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    /**
     * 2 字节 yuv420
     */
    [59 /* AVPixelFormat.AV_PIX_FMT_YUV420P9BE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [60 /* AVPixelFormat.AV_PIX_FMT_YUV420P9LE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [122 /* AVPixelFormat.AV_PIX_FMT_YUV420P12BE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [123 /* AVPixelFormat.AV_PIX_FMT_YUV420P12LE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [124 /* AVPixelFormat.AV_PIX_FMT_YUV420P14BE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [125 /* AVPixelFormat.AV_PIX_FMT_YUV420P14LE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [46 /* AVPixelFormat.AV_PIX_FMT_YUV420P16BE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [45 /* AVPixelFormat.AV_PIX_FMT_YUV420P16LE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    /**
     * 2 字节 yuv422
     */
    [69 /* AVPixelFormat.AV_PIX_FMT_YUV422P9BE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [70 /* AVPixelFormat.AV_PIX_FMT_YUV422P9LE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [126 /* AVPixelFormat.AV_PIX_FMT_YUV422P12BE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [127 /* AVPixelFormat.AV_PIX_FMT_YUV422P12LE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [128 /* AVPixelFormat.AV_PIX_FMT_YUV422P14BE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [129 /* AVPixelFormat.AV_PIX_FMT_YUV422P14LE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [48 /* AVPixelFormat.AV_PIX_FMT_YUV422P16BE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [47 /* AVPixelFormat.AV_PIX_FMT_YUV422P16LE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    /**
     * 2 字节 yuv444
     */
    [65 /* AVPixelFormat.AV_PIX_FMT_YUV444P9BE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [66 /* AVPixelFormat.AV_PIX_FMT_YUV444P9LE */]: {
        depth: 9,
        max: 511,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */]: {
        depth: 10,
        max: 1023,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [130 /* AVPixelFormat.AV_PIX_FMT_YUV444P12BE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [131 /* AVPixelFormat.AV_PIX_FMT_YUV444P12LE */]: {
        depth: 12,
        max: 4095,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [132 /* AVPixelFormat.AV_PIX_FMT_YUV444P14BE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [133 /* AVPixelFormat.AV_PIX_FMT_YUV444P14LE */]: {
        depth: 14,
        max: 16383,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    },
    [50 /* AVPixelFormat.AV_PIX_FMT_YUV444P16BE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 2 /* PixelFormatFlags.PLANER */
    },
    [49 /* AVPixelFormat.AV_PIX_FMT_YUV444P16LE */]: {
        depth: 16,
        max: 65535,
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 2 /* PixelFormatFlags.PLANER */
    }
};
function chromaLocation2Pos(pos) {
    if (pos <= 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */ || pos >= 7 /* AVChromaLocation.AVCHROMA_LOC_NB */) {
        return;
    }
    return {
        x: (pos & 1) * 128,
        y: ((pos >>> 1) ^ (pos < 4 ? 1 : 0)) * 128
    };
}


/***/ }),

/***/ "./src/avutil/struct/audiosample.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/audiosample.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVChannelLayout: () => (/* binding */ AVChannelLayout)
/* harmony export */ });
/* unused harmony export AVChannelCustom */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVChannelCustom {
    id;
    name;
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("name", { 0: 4, 1: 0, 2: 0, 3: 1, 4: 16, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVChannelCustom.prototype);
class AVChannelLayout {
    /**
     * Channel order used in this layout.
     * This is a mandatory field.
     */
    order;
    /**
     * Number of channels in this layout. Mandatory field.
     */
    nbChannels;
    /**
     * Details about which channels are present in this layout.
     * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
     * used.
     */
    u;
    /**
     * For some private data of the user.
     */
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("order", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("nbChannels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("u", { 0: (function (prototype) {
            var map = new Map();
            map.set("mask", { 0: 10, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            map.set("map", { 0: AVChannelCustom, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
            return prototype;
        })({}), 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVChannelLayout.prototype);


/***/ }),

/***/ "./src/avutil/struct/avbuffer.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avbuffer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVBufferRef: () => (/* binding */ AVBufferRef)
/* harmony export */ });
/* unused harmony exports AVBuffer, AVBufferPool, BufferPoolEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cheap/thread/mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
var cheap__BufferPoolEntry__16;



/*
 * libmedia AVBuffer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVBuffer {
    /**
     * data described by this buffer
     */
    data = 0;
    /**
     * size of data in bytes
     */
    size = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * A combination of AV_BUFFER_FLAG_*
     */
    flags = 0 /* AVBufferFlags.NONE */;
    /**
     * A combination of BUFFER_FLAG_*
     */
    flagsInternal = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("flagsInternal", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 28);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBuffer.prototype);
function avbufferDefaultFree(opaque, data) {
    (0,_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(data);
}
class AVBufferRef {
    buffer = 0;
    /**
     * The data buffer. It is considered writable if and only if
     * this is the only reference to the buffer, in which case
     * av_buffer_is_writable() returns 1.
     */
    data = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buffer", { 0: AVBuffer, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBufferRef.prototype);
class AVBufferPool {
    mutex;
    pool = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    alloc = 0;
    alloc2 = 0;
    poolFree = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("mutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pool", { 0: cheap__BufferPoolEntry__16, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("alloc", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("alloc2", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("poolFree", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBufferPool.prototype);
class BufferPoolEntry {
    data = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    pool = 0;
    next = 0;
    /*
     * An AVBuffer structure to (re)use as AVBuffer for subsequent uses
     * of this BufferPoolEntry.
     */
    buffer;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pool", { 0: AVBufferPool, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("next", { 0: BufferPoolEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("buffer", { 0: AVBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(BufferPoolEntry.prototype);
cheap__BufferPoolEntry__16 = BufferPoolEntry;


/***/ }),

/***/ "./src/avutil/struct/avcodecparameters.ts":
/*!************************************************!*\
  !*** ./src/avutil/struct/avcodecparameters.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVCodecParameters)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _rational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _avpacket_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./avpacket.ts */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_codecparameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/codecparameters */ "./src/avutil/util/codecparameters.ts");





/*
 * libmedia AVCodecParameters defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




/**
 * FFmpeg AVCodecParameters 定义
 */
class AVCodecParameters {
    /**
     * General type of the encoded data.
     */
    codecType = -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */;
    /**
     * Specific type of the encoded data (the codec used).
     */
    codecId = 0 /* AVCodecID.AV_CODEC_ID_NONE */;
    /**
     * Additional information about the codec (corresponds to the AVI FOURCC).
     */
    codecTag = 0;
    /**
     * Extra binary data needed for initializing the decoder, codec-dependent.
     *
     * Must be allocated with av_malloc() and will be freed by
     * avcodec_parameters_free(). The allocated size of extradata must be at
     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
     * bytes zeroed.
     */
    extradata = 0;
    extradataSize = 0;
    /**
     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * The average bitrate of the encoded data (in bits per second).
     */
    bitRate = BigInt(0);
    /**
     * The number of bits per sample in the codedwords.
     *
     * This is basically the bitrate per sample. It is mandatory for a bunch of
     * formats to actually decode them. It's the number of bits for one sample in
     * the actual coded bitstream.
     *
     * This could be for example 4 for ADPCM
     * For PCM formats this matches bits_per_raw_sample
     * Can be 0
     */
    bitsPerCodedSample = 0;
    /**
     * This is the number of valid bits in each output sample. If the
     * sample format has more bits, the least significant bits are additional
     * padding bits, which are always 0. Use right shifts to reduce the sample
     * to its actual size. For example, audio formats with 24 bit samples will
     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
     * To get the original sample use "(int32_t)sample >> 8"."
     *
     * For ADPCM this might be 12 or 16 or similar
     * Can be 0
     */
    bitsPerRawSample = 0;
    /**
     * Codec-specific bitstream restrictions that the stream conforms to.
     */
    profile = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    level = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Video only. The dimensions of the video frame in pixels.
     */
    width = 0;
    height = 0;
    /**
     * Video only. The aspect ratio (width / height) which a single pixel
     * should have when displayed.
     *
     * When the aspect ratio is unknown / undefined, the numerator should be
     * set to 0 (the denominator may have any value).
     */
    sampleAspectRatio = new _rational__WEBPACK_IMPORTED_MODULE_1__.Rational({ den: 1, num: 0 });
    /**
     * Video only. The order of the fields in interlaced video.
     */
    fieldOrder = 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */;
    /**
     * Video only. Additional colorspace characteristics.
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * Video only. Number of delayed frames.
     */
    videoDelay = 0;
    /**
     * Audio only. The channel layout bitmask. May be 0 if the channel layout is
     * unknown or unspecified, otherwise the number of bits set must be equal to
     * the channels field.
     * @deprecated use ch_layout
     */
    channelLayout = BigInt(0);
    /**
     * Audio only. The number of audio channels.
     * @deprecated use ch_layout.nb_channels
     */
    channels = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Audio only. The number of audio samples per second.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Audio only. The number of bytes per coded audio frame, required by some
     * formats.
     *
     * Corresponds to nBlockAlign in WAVEFORMATEX.
     */
    blockAlign = 0;
    /**
     * Audio only. Audio frame size, if known. Required by some formats to be static.
     */
    frameSize = 0;
    /**
     * Audio only. The amount of padding (in samples) inserted by the encoder at
     * the beginning of the audio. I.e. this number of leading decoded samples
     * must be discarded by the caller to get the original audio without leading
     * padding.
     */
    initialPadding = 0;
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     */
    trailingPadding = 0;
    /**
     * Audio only. Number of samples to skip after a discontinuity.
     */
    seekPreroll = 0;
    /**
     * Audio only. The channel layout and number of channels.
     */
    chLayout;
    /**
     * Video only. Number of frames per second, for streams with constant frame
     * durations. Should be set to { 0, 1 } when some frames have differing
     * durations or if the value is not known.
     *
     * @note This field correponds to values that are stored in codec-level
     * headers and is typically overridden by container/transport-layer
     * timestamps, when available. It should thus be used only as a last resort,
     * when no higher-level timing information is available.
     */
    framerate = new _rational__WEBPACK_IMPORTED_MODULE_1__.Rational({ den: 1, num: 0 });
    /**
     * Additional data associated with the entire stream.
     *
     * Should be allocated with av_packet_side_data_new() or
     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
     */
    codedSideData = 0;
    /**
     * Amount of entries in @ref coded_side_data.
     */
    nbCodedSideData = 0;
    /**
     * 码流格式
     * 对于 h264/h265 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
    destroy() {
        (0,_util_codecparameters__WEBPACK_IMPORTED_MODULE_2__.freeCodecParameters)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress]);
        this[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("codecType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("codecId", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("codecTag", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("extradata", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("extradataSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("bitRate", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("bitsPerCodedSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("bitsPerRawSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 36, 8: 0 });
    map.set("profile", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("level", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational__WEBPACK_IMPORTED_MODULE_1__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("fieldOrder", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 76, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("videoDelay", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("channelLayout", { 0: 10, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 108, 8: 0 });
    map.set("blockAlign", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("frameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 116, 8: 0 });
    map.set("initialPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("trailingPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 124, 8: 0 });
    map.set("seekPreroll", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("framerate", { 0: _rational__WEBPACK_IMPORTED_MODULE_1__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    map.set("codedSideData", { 0: _avpacket_ts__WEBPACK_IMPORTED_MODULE_5__.AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 168, 8: 0 });
    map.set("nbCodedSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 172, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 176, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 184);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVCodecParameters.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpacket.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avpacket.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPacketSideData: () => (/* binding */ AVPacketSideData)
/* harmony export */ });
/* unused harmony exports default, AVPacketRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");






class AVPacketSideData {
    data = 0;
    size = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    type = -1 /* AVPacketSideDataType.AV_PKT_DATA_UNKNOWN */;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacketSideData.prototype);
/**
 * FFmpeg AVPacket 定义
 */
class AVPacket {
    /**
     * A reference to the reference-counted buffer where the packet data is
     * stored.
     * May be NULL, then the packet data is not reference-counted.
     */
    buf = 0;
    /**
     * Presentation timestamp in AVStream->time_base units; the time at which
     * the decompressed packet will be presented to the user.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     * pts MUST be larger or equal to dts as presentation cannot happen before
     * decompression, unless one wants to view hex dumps. Some formats misuse
     * the terms dts and pts/cts to mean something different. Such timestamps
     * must be converted to true pts/dts before they are stored in AVPacket.
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * Decompression timestamp in AVStream->time_base units; the time at which
     * the packet is decompressed.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     */
    dts = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    data = 0;
    size = 0;
    streamIndex = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * A combination of AV_PKT_FLAG values
     */
    flags = 0;
    /**
     * Additional packet data that can be provided by the container.
     * Packet can contain several types of side information.
     */
    sideData = 0;
    sideDataElems = 0;
    /**
     * Duration of this packet in AVStream->time_base units, 0 if unknown.
     * Equals next_pts - this_pts in presentation order.
     */
    duration = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    pos = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * for some private data of the user
     */
    opaque = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the packet is unreferenced. av_packet_copy_props() calls create a new
     * reference with av_buffer_ref() for the target packet's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * 编码时间基
     *
     * 封装时用户设置
     */
    timeBase = new _rational__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: _constant__WEBPACK_IMPORTED_MODULE_0__.AV_TIME_BASE, num: 1 });
    /**
     * 码流格式
     * 对于 h264/h265 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("dts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("streamIndex", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 36, 8: 0 });
    map.set("sideData", { 0: AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("sideDataElems", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("pos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("timeBase", { 0: _rational__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacket.prototype);
class AVPacketRef extends AVPacket {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 96);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacketRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpcmbuffer.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/avpcmbuffer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBuffer)
/* harmony export */ });
/* unused harmony export AVPCMBufferRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia AVPCMBuffer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class AVPCMBuffer {
    /**
     * pcm 数据
     * 可同时存放多个 channel 数据
     */
    data;
    /**
     * 当前存放了多少个采样点
     */
    nbSamples;
    /**
     * 当前 data 每个 channel 能存放的最大采样点数
     */
    maxnbSamples;
    /**
     * 声道数
     */
    channels;
    /**
     * 采样率
     */
    sampleRate;
    /**
     * pts
     */
    timestamp;
    /**
     * 时长
     */
    duration;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("maxnbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("timestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("duration", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 40);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVPCMBuffer.prototype);
class AVPCMBufferRef extends AVPCMBuffer {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVPCMBufferRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/rational.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/rational.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rational: () => (/* binding */ Rational)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia Rational defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Rational {
    /**
     * 分子
     */
    num = 1;
    /**
     * 分母
     */
    den = 1;
    constructor(init) {
        if (init) {
            this.den = init.den;
            this.num = init.num;
        }
    }
}
(function (prototype) {
    var map = new Map();
    map.set("num", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("den", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Rational.prototype);


/***/ }),

/***/ "./src/avutil/util/av1syntax.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/av1syntax.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ f),
/* harmony export */   uvlc: () => (/* binding */ uvlc)
/* harmony export */ });
/* unused harmony exports le, leb128, su, ns, L, NS */
/*
 * libmedia av1 syntax util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function f(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function uvlc(bitReader) {
    let leadingZeros = 0;
    while (true) {
        let done = f(bitReader, 1);
        if (done) {
            break;
        }
        leadingZeros++;
    }
    if (leadingZeros >= 32) {
        return (1) - 1;
    }
    const value = f(bitReader, leadingZeros);
    return value + (1 << leadingZeros) - 1;
}
function le(bitReader, n) {
    let t = 0;
    for (let i = 0; i < n; i++) {
        let byte = f(bitReader, 8);
        t += (byte << (i * 8));
    }
    return t;
}
function leb128(bitReader) {
    let value = 0;
    let Leb128Bytes = 0;
    for (let i = 0; i < 8; i++) {
        let leb128Byte_ = f(bitReader, 8);
        value |= ((leb128Byte_ & 0x7f) << (i * 7));
        Leb128Bytes += 1;
        if (!(leb128Byte_ & 0x80)) {
            break;
        }
    }
    return value;
}
function su(bitReader, n) {
    let value = f(bitReader, n);
    let signMask = 1 << (n - 1);
    if (value & signMask) {
        value = value - 2 * signMask;
    }
    return value;
}
function ns(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = f(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = f(bitReader, 1);
    return (v << 1) - m + extraBit;
}
function L(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function NS(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = L(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = L(bitReader, 1);
    return (v << 1) - m + extraBit;
}


/***/ }),

/***/ "./src/avutil/util/avbuffer.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avbuffer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avbufferCreate: () => (/* binding */ avbufferCreate),
/* harmony export */   avbufferRealloc: () => (/* binding */ avbufferRealloc),
/* harmony export */   avbufferRef: () => (/* binding */ avbufferRef),
/* harmony export */   avbufferReplace: () => (/* binding */ avbufferReplace),
/* harmony export */   avbufferUnref: () => (/* binding */ avbufferUnref)
/* harmony export */ });
/* unused harmony exports bufferCreate, avbufferAlloc, avbufferAllocz, bufferReplace, avbufferIsWritable, avbufferGetOpaque, avbufferGetRefCount, avbufferMakeWritable, bufferPoolFlush, bufferPoolFree, poolReleaseBuffer */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");





/*
 * libmedia avbuffer util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_FLAG_REALLOCATABLE = 1;
function bufferCreate(buf, data, size, free = 0, opaque = 0, flags = 0) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 4, size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 12, free);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 16, opaque);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.store(buf + 8, 1, 9, 2);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 20, flags);
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(12);
    if (!ref) {
        return 0;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref, buf);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref + 4, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](ref + 8, size);
    return ref;
}
function avbufferCreate(data, size, free = 0, opaque = 0, flags = 0) {
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(28);
    if (!buf) {
        return 0;
    }
    const ref = bufferCreate(buf, data, size, free, opaque, flags);
    if (!ref) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
        return 0;
    }
    return ref;
}
function avbufferAlloc(size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMalloc)(size);
    return avbufferCreate(data, size);
}
function avbufferAllocz(size) {
    const p = avbufferAlloc(size);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](p + 4), 0, size);
    return p;
}
function avbufferRef(buf) {
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(12);
    // @ts-ignore
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(ref, buf, 12);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.add(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 1, 9, 2);
    return ref;
}
function bufferReplace(dst, src) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst));
    if (src) {
        // @ts-ignore
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src), 12);
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(src);
    }
    else {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(dst);
    }
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.sub(buf + 8, 1, 9, 2) === 1) {
        const freeAvbuffer = !(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 24) & 2 /* BufferFlags.BUFFER_FLAG_NO_FREE */);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        if (freeAvbuffer) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
        }
    }
}
function avbufferUnref(buf) {
    if (!buf || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf)) {
        return;
    }
    bufferReplace(buf, 0);
}
function avbufferIsWritable(buf) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 20) & 1 /* AVBufferFlags.READONLY */) {
        return 0;
    }
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 9, 2) === 1 ? 1 : 0;
}
function avbufferGetOpaque(buf) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 16);
}
function avbufferGetRefCount(buf) {
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 9, 2);
}
function avbufferMakeWritable(pbuf) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pbuf);
    if (!buf) {
        return -1;
    }
    if (avbufferIsWritable(buf)) {
        return 0;
    }
    const newbuf = avbufferAlloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 8));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](newbuf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 8));
    let newbufp = cheap_stack__WEBPACK_IMPORTED_MODULE_5__.malloc(4);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](newbufp, newbuf);
    bufferReplace(pbuf, newbufp);
    cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
    return 0;
}
function avbufferReplace(pdst, src) {
    const dst = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst);
    if (!src) {
        avbufferUnref(pdst);
        return 0;
    }
    if (dst && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst + 4) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src + 4)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](src + 8));
        return 0;
    }
    const tmp = avbufferRef(src);
    avbufferUnref(pdst);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pdst, tmp);
    return 0;
}
function avbufferRealloc(pdst, size) {
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst)) {
        const data = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avRealloc)(0, size);
        const buf = avbufferCreate(data, size);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pdst, buf);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 24) | BUFFER_FLAG_REALLOCATABLE);
        return 0;
    }
    const ref = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst);
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](ref);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](ref + 8) === size) {
        return 0;
    }
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 24) & BUFFER_FLAG_REALLOCATABLE)
        || !avbufferIsWritable(ref)
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](ref + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf)) {
        let newRef = cheap_stack__WEBPACK_IMPORTED_MODULE_5__.malloc(4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](newRef, 0);
        const ret = avbufferRealloc(newRef, size);
        if (ret < 0) {
            cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
            return ret;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](newRef) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf), Math.min(size, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 4)));
        bufferReplace(pdst, newRef);
        cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
        return 0;
    }
    const tmp = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avRealloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf), size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref + 4, tmp), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf, tmp);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](ref + 8, size), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 4, size);
    return 0;
}
function bufferPoolFlush(pool) {
    while (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4)) {
        const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pool + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
    }
}
function bufferPoolFree(pool) {
    bufferPoolFlush(pool);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.destroy(pool);
    (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(pool);
}
function poolReleaseBuffer(opaque, data) {
    const buf = opaque;
    const pool = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 12);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.lock(pool);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pool + 4, buf);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.unlock(pool);
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.sub(pool + 8, 1, 9, 2) === 1) {
        bufferPoolFree(pool);
    }
}


/***/ }),

/***/ "./src/avutil/util/avdict.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/avdict.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   freeAVDict: () => (/* binding */ freeAVDict)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");



function freeAVDict(pm) {
    const m = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pm);
    if (m) {
        while (cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) - 1), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8);
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4);
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(m + 4);
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(pm);
}


/***/ }),

/***/ "./src/avutil/util/avframe.ts":
/*!************************************!*\
  !*** ./src/avutil/util/avframe.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVFrame: () => (/* binding */ createAVFrame),
/* harmony export */   destroyAVFrame: () => (/* binding */ destroyAVFrame),
/* harmony export */   getAVFrameDefault: () => (/* binding */ getAVFrameDefault),
/* harmony export */   getAVFrameSideData: () => (/* binding */ getAVFrameSideData),
/* harmony export */   unrefAVFrame: () => (/* binding */ unrefAVFrame)
/* harmony export */ });
/* unused harmony exports freeSideData, wipeSideData, getVideoBuffer, getAudioBuffer, getBuffer, refAVFrame, copyAVFrameProps, cloneAVFrame */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");
/* harmony import */ var _avdict__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");






/*
 * libmedia avframe util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */








function createAVFrame() {
    const frame = (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(360);
    getAVFrameDefault(frame);
    return frame;
}
function destroyAVFrame(frame) {
    unrefAVFrame(frame);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(frame);
}
function freeSideData(ptr) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ptr);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(sideData + 16);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_3__.freeAVDict)(sideData + 12);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(ptr);
}
function wipeSideData(frame) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 228); i++) {
        freeSideData(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 224) + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 228, 0);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 224);
}
function getAVFrameSideData(frame, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 228); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 224) + i * 4)) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 224) + (i * 4));
        }
    }
    return 0;
}
function getAVFrameDefault(frame) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) !== frame) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 64);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(frame, 0, 360);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 104, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 112, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 256, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 272, BigInt(0));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 264, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 292, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 84, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 92, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 96, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 80, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 64, frame);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 240, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 244, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 248, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 236, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 252, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 232, 0);
}
function getVideoBuffer(frame, algin) {
}
function getAudioBuffer(frame, algin) {
}
function getBuffer(frame, algin) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80) < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_7__.INVALID_ARGUMENT;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68) > 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) > 0) {
        return getVideoBuffer(frame, algin);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76) > 0 && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[10](frame + 336) || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 332) > 0)) {
        return getAudioBuffer(frame, algin);
    }
    return _error__WEBPACK_IMPORTED_MODULE_7__.INVALID_ARGUMENT;
}
function refAVFrame(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 328, src + 328, 24);
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 288, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 288));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[10](dst + 176, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[10](src + 176));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    let ret = copyAVFrameProps(dst, src);
    if (ret < 0) {
        return ret;
    }
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 184)) {
        for (let i = 0; i < 8; i++) {
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i))) {
                continue;
            }
            let size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + i * 4, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(size));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)), size);
        }
        return 0;
    }
    for (let i = 0; i < 8; i++) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 184 + 4 * (i))) {
            continue;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 184 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 184 + 4 * (i))));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 184 + 4 * (i))) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 216)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 216, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(4 * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 216)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 220, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 216) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 216) + (i * 4))));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 216) + (i * 4))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
            }
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64) !== src) {
        let ch = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 332);
        if (!ch) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_7__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(4 * ch));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64), 4 * ch);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 64, dst);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst, src, 32);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 32, src + 32, 32);
    return 0;
}
function unrefAVFrame(frame) {
    wipeSideData(frame);
    for (let i = 0; i < (8); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 184 + i * 4);
    }
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 220); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 216) + (i * 4));
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 216);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_3__.freeAVDict)(frame + 280);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 296);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 300);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 320);
    getAVFrameDefault(frame);
}
function copyAVFrameProps(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 92, src + 92, 8);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 304, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 304));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 308, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 308));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 312, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 312));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 316, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 316));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 104));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 156, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 156));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 168, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 168));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 140));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 112));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 264, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 264));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 292, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 292));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 272, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 272));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 160));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 256, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 256));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 128));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 132, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 132));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 232, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 232));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 284, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 284));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 240, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 240));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 244, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 244));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 248, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 248));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 236, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 236));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 252, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 252));
    let ret = (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferReplace)(dst + 300, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 300));
    ret |= (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferReplace)(dst + 320, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 320));
    return ret;
}
function cloneAVFrame(frame) {
    const ret = createAVFrame();
    refAVFrame(ret, frame);
    return ret;
}


/***/ }),

/***/ "./src/avutil/util/avpacket.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avpacket.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAVPacketData: () => (/* binding */ addAVPacketData),
/* harmony export */   addAVPacketSideData: () => (/* binding */ addAVPacketSideData),
/* harmony export */   copyAVPacketData: () => (/* binding */ copyAVPacketData),
/* harmony export */   copyAVPacketProps: () => (/* binding */ copyAVPacketProps),
/* harmony export */   createAVPacket: () => (/* binding */ createAVPacket),
/* harmony export */   deleteAVPacketSideData: () => (/* binding */ deleteAVPacketSideData),
/* harmony export */   destroyAVPacket: () => (/* binding */ destroyAVPacket),
/* harmony export */   freeAVPacketSideData: () => (/* binding */ freeAVPacketSideData),
/* harmony export */   getAVPacketData: () => (/* binding */ getAVPacketData),
/* harmony export */   getAVPacketDefault: () => (/* binding */ getAVPacketDefault),
/* harmony export */   getAVPacketSideData: () => (/* binding */ getAVPacketSideData),
/* harmony export */   hasAVPacketSideData: () => (/* binding */ hasAVPacketSideData),
/* harmony export */   refAVPacket: () => (/* binding */ refAVPacket),
/* harmony export */   unrefAVPacket: () => (/* binding */ unrefAVPacket)
/* harmony export */ });
/* unused harmony exports initAVPacketData, copyAVPacketSideData */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");





/*
 * libmedia avpacket util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const AV_INPUT_BUFFER_PADDING_SIZE = 64;
function getAVPacketData(avpacket, safe) {
    return safe ? (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) : (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function initAVPacketData(avpacket, length) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(length));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, length);
    return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function getAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12);
        }
    }
    return 0;
}
function hasAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return true;
        }
    }
    return false;
}
function addAVPacketSideData(avpacket, type, data, length) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12, data);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 4, length);
            return;
        }
    }
    const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) + 1) * 12;
    const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(len);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44)) {
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
        }
    }
    const ele = sideData + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) * 12);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ele, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 8, type);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 4, length);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) + 1);
}
function deleteAVPacketSideData(avpacket, type) {
    let index = -1;
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            index = i;
            break;
        }
    }
    if (index > -1) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) === 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)));
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
        }
        else {
            const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1) * 12;
            const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(len);
            for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
                if (i !== index) {
                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
                }
                else {
                    (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
                }
            }
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1);
        }
    }
}
function createAVPacket() {
    const avpacket = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(88);
    getAVPacketDefault(avpacket);
    return avpacket;
}
function destroyAVPacket(avpacket) {
    unrefAVPacket(avpacket);
    (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(avpacket);
}
function freeAVPacketSideData(pSideData, pnbSideData) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pSideData);
    const nbSideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSideData);
    if (sideData) {
        for (let i = 0; i < nbSideData; i++) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(pSideData);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSideData, 0);
    }
}
function getAVPacketDefault(avpacket) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 32, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 56, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 48, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 36, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 16, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 8, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 80, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, 0);
}
function copyAVPacketSideData(dst, src) {
    freeAVPacketSideData(dst + 40, dst + 44);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)) {
        let size = 12;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 40, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(size * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 8));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4)));
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    }
}
function copyAVPacketProps(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 36));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 16));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 68, 0);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferReplace)(dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 68));
    copyAVPacketSideData(dst, src);
    return 0;
}
function allocAVPacket(buf, size) {
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRealloc)(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 4) + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return 0;
}
function refAVPacket(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    copyAVPacketProps(dst, src);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    return 0;
}
function unrefAVPacket(avpacket) {
    freeAVPacketSideData(avpacket + 40, avpacket + 44);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket + 68);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    getAVPacketDefault(avpacket);
}
function copyAVPacketData(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
}
function addAVPacketData(avpacket, data, size) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferCreate)(data, size + AV_INPUT_BUFFER_PADDING_SIZE));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, size);
}


/***/ }),

/***/ "./src/avutil/util/channel.ts":
/*!************************************!*\
  !*** ./src/avutil/util/channel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unInitChannelLayout: () => (/* binding */ unInitChannelLayout)
/* harmony export */ });
/* unused harmony export getChannelLayoutNBChannels */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");




function getChannelLayoutNBChannels(layout) {
    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.popCount64)(layout);
}
function unInitChannelLayout(channelLayout) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](channelLayout) == 2 /* AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM */) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(channelLayout + 8);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(channelLayout, 0, 24);
}


/***/ }),

/***/ "./src/avutil/util/codecparameters.ts":
/*!********************************************!*\
  !*** ./src/avutil/util/codecparameters.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyCodecParameters: () => (/* binding */ copyCodecParameters),
/* harmony export */   freeCodecParameters: () => (/* binding */ freeCodecParameters)
/* harmony export */ });
/* unused harmony export resetCodecParameters */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");












function copyCodecParametersSideData(pDst, pnbDst, src, nbSrc) {
    if (!src) {
        return;
    }
    const dst = (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(nbSrc * 12);
    for (let i = 0; i < nbSrc; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 8));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](dst + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4)));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + i * 12, src + i * 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pnbDst, nbSrc);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](pDst, dst);
    return 0;
}
function copyCodecParameters(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 20, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 20));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](src + 24));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 36));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 40, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 40));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 44));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 52, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 52));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 60, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 60));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 72));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 76));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 84));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 88));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + 136, src + 136, 24);
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](dst + 96, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[10](src + 96));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 104));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 108, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 108));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 112));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 116, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 116));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 120));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 124, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 124));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 128));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + 160, src + 160, 8);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 12)) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](dst + 12, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16));
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 168)) {
        copyCodecParametersSideData(dst + 168, dst + 172, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 168), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 172));
    }
}
function resetCodecParameters(par) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](par + 12)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(par + 12);
    }
    (0,_channel__WEBPACK_IMPORTED_MODULE_4__.unInitChannelLayout)(par + 136);
    (0,_avpacket__WEBPACK_IMPORTED_MODULE_5__.freeAVPacketSideData)(par + 168, par + 172);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(par, 0, 184);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par, -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 4, 0 /* AVCodecID.AV_CODEC_ID_NONE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 20, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 136, 0 /* AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 64, 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 68, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 72, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 76, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 80, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 84, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 56, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 60, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 160, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 160, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 40, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 44, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
}
function freeCodecParameters(par) {
    if (!par) {
        return;
    }
    resetCodecParameters(par);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(par);
}


/***/ }),

/***/ "./src/avutil/util/common.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/common.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   milliSecond2Second: () => (/* binding */ milliSecond2Second),
/* harmony export */   popCount64: () => (/* binding */ popCount64)
/* harmony export */ });
/* unused harmony export popCount */
/*
 * libmedia common util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F;
    x += x >> 8;
    return (x + (x >> 16)) & 0x3F;
}
function popCount64(x) {
    return popCount(Number(x & 0xffffffffn)) + popCount(Number(x >> BigInt(32) & 0xffffffffn));
}
function milliSecond2Second(time) {
    const integer = time / BigInt(1000);
    const decimal = time - integer * BigInt(1000);
    return Number(integer) + Number(decimal) / 1000;
}


/***/ }),

/***/ "./src/avutil/util/expgolomb.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/expgolomb.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSE: () => (/* binding */ readSE),
/* harmony export */   readUE: () => (/* binding */ readUE)
/* harmony export */ });
/* unused harmony exports readTE, writeUE, writeSE, writeTE */
/*
 * libmedia expgolomb util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const UESizeTable = [
    // 0 的二进制所需的比特个数
    1,
    // 1 的二进制所需的比特个数    
    1,
    // 2~3 的二进制所需的比特个数   
    2, 2,
    // 4~7 的二进制所需的比特个数
    3, 3, 3, 3,
    // 8~15 的二进制所需的比特个数
    4, 4, 4, 4, 4, 4, 4, 4,
    // 16~31 的二进制所需的比特个数
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    // 32~63 的二进制所需的比特个数
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    // 64~127 的二进制所需的比特个数
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // 128~255 的二进制所需的比特个数
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
];
/**
 * ue(v) 指数哥伦布解码
 */
function readUE(bitReader) {
    let result = 0;
    // leadingZeroBits
    let i = 0;
    while (i < 32 && bitReader.readU1() === 0) {
        i++;
    }
    // 计算 read_bits ( leadingZeroBits )
    result = bitReader.readU(i);
    // 计算 codeNum，1 << i 即为 2 的 i 次幂
    result += (1 << i) - 1;
    return result;
}
/**
 * se(v) 有符号指数哥伦布解码
 */
function readSE(bitReader) {
    let result = readUE(bitReader);
    // 判断 result 的奇偶性
    if (result & 0x01) {
        // 如果为奇数，说明编码前 > 0
        result = (result + 1) / 2;
    }
    else {
        // 如果为偶数，说明编码前 <= 0
        result = -result / 2;
    }
    return result;
}
/**
 * te(v) 截断指数哥伦布解码
 */
function readTE(bitReader, x) {
    let result = 0;
    // 判断取值上限
    if (x === 1) {
        // 如果为 1 则将读取到的比特值取反
        result = 1 - bitReader.readU1();
    }
    else if (x > 1) {
        // 否则按照 ue(v) 进行解码
        result = readUE(bitReader);
    }
    return result;
}
/**
 * ue(v) 指数哥伦布编码
 */
function writeUE(bitWriter, value) {
    let size = 0;
    if (value === 0) {
        // 0 直接编码为 1
        bitWriter.writeU1(1);
    }
    else {
        let tmp = ++value;
        // 判断所需比特个数是否大于 16 位
        if (tmp >= 0x00010000) {
            size += 16;
            tmp >>= 16;
        }
        // 判断此时所需比特个数是否大于 8 位
        if (tmp >= 0x100) {
            size += 8;
            tmp >>= 8;
        }
        // 最终 tmp 移位至 8 位以内，去查表
        size += UESizeTable[tmp];
        // 最终得出编码 value 所需的总比特数：2 * size - 1
        bitWriter.writeU(2 * size - 1, value);
    }
}
/**
 * se(v) 有符号指数哥伦布编码
 */
function writeSE(bitWriter, value) {
    if (value <= 0) {
        writeUE(bitWriter, -value * 2);
    }
    else {
        writeUE(bitWriter, value * 2 - 1);
    }
}
/**
 * te(v) 截断指数哥伦布编码
 */
function writeTE(bitWriter, x, value) {
    if (x === 1) {
        bitWriter.writeU1(1 & ~value);
    }
    else if (x > 1) {
        writeUE(bitWriter, value);
    }
}


/***/ }),

/***/ "./src/avutil/util/mem.ts":
/*!********************************!*\
  !*** ./src/avutil/util/mem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avFree: () => (/* binding */ avFree),
/* harmony export */   avFreep: () => (/* binding */ avFreep),
/* harmony export */   avMalloc: () => (/* binding */ avMalloc),
/* harmony export */   avMallocz: () => (/* binding */ avMallocz),
/* harmony export */   avRealloc: () => (/* binding */ avRealloc)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__1 = "src/avutil/util/mem.ts";



/*
 * libmedia mem util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function avMalloc(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('can not alloc buffer', cheap__fileName__1, 32);
    }
    return p;
}
function avMallocz(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('can not alloc buffer', cheap__fileName__1, 40);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(p, 0, len);
    return p;
}
function avFree(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
}
function avFreep(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](p));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](p, 0);
}
function avRealloc(p, size) {
    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(p, size);
}


/***/ }),

/***/ "./src/avutil/util/nalu.ts":
/*!*********************************!*\
  !*** ./src/avutil/util/nalu.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAnnexb: () => (/* binding */ isAnnexb),
/* harmony export */   naluUnescape: () => (/* binding */ naluUnescape),
/* harmony export */   splitNaluByStartCode: () => (/* binding */ splitNaluByStartCode)
/* harmony export */ });
/* unused harmony exports splitNaluByLength, joinNaluByStartCode, joinNaluByLength, naluEscape */
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia nalu util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function isAnnexb(data) {
    return data.length > 4
        && data[0] === 0
        && data[1] === 0
        && (data[2] === 1
            || data[2] === 0 && data[3] === 1);
}
function getNextNaluStart(data, offset) {
    let t = 0;
    for (let i = offset; i < data.length; i++) {
        switch (data[i]) {
            case 0:
                t++;
                break;
            case 1:
                if (t >= 2) {
                    return {
                        offset: i - Math.min(t, 3),
                        startCode: Math.min(t + 1, 4)
                    };
                }
                t = 0;
                break;
            default:
                t = 0;
        }
    }
    return {
        offset: -1,
        startCode: 0
    };
}
function splitNaluByStartCode(buffer) {
    const list = [];
    let offset = 0;
    let current = getNextNaluStart(buffer, offset);
    let next = {
        offset: -1,
        startCode: 0
    };
    while (next = getNextNaluStart(buffer, current.offset + current.startCode), next.offset > -1) {
        list.push(buffer.subarray(current.offset + current.startCode, next.offset, true));
        current = next;
    }
    list.push(buffer.subarray(current.offset + current.startCode, undefined, true));
    return list;
}
function splitNaluByLength(buffer, naluLengthSizeMinusOne) {
    const list = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](buffer);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = buffer.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length, true);
        bufferReader.skip(length);
        list.push(nalu);
    }
    return list;
}
function joinNaluByStartCode(nalus, output, slice = false) {
    if (!output) {
        let length = nalus.reduce((prev, nalu, index) => {
            return prev + ((index && slice) ? 3 : 4) + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index && slice) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function joinNaluByLength(nalus, naluLengthSizeMinusOne, output) {
    if (!output) {
        const length = nalus.reduce((prev, nalu) => {
            return prev + naluLengthSizeMinusOne + 1 + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (naluLengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function naluUnescape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const buffer = new Uint8Array(data.length);
    let zeroCount = 0;
    let pos = 0;
    for (let i = 0; i < data.length; i++) {
        if (i >= start && i < end) {
            if (data[i] === 0) {
                zeroCount++;
            }
            else {
                if (data[i] === 3 && zeroCount === 2 && i + 1 < data.length && data[i + 1] <= 3) {
                    i++;
                    if (i === data.length) {
                        break;
                    }
                    else {
                        if (data[i] === 0) {
                            zeroCount = 1;
                        }
                        else {
                            zeroCount = 0;
                        }
                    }
                }
                else {
                    zeroCount = 0;
                }
            }
        }
        buffer[pos++] = data[i];
    }
    return buffer.slice(0, pos);
}
function naluEscape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const indexes = [];
    let zeroCount = 0;
    for (let i = start; i < end; i++) {
        if (i >= end) {
            break;
        }
        if (data[i] === 0) {
            zeroCount++;
        }
        else {
            if (data[i] <= 3 && zeroCount === 2) {
                indexes.push(i);
            }
            zeroCount = 0;
        }
    }
    if (indexes.length) {
        const buffer = new Uint8Array(data.length + indexes.length);
        let pos = 0;
        let subData = data.subarray(0, indexes[0]);
        buffer.set(subData, pos);
        pos += subData.length;
        buffer[pos++] = 3;
        for (let i = 1; i < indexes.length; i++) {
            subData = data.subarray(indexes[i - 1], indexes[i]);
            buffer.set(subData, pos);
            pos += subData.length;
            buffer[pos++] = 3;
        }
        subData = data.subarray(indexes[indexes.length - 1], data.length);
        buffer.set(subData, pos);
        pos += subData.length;
        return buffer;
    }
    else {
        return data;
    }
}


/***/ }),

/***/ "./src/avutil/util/rational.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/rational.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avQ2D: () => (/* binding */ avQ2D),
/* harmony export */   avQ2D2: () => (/* binding */ avQ2D2),
/* harmony export */   avRescaleQ: () => (/* binding */ avRescaleQ)
/* harmony export */ });
/* unused harmony export avRescaleQ2 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");

/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ(a, bq, cq) {
    const b = a * BigInt(bq.num >>> 0) * BigInt(cq.den >>> 0);
    const c = BigInt(bq.den >>> 0) * BigInt(cq.num >>> 0);
    return b / c;
}
/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ2(a, bq, cq) {
    const b = a * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq + 4) >>> 0);
    const c = BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq + 4) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq) >>> 0);
    return b / c;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D(a) {
    return a.num / a.den;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D2(a) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4);
}


/***/ }),

/***/ "./src/cheap/allocator/AllocatorJS.ts":
/*!********************************************!*\
  !*** ./src/cheap/allocator/AllocatorJS.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AllocatorJS)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/cheap/allocator/AllocatorJS.ts";





const ALIGNMENT_IN_BYTES = 8;
const ALIGNMENT_MASK = ALIGNMENT_IN_BYTES - 1;
const POINTER_SIZE_IN_BYTES = 4;
const BYTES_TO_QUADS_SHIFT = 2;
const MIN_FREEABLE_SIZE_IN_BYTES = 16;
const MIN_FREEABLE_SIZE_IN_QUADS = bytesToQuads(MIN_FREEABLE_SIZE_IN_BYTES);
const MAX_HEIGHT = 32;
const HEADER_SIZE_IN_QUADS = 1 + (MAX_HEIGHT * 2);
const HEADER_OFFSET_IN_QUADS = 1;
const HEIGHT_OFFSET_IN_QUADS = 0;
const NEXT_OFFSET_IN_QUADS = 2;
const POINTER_SIZE_IN_QUADS = 1;
const POINTER_OVERHEAD_IN_QUADS = 2;
const FIRST_BLOCK_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS + POINTER_OVERHEAD_IN_QUADS;
const FIRST_BLOCK_OFFSET_IN_BYTES = FIRST_BLOCK_OFFSET_IN_QUADS * POINTER_SIZE_IN_BYTES;
const OVERHEAD_IN_BYTES = (FIRST_BLOCK_OFFSET_IN_QUADS + 1) * POINTER_SIZE_IN_BYTES;
class AllocatorJS {
    buffer;
    byteOffset;
    heapOffset;
    heapLength;
    int32Array;
    updates;
    options;
    shared;
    handles;
    constructor(options, init = true) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({
            growSize: 1048576,
            maxHeapSize: 2097152000
        }, options);
        this.handles = [];
        this.buffer = options.buffer;
        this.shared = false;
        if (this.options.memory || this.buffer instanceof ArrayBuffer || this.buffer instanceof SharedArrayBuffer) {
            this.byteOffset = options.byteOffset ?? 0;
            this.heapOffset = alignHeapOffset(this.byteOffset + quadsToBytes(MAX_HEIGHT), options.byteLength ?? this.buffer.byteLength);
            this.heapLength = alignHeapLength((options.byteLength ?? this.buffer.byteLength) - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
            this.updates = new Int32Array(this.buffer, this.byteOffset, MAX_HEIGHT);
            if (typeof SharedArrayBuffer === 'function' && this.buffer instanceof SharedArrayBuffer) {
                this.shared = true;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('Expected buffer to be an instance of Buffer or ArrayBuffer', cheap__fileName__0, 109);
        }
        if (init) {
            this.updates.fill(HEADER_OFFSET_IN_QUADS);
            prepare(this.int32Array);
            checkListIntegrity(this.int32Array);
        }
    }
    addUpdateHandle(handle) {
        if (!common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(this.handles, handle)) {
            this.handles.push(handle);
        }
    }
    removeUpdateHandle(handle) {
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.remove(this.handles, handle);
    }
    malloc_(size) {
        size = align(size, ALIGNMENT_MASK);
        if (size < MIN_FREEABLE_SIZE_IN_BYTES) {
            size = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        const minimumSize = bytesToQuads(size);
        const block = this.findFreeBlock(this.int32Array, minimumSize);
        if (block <= HEADER_OFFSET_IN_QUADS) {
            return 0;
        }
        const blockSize = readSize(this.int32Array, block);
        if (blockSize - (minimumSize + POINTER_OVERHEAD_IN_QUADS) >= MIN_FREEABLE_SIZE_IN_QUADS) {
            split(this.int32Array, block, minimumSize, blockSize, this.updates);
        }
        else {
            remove(this.int32Array, block, blockSize, this.updates);
        }
        return quadsToBytes(block) + this.heapOffset;
    }
    /**
     * Allocate a given number of bytes and return the offset.
     * If allocation fails, returns 0.
     */
    malloc(size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.malloc_(size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    calloc_(num, size) {
        let numberOfBytes = num * size;
        if (numberOfBytes < MIN_FREEABLE_SIZE_IN_BYTES) {
            numberOfBytes = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        else {
            numberOfBytes = align(numberOfBytes, ALIGNMENT_MASK);
        }
        const address = this.malloc_(numberOfBytes);
        if (address === 0) {
            // Not enough space
            return 0;
        }
        const offset = bytesToQuads(address);
        this.int32Array.subarray(offset, offset + numberOfBytes >> 2).fill(0);
        return address;
    }
    calloc(num, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.calloc_(num, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    realloc_(address, size) {
        if (address === 0) {
            return this.malloc_(size);
        }
        const originAddress = address;
        if (size === 0) {
            this.free_(originAddress);
            return 0;
        }
        address = address - this.heapOffset;
        let originBlock = bytesToQuads(address);
        let block = originBlock;
        let padding = 0;
        if (isAlign(this.int32Array, originBlock)) {
            block = this.int32Array[originBlock - 1];
            padding = originBlock - block;
        }
        const blockSize = readSize(this.int32Array, block) - padding;
        const minimumSize = bytesToQuads(align(size, ALIGNMENT_MASK));
        if (blockSize >= minimumSize) {
            return originAddress;
        }
        else {
            const newAddress = this.malloc_(size);
            if (newAddress === 0) {
                this.free_(originAddress);
                return 0;
            }
            this.int32Array.set(this.int32Array.subarray(originBlock, originBlock + blockSize), bytesToQuads(newAddress - this.heapOffset));
            this.free_(originAddress);
            return newAddress;
        }
    }
    realloc(address, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        address = this.realloc_(address, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    alignedAlloc_(alignment, size) {
        if (alignment <= ALIGNMENT_IN_BYTES) {
            // malloc 以 ALIGNMENT_IN_BYTES 字节对齐
            return this.malloc_(size);
        }
        const address = this.malloc_(size + alignment - 1 + POINTER_SIZE_IN_BYTES);
        if (address === 0) {
            return 0;
        }
        const alignmentAddress = (address + alignment - 1 + POINTER_SIZE_IN_BYTES) & ~(alignment - 1);
        this.int32Array[bytesToQuads(alignmentAddress - this.heapOffset) - POINTER_SIZE_IN_QUADS] = bytesToQuads(address - this.heapOffset);
        return alignmentAddress;
    }
    alignedAlloc(alignment, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.alignedAlloc_(alignment, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    free_(address) {
        if (address === 0) {
            return;
        }
        address = address - this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        if (isFree(this.int32Array, block)) {
            return;
        }
        const blockSize = readSize(this.int32Array, block);
        const preceding = getFreeBlockBefore(this.int32Array, block);
        const trailing = getFreeBlockAfter(this.int32Array, block);
        if (preceding !== 0) {
            if (trailing !== 0) {
                insertMiddle(this.int32Array, preceding, block, blockSize, trailing, this.updates);
            }
            else {
                insertAfter(this.int32Array, preceding, block, blockSize, this.updates);
            }
        }
        else if (trailing !== 0) {
            insertBefore(this.int32Array, trailing, block, blockSize, this.updates);
        }
        else {
            insert(this.int32Array, block, blockSize, this.updates);
        }
    }
    /**
     * Free a number of bytes from the given address.
     */
    free(address) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        this.free_(address);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
    }
    /**
     * Return the size of the block at the given address.
     */
    sizeof(address) {
        if (address === 0) {
            return 0;
        }
        address -= this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        return quadsToBytes(readSize(this.int32Array, block));
    }
    /**
     * 获取堆分配信息
     *
     * @returns
     */
    inspect() {
        this.checkBuffer();
        return inspect(this.int32Array, this.heapOffset);
    }
    findFreeBlock(int32Array, minimumSize) {
        let block = findFreeBlock(int32Array, minimumSize);
        if (block === HEADER_OFFSET_IN_QUADS) {
            if (this.options.growAllowed && this.heapLength < this.options.maxHeapSize) {
                const block = this.int32Array.length + 1;
                let int32Array;
                let updates;
                let byteOffset = 0;
                let heapLength = 0;
                let heapOffset = 0;
                if (this.options.onResize) {
                    const result = this.options.onResize(this.int32Array, this.int32Array.byteLength + align(Math.max(this.options.growSize, quadsToBytes(minimumSize)), ALIGNMENT_MASK));
                    byteOffset = result.byteOffset ?? 0;
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), result.byteLength ?? result.buffer.byteLength);
                    heapLength = alignHeapLength((result.byteLength ?? result.buffer.byteLength) - heapOffset);
                    int32Array = new Int32Array(result.buffer, heapOffset, bytesToQuads(heapLength));
                    updates = new Int32Array(result.buffer, byteOffset, MAX_HEIGHT);
                }
                else {
                    const buffer = new ArrayBuffer(this.int32Array.length + bytesToQuads(this.options.growSize));
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), buffer.byteLength);
                    heapLength = alignHeapLength(buffer.byteLength - heapOffset);
                    int32Array = new Int32Array(buffer, heapOffset, bytesToQuads(heapLength));
                    int32Array.set(this.int32Array, 0);
                    updates = new Int32Array(buffer, byteOffset, MAX_HEIGHT);
                }
                this.byteOffset = byteOffset;
                this.heapOffset = heapOffset;
                this.buffer = int32Array.buffer;
                this.heapLength = heapLength;
                this.int32Array = int32Array;
                this.updates = updates;
                const blockSize = int32Array.length - (block - 1) - POINTER_OVERHEAD_IN_QUADS;
                writeFreeBlockSize(int32Array, blockSize, block);
                const preceding = getFreeBlockBefore(int32Array, block);
                if (preceding !== 0) {
                    insertAfter(int32Array, preceding, block, blockSize, this.updates);
                }
                else {
                    insert(int32Array, block, blockSize, this.updates);
                }
                if (this.handles.length) {
                    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(this.handles, (func) => {
                        func(this.buffer);
                    });
                }
                return this.findFreeBlock(this.int32Array, minimumSize);
            }
            return block;
        }
        else {
            return block;
        }
    }
    getBuffer() {
        return this.buffer;
    }
    isAlloc(pointer) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const block = bytesToQuads(pointer - this.heapOffset);
        let next = this.int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS];
        // sometime get undefined from the last free node in v8
        // but it's is all right |=_=
        while (next && next !== HEADER_OFFSET_IN_QUADS) {
            if (block >= next && block < next + this.int32Array[next - POINTER_SIZE_IN_QUADS]) {
                if (this.shared) {
                    (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
                }
                return false;
            }
            next = this.int32Array[next + NEXT_OFFSET_IN_QUADS];
        }
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return true;
    }
    checkBuffer() {
        if (this.options.memory && this.options.memory.buffer !== this.buffer) {
            this.buffer = this.options.memory.buffer;
            this.heapLength = alignHeapLength(this.buffer.byteLength - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
        }
    }
}
/**
 * Prepare the given int32Array and ensure it contains a valid header.
 */
function prepare(int32Array) {
    if (!verifyHeader(int32Array)) {
        writeInitialHeader(int32Array);
    }
}
/**
 * Verify that the int32Array contains a valid header.
 */
function verifyHeader(int32Array) {
    return int32Array[HEADER_OFFSET_IN_QUADS - 1] === HEADER_SIZE_IN_QUADS
        && int32Array[HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS] === HEADER_SIZE_IN_QUADS;
}
/**
 * Write the initial header for an empty int32Array.
 */
function writeInitialHeader(int32Array) {
    const header = HEADER_OFFSET_IN_QUADS;
    const headerSize = HEADER_SIZE_IN_QUADS;
    const block = FIRST_BLOCK_OFFSET_IN_QUADS;
    const blockSize = int32Array.length - (header + headerSize + POINTER_OVERHEAD_IN_QUADS + POINTER_SIZE_IN_QUADS);
    writeFreeBlockSize(int32Array, headerSize, header);
    int32Array[header + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[header + NEXT_OFFSET_IN_QUADS] = block;
    for (let height = 1; height < MAX_HEIGHT; height++) {
        int32Array[header + NEXT_OFFSET_IN_QUADS + height] = HEADER_OFFSET_IN_QUADS;
    }
    writeFreeBlockSize(int32Array, blockSize, block);
    int32Array[block + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[block + NEXT_OFFSET_IN_QUADS] = header;
}
/**
 * Check the integrity of the freelist in the given array.
 */
function checkListIntegrity(int32Array) {
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length - FIRST_BLOCK_OFFSET_IN_QUADS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)} bytes).`, cheap__fileName__0, 564);
        }
        else if (isFree(int32Array, block)) {
            checkFreeBlockIntegrity(int32Array, block, size);
        }
        else {
            checkUsedBlockIntegrity(int32Array, block, size);
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return true;
}
function checkFreeBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 580);
    }
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    /* istanbul ignore if  */
    if (height < 1 || height > MAX_HEIGHT) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block ${quadsToBytes(block)} height must be between 1 and ${MAX_HEIGHT}, got ${height}.`, cheap__fileName__0, 585);
    }
    for (let i = 0; i < height; i++) {
        const pointer = int32Array[block + NEXT_OFFSET_IN_QUADS + i];
        /* istanbul ignore if  */
        if (pointer >= FIRST_BLOCK_OFFSET_IN_QUADS && !isFree(int32Array, pointer)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block ${quadsToBytes(block)} has a pointer to a non-free block (${quadsToBytes(pointer)}).`, cheap__fileName__0, 591);
        }
    }
    return true;
}
function checkUsedBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 600);
    }
    else {
        return true;
    }
}
/**
 * Inspect the freelist in the given array.
 */
function inspect(int32Array, byteOffset) {
    const blocks = [];
    const header = readListNode(int32Array, HEADER_OFFSET_IN_QUADS, byteOffset);
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    let used = 0;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)})`, cheap__fileName__0, 620);
        }
        if (isFree(int32Array, block)) {
            // @flowIssue todo
            blocks.push(readListNode(int32Array, block, byteOffset));
        }
        else {
            used += quadsToBytes(size);
            blocks.push({
                type: 'used',
                block: block,
                offset: quadsToBytes(block) + byteOffset,
                size: quadsToBytes(size)
            });
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return { header, blocks, total: quadsToBytes(int32Array.length), used };
}
/**
 * Convert quads to bytes.
 */
function quadsToBytes(num) {
    return num << BYTES_TO_QUADS_SHIFT;
}
/**
 * Convert bytes to quads.
 */
function bytesToQuads(num) {
    return num >>> BYTES_TO_QUADS_SHIFT;
}
/**
 * Align the given value to 8 bytes.
 */
function align(value, alignment) {
    return (value + alignment) & ~alignment;
}
/**
 * align heap
 *
 * @param offset heap start offset
 * @param byteLength  buffer length
 * @returns
 */
function alignHeapOffset(offset, byteLength) {
    const length = byteLength - offset;
    // 保证 heapLength 为 ALIGNMENT_IN_BYTES 对齐
    let heapOffset = offset + (align(length, ALIGNMENT_MASK) === length
        ? 0
        : (length - align(length, ALIGNMENT_MASK) + ALIGNMENT_IN_BYTES));
    return heapOffset;
}
function alignHeapLength(length) {
    // header 所占 int length 为奇数，则总长度也需要为奇数保证 body 为偶数
    if (!((HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS) % 2)) {
        length -= POINTER_SIZE_IN_BYTES;
    }
    return length;
}
/**
 * Read the list pointers for a given block.
 */
function readListNode(int32Array, block, byteOffset) {
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    const pointers = [];
    for (let i = 0; i < height; i++) {
        pointers.push(int32Array[block + NEXT_OFFSET_IN_QUADS + i]);
    }
    return {
        type: 'free',
        block,
        offset: quadsToBytes(block) + byteOffset,
        height,
        pointers,
        size: quadsToBytes(int32Array[block - 1])
    };
}
/**
 * Read the size (in quads) of the block at the given address.
 */
function readSize(int32Array, block) {
    const n = int32Array[block - 1];
    const mask = n >> 31;
    return (n + mask) ^ mask;
}
/**
 * Write the size of the block at the given address.
 * Note: This ONLY works for free blocks, not blocks in use.
 */
function writeFreeBlockSize(int32Array, size, block) {
    int32Array[block - 1] = size;
    int32Array[block + size] = size;
}
/**
 * Populate the `UPDATES` array with the offset of the last item in each
 * list level, *before* a node of at least the given size.
 */
function findPredecessors(int32Array, minimumSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let node = HEADER_OFFSET_IN_QUADS;
    for (let height = listHeight; height > 0; height--) {
        let next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        while (int32Array[next] >= FIRST_BLOCK_OFFSET_IN_QUADS && int32Array[int32Array[next] - 1] < minimumSize) {
            node = int32Array[next];
            next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        }
        UPDATES[height - 1] = node;
    }
}
/**
 * Find a free block with at least the given size and return its offset in quads.
 */
function findFreeBlock(int32Array, minimumSize) {
    let block = HEADER_OFFSET_IN_QUADS;
    for (let height = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS]; height > 0; height--) {
        let next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        while (next !== HEADER_OFFSET_IN_QUADS && int32Array[next - POINTER_SIZE_IN_QUADS] < minimumSize) {
            block = next;
            next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        }
    }
    block = int32Array[block + NEXT_OFFSET_IN_QUADS];
    if (block === HEADER_OFFSET_IN_QUADS) {
        return block;
    }
    else {
        return block;
    }
}
/**
 * Split the given block after a certain number of bytes and add the second half to the freelist.
 */
function split(int32Array, block, firstSize, blockSize, UPDATES) {
    const second = (block + firstSize + POINTER_OVERHEAD_IN_QUADS);
    const secondSize = (blockSize - (second - block));
    remove(int32Array, block, blockSize, UPDATES);
    int32Array[block - 1] = -firstSize;
    int32Array[block + firstSize] = -firstSize;
    int32Array[second - 1] = -secondSize;
    int32Array[second + secondSize] = -secondSize;
    insert(int32Array, second, secondSize, UPDATES);
}
/**
 * Remove the given block from the freelist and mark it as allocated.
 */
function remove(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    let node = int32Array[UPDATES[0] + NEXT_OFFSET_IN_QUADS];
    while (node !== block && node !== HEADER_OFFSET_IN_QUADS && int32Array[node - 1] <= blockSize) {
        for (let height = int32Array[node + HEIGHT_OFFSET_IN_QUADS] - 1; height >= 0; height--) {
            if (int32Array[node + NEXT_OFFSET_IN_QUADS + height] === block) {
                UPDATES[height] = node;
            }
        }
        node = int32Array[node + NEXT_OFFSET_IN_QUADS];
    }
    let listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    for (let height = 0; height < listHeight; height++) {
        const next = int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height];
        if (next !== block) {
            break;
        }
        int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height] = int32Array[block + NEXT_OFFSET_IN_QUADS + height];
    }
    while (listHeight > 0 && int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (listHeight - 1)] === HEADER_OFFSET_IN_QUADS) {
        listHeight--;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = listHeight;
    }
    // invert the size sign to signify an allocated block
    int32Array[block - 1] = -blockSize;
    int32Array[block + blockSize] = -blockSize;
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isFree(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const size = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (size < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isAlign(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const origin = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (origin < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Get the address of the block before the given one and return the address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockBefore(int32Array, block) {
    if (block <= FIRST_BLOCK_OFFSET_IN_QUADS) {
        return 0;
    }
    const beforeSize = int32Array[block - POINTER_OVERHEAD_IN_QUADS];
    if (beforeSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return block - (POINTER_OVERHEAD_IN_QUADS + beforeSize);
}
/**
 * Get the address of the block after the given one and return its address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockAfter(int32Array, block) {
    const blockSize = readSize(int32Array, block);
    if (block + blockSize + POINTER_OVERHEAD_IN_QUADS >= int32Array.length - 2) {
        // Block is the last in the list.
        return 0;
    }
    const next = (block + blockSize + POINTER_OVERHEAD_IN_QUADS);
    const nextSize = int32Array[next - POINTER_SIZE_IN_QUADS];
    if (nextSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return next;
}
/**
 * Insert the given block into the freelist and return the number of bytes that were freed.
 */
function insert(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    const blockHeight = generateHeight(int32Array, block, blockSize, UPDATES);
    for (let height = 1; height <= blockHeight; height++) {
        const update = UPDATES[height - 1] + NEXT_OFFSET_IN_QUADS + (height - 1);
        int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)] = int32Array[update];
        int32Array[update] = block;
        UPDATES[height - 1] = HEADER_OFFSET_IN_QUADS;
    }
    int32Array[block - 1] = blockSize;
    int32Array[block + blockSize] = blockSize;
    return blockSize;
}
/**
 * Insert the given block into the freelist before the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertBefore(int32Array, trailing, block, blockSize, UPDATES) {
    const trailingSize = readSize(int32Array, trailing);
    remove(int32Array, trailing, trailingSize, UPDATES);
    const size = (blockSize + trailingSize + POINTER_OVERHEAD_IN_QUADS);
    int32Array[block - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, block, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist in between the given free blocks,
 * joining them together, returning the number of bytes which were freed.
 */
function insertMiddle(int32Array, preceding, block, blockSize, trailing, UPDATES) {
    const precedingSize = readSize(int32Array, preceding);
    const trailingSize = readSize(int32Array, trailing);
    const size = ((trailing - preceding) + trailingSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    remove(int32Array, trailing, trailingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist after the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertAfter(int32Array, preceding, block, blockSize, UPDATES) {
    const precedingSize = (block - preceding) - POINTER_OVERHEAD_IN_QUADS;
    const size = ((block - preceding) + blockSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[block + blockSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Generate a random height for a block, growing the list height by 1 if required.
 */
function generateHeight(int32Array, block, blockSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let height = randomHeight();
    if (blockSize - 1 < height + 1) {
        height = blockSize - 2;
    }
    if (height > listHeight) {
        const newHeight = listHeight + 1;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (newHeight - 1)] = HEADER_OFFSET_IN_QUADS;
        UPDATES[newHeight] = HEADER_OFFSET_IN_QUADS;
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        return newHeight;
    }
    else {
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = height;
        return height;
    }
}
/**
 * Generate a random height for a new block.
 */
function randomHeight() {
    let height = 1;
    while (Math.random() < 0.5 && height < MAX_HEIGHT) {
        height += 1;
    }
    return height;
}


/***/ }),

/***/ "./src/cheap/allocator/Table.ts":
/*!**************************************!*\
  !*** ./src/cheap/allocator/Table.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebassemblyTable: () => (/* binding */ WebassemblyTable)
/* harmony export */ });
class WebassemblyTable {
    table;
    pointer;
    nodes;
    constructor() {
        this.table = new WebAssembly.Table({
            initial: 10,
            element: 'anyfunc'
        });
        this.pointer = 1;
        this.nodes = [{
                pointer: 1,
                length: 9,
                free: true
            }];
    }
    getPointer() {
        return this.pointer;
    }
    alloc(count) {
        let p = this.findFree(count);
        if (p < 0) {
            const last = this.nodes[this.nodes.length - 1];
            const length = count - (last.free ? last.length : 0);
            this.table.grow(length);
            if (last.free) {
                last.length = last.length + length;
            }
            else {
                this.nodes.push({
                    pointer: last.pointer + last.length,
                    length,
                    free: true
                });
            }
            p = this.findFree(count);
        }
        const node = this.nodes[p];
        if (node.length > count) {
            this.nodes.splice(p + 1, 0, {
                pointer: node.pointer + count,
                length: node.length - count,
                free: true
            });
            node.length = count;
        }
        node.free = false;
        return node.pointer;
    }
    free(pointer) {
        let p = this.findNode(pointer);
        const node = this.nodes[p];
        if (node && !node.free) {
            const before = this.nodes[p - 1];
            const after = this.nodes[p + 1];
            if (before && before.free) {
                if (after && after.free) {
                    before.length += (node.length + after.length);
                    this.nodes.splice(p, 2);
                }
                else {
                    before.length += node.length;
                    this.nodes.splice(p, 1);
                }
            }
            else {
                if (after && after.free) {
                    node.length += after.length;
                    this.nodes.splice(p + 1, 1);
                    node.free = true;
                }
                else {
                    node.free = true;
                }
            }
        }
    }
    get(index) {
        return this.table.get(index);
    }
    set(index, value) {
        if (index < 0 || index >= this.pointer) {
            throw new RangeError('index out of bound');
        }
        this.table.set(index, value);
    }
    inspect() {
        return this.nodes;
    }
    findFree(length) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].length >= length && this.nodes[i].free) {
                index = i;
                break;
            }
        }
        return index;
    }
    findNode(pointer) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].pointer === pointer) {
                index = i;
                break;
            }
        }
        return index;
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/asm/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* unused harmony exports instance, support */
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory.asm */ "./src/cheap/asm/memory.asm");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_memory_asm__WEBPACK_IMPORTED_MODULE_1__);
var cheap__fileName__0 = "src/cheap/asm/memory.ts";






/**
 * WebAssembly runtime 实例
 */
let instance;
function support() {
    return !!instance;
}
async function init(memory) {
    try {
        let wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_memory_asm__WEBPACK_IMPORTED_MODULE_1___default()));
        common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer);
        instance = (await WebAssembly.instantiate(wasm, {
            env: {
                memory
            }
        })).instance;
        (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.readU8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.readU8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.readU8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.readU8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.readU16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.readU16,
            [8 /* CTypeEnum.uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [9 /* CTypeEnum.atomic_uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [10 /* CTypeEnum.uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [22 /* CTypeEnum.atomic_uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [11 /* CTypeEnum.int8 */]: instance.exports.read8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.read8,
            [13 /* CTypeEnum.int16 */]: instance.exports.read16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.read16,
            [15 /* CTypeEnum.int32 */]: instance.exports.read32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.read32,
            [17 /* CTypeEnum.int64 */]: instance.exports.read64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.read64,
            [18 /* CTypeEnum.float */]: instance.exports.readf32,
            [19 /* CTypeEnum.double */]: instance.exports.readf64,
            [20 /* CTypeEnum.pointer */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            }
        });
        (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.write8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.write8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.write8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.write8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.write16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.write16,
            [8 /* CTypeEnum.uint32 */]: instance.exports.write32,
            [9 /* CTypeEnum.atomic_uint32 */]: instance.exports.write32,
            [10 /* CTypeEnum.uint64 */]: instance.exports.write64,
            [22 /* CTypeEnum.atomic_uint64 */]: instance.exports.write64,
            [11 /* CTypeEnum.int8 */]: instance.exports.write8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.write8,
            [13 /* CTypeEnum.int16 */]: instance.exports.write16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.write16,
            [15 /* CTypeEnum.int32 */]: instance.exports.write32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.write32,
            [17 /* CTypeEnum.int64 */]: instance.exports.write64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.write64,
            [18 /* CTypeEnum.float */]: instance.exports.writef32,
            [19 /* CTypeEnum.double */]: instance.exports.writef64,
            [20 /* CTypeEnum.pointer */]: instance.exports.write32
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.warn('memory asm not support, cannot use asm memory function', cheap__fileName__0, 96);
    }
}


/***/ }),

/***/ "./src/cheap/config.ts":
/*!*****************************!*\
  !*** ./src/cheap/config.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEAP_INITIAL: () => (/* binding */ HEAP_INITIAL),
/* harmony export */   HEAP_MAXIMUM: () => (/* binding */ HEAP_MAXIMUM),
/* harmony export */   HEAP_OFFSET: () => (/* binding */ HEAP_OFFSET),
/* harmony export */   STACK_ALIGNMENT: () => (/* binding */ STACK_ALIGNMENT),
/* harmony export */   STACK_SIZE: () => (/* binding */ STACK_SIZE),
/* harmony export */   USE_THREADS: () => (/* binding */ USE_THREADS)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");


/**
 * 是否使用多线程
 */
const USE_THREADS =  true && (common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].thread || false) && common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_DISABLE_PTHREAD !== true;
/**
 * 栈地址对齐
 * 栈地址至少是 16 字节对齐，因为 wasm 的基本类型中最大是 v128 16 字节
 */
let STACK_ALIGNMENT = 16;
/**
 * 栈大小，应为 STACK_ALIGNMENT 的整数倍
 */
let STACK_SIZE = 1048576;
/**
 * 堆保留段，可用于静态数据区分配
 */
const HEAP_OFFSET = 1024;
/**
 * 堆初始大小
 */
const HEAP_INITIAL = (common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_HEAP_INITIAL ?? 265);
/**
 * 堆最大大小
 */
const HEAP_MAXIMUM = 32768;


/***/ }),

/***/ "./src/cheap/ctypeEnumImpl.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumImpl.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/isLittleEndian */ "./src/common/function/isLittleEndian.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");



let getAllocator;
let getView;
const littleEndian = (0,common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__["default"])();
function writeU8(pointer, value) {
    getView().setUint8(pointer, value);
}
function readU8(pointer) {
    return getView().getUint8(pointer);
}
function writeU16(pointer, value) {
    getView().setUint16(pointer, value, littleEndian);
}
function readU16(pointer) {
    return getView().getUint16(pointer, littleEndian);
}
function writeU32(pointer, value) {
    getView().setUint32(pointer, value, littleEndian);
}
function readU32(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writeU64(pointer, value) {
    getView().setBigUint64(pointer, value, littleEndian);
}
function readU64(pointer) {
    return getView().getBigUint64(pointer, littleEndian);
}
function write8(pointer, value) {
    getView().setInt8(pointer, value);
}
function read8(pointer) {
    return getView().getInt8(pointer);
}
function write16(pointer, value) {
    getView().setInt16(pointer, value, littleEndian);
}
function read16(pointer) {
    return getView().getInt16(pointer, littleEndian);
}
function write32(pointer, value) {
    getView().setInt32(pointer, value, littleEndian);
}
function read32(pointer) {
    return getView().getInt32(pointer, littleEndian);
}
function write64(pointer, value) {
    getView().setBigInt64(pointer, value, littleEndian);
}
function read64(pointer) {
    return getView().getBigInt64(pointer, littleEndian);
}
function writef32(pointer, value) {
    getView().setFloat32(pointer, value, littleEndian);
}
function readf32(pointer) {
    return getView().getFloat32(pointer, littleEndian);
}
function writef64(pointer, value) {
    getView().setFloat64(pointer, value, littleEndian);
}
function readf64(pointer) {
    return getView().getFloat64(pointer, littleEndian);
}
function readPointer(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writePointer(pointer, value) {
    return getView().setUint32(pointer, value, littleEndian);
}
function init(getAllocator_, getView_) {
    getAllocator = getAllocator_;
    getView = getView_;
    (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.override)({
        [4 /* CTypeEnum.char */]: readU8,
        [5 /* CTypeEnum.atomic_char */]: readU8,
        [2 /* CTypeEnum.uint8 */]: readU8,
        [3 /* CTypeEnum.atomic_uint8 */]: readU8,
        [6 /* CTypeEnum.uint16 */]: readU16,
        [7 /* CTypeEnum.atomic_uint16 */]: readU16,
        [8 /* CTypeEnum.uint32 */]: readU32,
        [9 /* CTypeEnum.atomic_uint32 */]: readU32,
        [10 /* CTypeEnum.uint64 */]: readU64,
        [11 /* CTypeEnum.int8 */]: read8,
        [12 /* CTypeEnum.atomic_int8 */]: read8,
        [13 /* CTypeEnum.int16 */]: read16,
        [14 /* CTypeEnum.atomic_int16 */]: read16,
        [15 /* CTypeEnum.int32 */]: read32,
        [16 /* CTypeEnum.atomic_int32 */]: read32,
        [17 /* CTypeEnum.int64 */]: read64,
        [18 /* CTypeEnum.float */]: readf32,
        [19 /* CTypeEnum.double */]: readf64,
        [20 /* CTypeEnum.pointer */]: readPointer
    });
    (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.override)({
        [4 /* CTypeEnum.char */]: writeU8,
        [5 /* CTypeEnum.atomic_char */]: writeU8,
        [2 /* CTypeEnum.uint8 */]: writeU8,
        [3 /* CTypeEnum.atomic_uint8 */]: writeU8,
        [6 /* CTypeEnum.uint16 */]: writeU16,
        [7 /* CTypeEnum.atomic_uint16 */]: writeU16,
        [8 /* CTypeEnum.uint32 */]: writeU32,
        [9 /* CTypeEnum.atomic_uint32 */]: writeU32,
        [10 /* CTypeEnum.uint64 */]: writeU64,
        [11 /* CTypeEnum.int8 */]: write8,
        [12 /* CTypeEnum.atomic_int8 */]: write8,
        [13 /* CTypeEnum.int16 */]: write16,
        [14 /* CTypeEnum.atomic_int16 */]: write16,
        [15 /* CTypeEnum.int32 */]: write32,
        [16 /* CTypeEnum.atomic_int32 */]: write32,
        [17 /* CTypeEnum.int64 */]: write64,
        [18 /* CTypeEnum.float */]: writef32,
        [19 /* CTypeEnum.double */]: writef64,
        [20 /* CTypeEnum.pointer */]: writePointer
    });
}


/***/ }),

/***/ "./src/cheap/ctypeEnumRead.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumRead.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumRead: () => (/* binding */ CTypeEnumRead),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumRead = {
    [4 /* CTypeEnum.char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumRead, funcs);
}


/***/ }),

/***/ "./src/cheap/ctypeEnumWrite.ts":
/*!*************************************!*\
  !*** ./src/cheap/ctypeEnumWrite.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumWrite: () => (/* binding */ CTypeEnumWrite),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumWrite = {
    [4 /* CTypeEnum.char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumWrite, funcs);
}


/***/ }),

/***/ "./src/cheap/definedStruct.ts":
/*!************************************!*\
  !*** ./src/cheap/definedStruct.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definedStruct: () => (/* binding */ definedStruct),
/* harmony export */   revokeDefinedStruct: () => (/* binding */ revokeDefinedStruct)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");









function definedProperty(target, key, get, set) {
    Object.defineProperty(target, key, {
        get,
        set,
        configurable: true,
        enumerable: true
    });
}
/**
 * 指针的值
 *
 * @param address
 * @returns
 */
function getPointerValue(address) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address());
    };
}
function getStruct(target, key, address, struct) {
    return function () {
        return target[`__$__${key}`] || (target[`__$__${key}`] = definedStruct(address(), struct));
    };
}
function getCTypeEnumValue(address, type) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](address());
    };
}
function getBitFieldValue(address, type, bitLen, offset) {
    const shift = _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] * 8 - offset - bitLen;
    const valueMask = Math.pow(2, bitLen) - 1;
    return function () {
        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](address());
        return (value >>> shift) & valueMask;
    };
}
function setPointerValue(address) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[8 /* CTypeEnum.uint32 */](address(), newValue);
    };
}
function setStruct(obj, key, address, struct) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        const proxy = obj[localKey] || (obj[localKey] = definedStruct(address(), struct));
        common_util_object__WEBPACK_IMPORTED_MODULE_3__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setCTypeEnumValue(address, type) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](address(), newValue);
    };
}
function setBitFieldValue(address, type, bitLen, offset) {
    let zeroMask = 0;
    let len = _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] * 8;
    for (let i = 0; i < bitLen; i++) {
        zeroMask |= (1 << (len - 1 - (i + offset)));
    }
    const valueMask = Math.pow(2, bitLen) - 1;
    const shift = len - offset - bitLen;
    return function (newValue) {
        const addr = address();
        const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](addr);
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](addr, (value & ~zeroMask) | ((newValue & valueMask) << shift));
    };
}
function definedArrayStruct(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(i);
        definedProperty(obj, key, getStruct(obj, key, () => {
            return address() + size * i;
        }, type), setStruct(obj, key, () => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function definedArrayCTypeEnum(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(i);
        definedProperty(obj, key, getCTypeEnumValue(() => {
            return address() + size * i;
        }, type), setCTypeEnumValue(() => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function getArray(address, target, key) {
    return function () {
        const t = target[`__$__${key}`];
        t[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        return t;
    };
}
function setArrayStruct(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayStruct(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setArrayCTypeEnum(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayCTypeEnum(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function definedStruct(address, struct) {
    let prototype = common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                if (meta[3 /* KeyMetaKey.Array */]) {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getArray(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, obj, key), setArrayCTypeEnum(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[4 /* KeyMetaKey.ArrayLength */], 20 /* CTypeEnum.pointer */));
                    }
                    else {
                        if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.object(meta[0 /* KeyMetaKey.Type */])) {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayStruct(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                        else {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayCTypeEnum(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
                else {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }), setPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }));
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.object(meta[0 /* KeyMetaKey.Type */])) {
                        definedProperty(obj, key, getStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]), setStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            definedProperty(obj, key, getBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]), setBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]));
                        }
                        else {
                            definedProperty(obj, key, getCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]), setCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
    return obj;
}
function revokeDefinedStruct(target) {
    let prototype = Object.getPrototypeOf(target);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                delete target[key];
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
}


/***/ }),

/***/ "./src/cheap/function/definedMetaProperty.ts":
/*!***************************************************!*\
  !*** ./src/cheap/function/definedMetaProperty.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ definedMetaProperty)
/* harmony export */ });
function definedMetaProperty(target, key, value) {
    Object.defineProperty(target, key, {
        value,
        writable: false,
        enumerable: false,
        configurable: false
    });
}


/***/ }),

/***/ "./src/cheap/heap.ts":
/*!***************************!*\
  !*** ./src/cheap/heap.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Allocator: () => (/* binding */ Allocator),
/* harmony export */   Memory: () => (/* binding */ Memory),
/* harmony export */   StackPointer: () => (/* binding */ StackPointer),
/* harmony export */   StackTop: () => (/* binding */ StackTop),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   allocThreadId: () => (/* binding */ allocThreadId),
/* harmony export */   getHeap16: () => (/* binding */ getHeap16),
/* harmony export */   getHeap32: () => (/* binding */ getHeap32),
/* harmony export */   getHeap64: () => (/* binding */ getHeap64),
/* harmony export */   getHeap8: () => (/* binding */ getHeap8),
/* harmony export */   getHeapF32: () => (/* binding */ getHeapF32),
/* harmony export */   getHeapF64: () => (/* binding */ getHeapF64),
/* harmony export */   getHeapU16: () => (/* binding */ getHeapU16),
/* harmony export */   getHeapU32: () => (/* binding */ getHeapU32),
/* harmony export */   getHeapU64: () => (/* binding */ getHeapU64),
/* harmony export */   getHeapU8: () => (/* binding */ getHeapU8),
/* harmony export */   getView: () => (/* binding */ getView),
/* harmony export */   initThread: () => (/* binding */ initThread)
/* harmony export */ });
/* unused harmony exports ThreadId, isMainThread, ThreadName, StackSize, getAtomicsBuffer, initMain */
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./allocator/AllocatorJS */ "./src/cheap/allocator/AllocatorJS.ts");
/* harmony import */ var _allocator_Table__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./allocator/Table */ "./src/cheap/allocator/Table.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var _thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./thread/atomicsImpl */ "./src/cheap/thread/atomicsImpl.ts");
/* harmony import */ var _asm_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./asm/memory */ "./src/cheap/asm/memory.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumImpl */ "./src/cheap/ctypeEnumImpl.ts");
/* harmony import */ var common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");













/**
 * 线程 id
 */
let ThreadId = -1;
let isMainThread = true;
/**
 * 线程名
 */
let ThreadName = '';
/**
 * 当前线程的栈顶指针
 */
let StackPointer = null;
/**
 * 栈结束位置
 */
let StackTop = null;
/**
 * 当前线程栈大小
 */
let StackSize = 0;
/**
 * 当前线程的 Table
 */
let Table = null;
/**
 * 堆分配器
 */
let Allocator = null;
/**
 * 堆
 */
let Memory = null;
/**
 * 1 字节整型读取
 * - int8
 * - -128 to 127
 */
let Heap8 = null;
/**
 * 2 字节整型读取
 * - int16
 * - -32768 to 32767
 */
let Heap16 = null;
/**
 * 4 字节整型读取
 * - int32
 * - -2147483648 to 2147483647
 */
let Heap32 = null;
/**
 * 8 字节整型读取
 * - int64
 * - 0 to 4294967295
 */
let Heap64 = null;
/**
 * 1 字节无符号整型读取
 * - uint8
 * - 0 to 255
 */
let HeapU8 = null;
/**
 * 2 字节无符号整型读取
 * - uint16
 * - 0 to 65535
 */
let HeapU16 = null;
/**
 * 4 字节无符号整型读取
 * - uint32
 * - 0 to 4294967295
 */
let HeapU32 = null;
/**
 * 8 字节无符号整型读取
 * - uint64
 * - 0 to 4294967295
 */
let HeapU64 = null;
/**
 * 32 位浮点数
 * float
 */
let HeapFloat32 = null;
/**
 * 64 位浮点数
 * double
 */
let HeapFloat64 = null;
/**
 * 堆访问器
 */
let view = null;
let AtomicBufferMap = {
    [5 /* CTypeEnum.atomic_char */]: HeapU8,
    [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
    [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
    [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
    [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
    [12 /* CTypeEnum.atomic_int8 */]: Heap8,
    [14 /* CTypeEnum.atomic_int16 */]: Heap16,
    [16 /* CTypeEnum.atomic_int32 */]: Heap32,
    [21 /* CTypeEnum.atomic_int64 */]: Heap64
};
function checkHeap() {
    if (Memory && Memory.buffer !== HeapU8.buffer) {
        return true;
    }
    return false;
}
function getHeapU8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU8;
}
function getHeap8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap8;
}
function getHeapU16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU16;
}
function getHeap16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap16;
}
function getHeapU32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU32;
}
function getHeap32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap32;
}
function getHeap64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap64;
}
function getHeapU64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU64;
}
function getHeapF32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat32;
}
function getHeapF64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat64;
}
function getView() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return view;
}
function getAtomicsBuffer(type) {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return AtomicBufferMap[type];
}
function setAllocator(a) {
    if (Allocator) {
        Allocator.removeUpdateHandle(updateHeap);
    }
    Allocator = a;
    if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Allocator = Allocator;
    }
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
}
function updateHeap(heap) {
    Heap8 = new Int8Array(heap);
    Heap16 = new Int16Array(heap);
    Heap32 = new Int32Array(heap);
    Heap64 = new BigInt64Array(heap);
    HeapU8 = new Uint8Array(heap);
    HeapU16 = new Uint16Array(heap);
    HeapU32 = new Uint32Array(heap);
    HeapU64 = new BigUint64Array(heap);
    HeapFloat32 = new Float32Array(heap);
    HeapFloat64 = new Float64Array(heap);
    view = new DataView(heap);
    AtomicBufferMap = {
        [5 /* CTypeEnum.atomic_char */]: HeapU8,
        [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
        [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
        [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
        [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
        [12 /* CTypeEnum.atomic_int8 */]: Heap8,
        [14 /* CTypeEnum.atomic_int16 */]: Heap16,
        [16 /* CTypeEnum.atomic_int32 */]: Heap32,
        [21 /* CTypeEnum.atomic_int64 */]: Heap64
    };
}
function allocThreadId() {
    return Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, 1);
}
/**
 * 子线程初始化
 *
 * @param options
 */
async function initThread(options) {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__["default"])(getAtomicsBuffer);
    Memory = options.memory;
    const allocator = new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    }, false);
    setAllocator(allocator);
    if (options.stackPointer) {
        StackSize = options.stackSize;
        StackTop = options.stackPointer;
        StackPointer = new WebAssembly.Global({
            value: 'i32',
            mutable: true
        }, StackTop + StackSize);
        Table = new _allocator_Table__WEBPACK_IMPORTED_MODULE_6__.WebassemblyTable();
    }
    if (typeof options.id === 'number') {
        ThreadId = options.id;
    }
    else {
        ThreadId = Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, 1);
    }
    ThreadName = options.name ?? 'anonymous';
    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
        initThread,
        Allocator,
        Table,
        ThreadId,
        ThreadName,
        Memory,
        StackSize,
        StackTop,
        StackPointer,
        isMainThread: false
    };
    isMainThread = false;
    {
        if (!options.disableAsm) {
            // @ts-ignore
            if (typeof BigInt === 'function' && BigInt !== Number
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
                await (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
            }
            if ( true && _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
                await (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
            }
        }
    }
}
/**
 * 主线程初始化
 */
function initMain() {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__["default"])(getAtomicsBuffer);
    Memory = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Memory ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Memory : new WebAssembly.Memory({
        initial: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_INITIAL,
        maximum: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM,
        shared: _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
    });
    Allocator = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Allocator ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Allocator : new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    });
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
    StackSize = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackSize ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackSize : _config__WEBPACK_IMPORTED_MODULE_5__.STACK_SIZE;
    StackTop = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackTop ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackTop : Allocator.malloc(StackSize);
    StackPointer = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackPointer ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackPointer : new WebAssembly.Global({
        value: 'i32',
        mutable: true
    }, StackTop + StackSize);
    Table = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Table ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Table : new _allocator_Table__WEBPACK_IMPORTED_MODULE_6__.WebassemblyTable();
    ThreadId = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.ThreadId ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.ThreadId : 0;
    ThreadName = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.ThreadName ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.ThreadName : 'main';
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS && true) {
            Atomics.store(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, ThreadId + 1);
            Atomics.store(Heap32, _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex >>> 2, 0);
        }
        else {
            HeapU32[_staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2] = ThreadId + 1;
            let index = _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex >>> 2;
            Heap32[index] = 0;
        }
    }
    {
        // @ts-ignore
        if (typeof BigInt === 'function' && BigInt !== Number
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
            (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
        }
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
            && true
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
            (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
        }
    }
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
            Allocator,
            Table,
            ThreadId,
            ThreadName,
            Memory,
            StackSize,
            StackTop,
            StackPointer,
            isMainThread: true,
            threadCounter: _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter,
            heapMutex: _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex
        };
    }
    isMainThread = true;
}
{
    if (!(0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_10__["default"])() && !(0,common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__["default"])()) {
        initMain();
    }
    else {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
            initThread,
            isMainThread: false
        };
        isMainThread = false;
    }
}


/***/ }),

/***/ "./src/cheap/proxyStruct.ts":
/*!**********************************!*\
  !*** ./src/cheap/proxyStruct.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   proxyStruct: () => (/* binding */ proxyStruct),
/* harmony export */   revokeProxyStruct: () => (/* binding */ revokeProxyStruct)
/* harmony export */ });
/* unused harmony export findKeyMeta */
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/function/toNumber */ "./src/common/function/toNumber.ts");









const ObjectPro = Object.getPrototypeOf({});
function findKeyMeta(prototype, key) {
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta];
        if (keysMeta) {
            const meta = keysMeta.get(key);
            if (meta) {
                return meta;
            }
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype || prototype === ObjectPro) {
            return null;
        }
    }
}
function proxyArray(address, length, type, pointer) {
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__["default"])(pointer ? 20 /* CTypeEnum.pointer */ : type);
    const proxy = new Proxy(obj, {
        get(target, propertyKey, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress) {
                return target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__["default"])(propertyKey);
            if (pointer) {
                return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size);
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(type)) {
                    return target[propertyKey];
                }
                else {
                    return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[type](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size);
                }
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress) {
                target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = newValue;
                return true;
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__["default"])(propertyKey);
            if (pointer) {
                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, newValue);
                target[propertyKey] = newValue;
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(type)) {
                    const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, type));
                    common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                        proxy[key] = value;
                    });
                    target[propertyKey] = proxy;
                }
                else {
                    _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[type](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, newValue);
                    target[propertyKey] = newValue;
                }
            }
            return true;
        }
    });
    return proxy;
}
function proxyStruct(address, struct) {
    const prototype = common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    const { proxy, revoke } = Proxy.revocable(obj, {
        get(target, propertyKey, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const t = target[propertyKey];
                        t[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
                        return t;
                    }
                    else if (meta[1 /* KeyMetaKey.Pointer */]) {
                        let p = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address);
                        return p;
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(meta[0 /* KeyMetaKey.Type */])) {
                        return target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            value = ((value >>> (_typedef__WEBPACK_IMPORTED_MODULE_7__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8 - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */]))
                                & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1));
                        }
                        return value;
                    }
                }
                else {
                    return target[propertyKey];
                }
            }
            else {
                return target[propertyKey];
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const proxy = target[propertyKey] || proxyArray(address, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */], meta[1 /* KeyMetaKey.Pointer */]);
                        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
                            proxy[key] = value;
                        });
                        target[propertyKey] = proxy;
                    }
                    else {
                        if (meta[1 /* KeyMetaKey.Pointer */]) {
                            _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](address, newValue);
                            target[propertyKey] = newValue;
                        }
                        else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(meta[0 /* KeyMetaKey.Type */])) {
                            const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                                proxy[key] = value;
                            });
                            target[propertyKey] = proxy;
                        }
                        else {
                            if (meta[5 /* KeyMetaKey.BitField */]) {
                                let mask = 0;
                                let len = _typedef__WEBPACK_IMPORTED_MODULE_7__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8;
                                for (let i = 0; i < meta[6 /* KeyMetaKey.BitFieldLength */]; i++) {
                                    mask |= (1 << (len - 1 - (i + meta[8 /* KeyMetaKey.BaseBitOffset */])));
                                }
                                const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, (value & ~mask) | ((newValue & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1))
                                    << (len - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */])));
                            }
                            else {
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, newValue);
                            }
                            target[propertyKey] = newValue;
                        }
                    }
                }
                else {
                    target[propertyKey] = newValue;
                }
            }
            else {
                target[propertyKey] = newValue;
            }
            return true;
        }
    });
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructProxyRevoke] = revoke;
    return proxy;
}
function revokeProxyStruct(target) {
    const revoke = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructProxyRevoke];
    if (revoke) {
        revoke();
    }
}


/***/ }),

/***/ "./src/cheap/stack.ts":
/*!****************************!*\
  !*** ./src/cheap/stack.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   free: () => (/* binding */ free),
/* harmony export */   malloc: () => (/* binding */ malloc)
/* harmony export */ });
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heap */ "./src/cheap/heap.ts");

function malloc(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value -= size;
    return _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value;
}
function free(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value += size;
}


/***/ }),

/***/ "./src/cheap/staticData.ts":
/*!*********************************!*\
  !*** ./src/cheap/staticData.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heapMutex: () => (/* binding */ heapMutex),
/* harmony export */   threadCounter: () => (/* binding */ threadCounter)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/**
 * 静态分配区只能在此文件分配
 * 导出在其他地方使用
 */



/**
 * 静态分配区栈顶指针
 */
let pointer = (0) + 1;
function malloc(length, algin = 1) {
    let address = pointer;
    while (address % algin) {
        address = address + 1;
    }
    pointer = address + length;
    return address;
}
/**
 * 线程计数器地址
 */
const threadCounter = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.threadCounter
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.threadCounter
    : malloc(4, 4);
/**
 * 堆分配锁地址
 */
const heapMutex = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.heapMutex
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.heapMutex
    : malloc(4, 4);


/***/ }),

/***/ "./src/cheap/std/buffer/SafeUint8Array.ts":
/*!************************************************!*\
  !*** ./src/cheap/std/buffer/SafeUint8Array.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SafeUint8Array)
/* harmony export */ });
/* unused harmony export SafeBufferView */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/interface/ArrayLike */ "./src/common/interface/ArrayLike.ts");




class SafeBufferView {
    pointer;
    len;
    constructor(pointer, len) {
        this.pointer = pointer;
        this.len = len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    getFloat32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getFloat32(this.pointer + byteOffset, littleEndian);
    }
    getFloat64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getFloat64(this.pointer + byteOffset, littleEndian);
    }
    getInt8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt8(this.pointer + byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt16(this.pointer + byteOffset, littleEndian);
    }
    getInt32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt32(this.pointer + byteOffset, littleEndian);
    }
    getUint8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint8(this.pointer + byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint16(this.pointer + byteOffset, littleEndian);
    }
    getUint32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint32(this.pointer + byteOffset, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setFloat32(this.pointer + byteOffset, value, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setFloat64(this.pointer + byteOffset, value, littleEndian);
    }
    setInt8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt8(this.pointer + byteOffset, value);
    }
    setInt16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt16(this.pointer + byteOffset, value, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt32(this.pointer + byteOffset, value, littleEndian);
    }
    setUint8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint8(this.pointer + byteOffset, value);
    }
    setUint16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint16(this.pointer + byteOffset, value, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint32(this.pointer + byteOffset, value, littleEndian);
    }
    getBigInt64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getBigInt64(this.pointer + byteOffset, littleEndian);
    }
    getBigUint64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getBigUint64(this.pointer + byteOffset, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setBigInt64(this.pointer + byteOffset, value, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setBigUint64(this.pointer + byteOffset, value, littleEndian);
    }
}
class SafeUint8Array extends common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"] {
    pointer;
    len;
    constructor(pointer, len) {
        super();
        this.pointer = pointer;
        this.len = len;
        return this.proxy;
    }
    getIndexValue(index) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](this.pointer + index);
    }
    setIndexValue(index, value) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[2](this.pointer + index, value);
    }
    set(array, offset = 0) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(array, this.pointer + offset);
    }
    subarray(begin = 0, end, safe) {
        if (safe) {
            return new SafeUint8Array(this.pointer + begin, (end ? end : this.len) - begin);
        }
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(this.pointer + begin, this.pointer + (end ?? this.len));
    }
    slice(start = 0, end) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().slice(this.pointer + start, this.pointer + (end ?? this.len));
    }
    get length() {
        return this.len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    get view() {
        return new SafeBufferView(this.pointer, this.len);
    }
}


/***/ }),

/***/ "./src/cheap/std/collection/List.ts":
/*!******************************************!*\
  !*** ./src/cheap/std/collection/List.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../structAccess */ "./src/cheap/std/structAccess.ts");












class ListNode {
    prev;
    next;
    data;
}
(function (prototype) {
    var map = new Map();
    map.set("prev", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("next", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("data", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(ListNode.prototype);
class List {
    length = 0;
    head = 0;
    tail = 0;
    createNode(item, type, move = false) {
        const pNode = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(12);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 4, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode, 0);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.number(type)) {
            if (type === 20) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[type](p, item);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        else {
            if (move) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpy)(p, item[cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructAddress], (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        return pNode;
    }
    getItem(data, type) {
        let result;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.number(type)) {
            if (type === 20) {
                result = data;
            }
            else {
                result = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[type](data);
            }
        }
        else {
            result = (0,_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(data, type);
        }
        return result;
    }
    push(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.tail) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](this.tail + 4, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode, this.tail);
            this.tail = pNode;
        }
        this.length++;
    }
    pop(type) {
        const pNode = this.tail;
        let result = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode) + 4, 0);
            this.tail = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pNode);
        return result;
    }
    shift(type) {
        const pNode = this.head;
        let result = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 4), 0);
            this.head = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 4);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pNode);
        return result;
    }
    unshift(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.head) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](this.head, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 4, this.head);
            this.head = pNode;
        }
        this.length++;
    }
    forEach(callback, type) {
        if (!this.length) {
            return;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            if (callback(this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type), index) === false) {
                break;
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            index++;
        }
    }
    find(callback, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            const item = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type);
            if (callback(item, index) === true) {
                return item;
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            index++;
        }
        return 0;
    }
    indexOf(index, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let i = 0;
        while (current !== 0) {
            if (i === index) {
                return this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type);
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            i++;
        }
        return 0;
    }
    clear(callback, type) {
        if (this.length) {
            let current = this.head;
            while (current !== 0) {
                if (callback) {
                    callback(this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type));
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8));
                const next = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(current);
                current = next;
            }
        }
        this.head = 0, this.tail = 0;
        this.length = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("length", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("head", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("tail", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(List.prototype);


/***/ }),

/***/ "./src/cheap/std/make.ts":
/*!*******************************!*\
  !*** ./src/cheap/std/make.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ make)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_isDef__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structAccess */ "./src/cheap/std/structAccess.ts");







/**
 * 创建一个 struct 实例
 *
 * @param target
 * @returns
 */
function make(struct, init) {
    const size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__["default"])(struct);
    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
    if (!address) {
        throw new TypeError('cannot alloc memory for struct');
    }
    (0,_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(address, 0, size);
    const target = (0,_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(address, struct);
    const data = new struct();
    if (init) {
        common_util_object__WEBPACK_IMPORTED_MODULE_4__.extend(data, init);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(data, (value, key) => {
        if ((0,common_function_isDef__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
            target[key] = value;
        }
    });
    return target;
}


/***/ }),

/***/ "./src/cheap/std/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapSafeUint8Array: () => (/* binding */ mapSafeUint8Array),
/* harmony export */   mapUint16Array: () => (/* binding */ mapUint16Array),
/* harmony export */   mapUint8Array: () => (/* binding */ mapUint8Array),
/* harmony export */   memcpy: () => (/* binding */ memcpy),
/* harmony export */   memcpyFromUint8Array: () => (/* binding */ memcpyFromUint8Array),
/* harmony export */   memset: () => (/* binding */ memset)
/* harmony export */ });
/* unused harmony exports memmove, mapInt8Array, mapInt16Array, mapUint32Array, mapInt32Array, mapUint64Array, mapInt64Array, mapFloat32Array, mapFloat64Array, readCString, writeCString */
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string */ "./src/cheap/std/string.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");






function memcpy(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set((0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + size), dst);
}
function memcpyFromUint8Array(src, max, data) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(data.subarray(0, max), src);
}
function memmove(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().copyWithin(dst, src, src + size);
}
function memset(src, c, n) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n).fill(c);
}
function mapSafeUint8Array(src, n) {
    return _config__WEBPACK_IMPORTED_MODULE_1__.USE_THREADS ? mapUint8Array(src, n) : new _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_2__["default"](src, n);
}
function mapUint8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n);
}
function mapInt8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap8)().subarray(src, src + n);
}
function mapUint16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU16)().subarray(src >>> 1, src + (n * 2));
}
function mapInt16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap16)().subarray(src >>> 1, src + (n * 2));
}
function mapUint32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU32)().subarray(src >>> 2, src + (n * 4));
}
function mapInt32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap32)().subarray(src >>> 2, src + (n * 4));
}
function mapUint64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU64)().subarray(src >>> 3, src + (n * 8));
}
function mapInt64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap64)().subarray(src >>> 3, src + (n * 8));
}
function mapFloat32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF32)().subarray(src >>> 2, src + (n * 4));
}
function mapFloat64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF64)().subarray(src >>> 3, src + (n * 8));
}
function readCString(pointer, max) {
    const stringLen = (0,_string__WEBPACK_IMPORTED_MODULE_3__.strlen)(pointer);
    const len = Math.min(stringLen, max ?? stringLen);
    return common_util_text__WEBPACK_IMPORTED_MODULE_4__.decode(mapUint8Array(pointer, len));
}
function writeCString(dst, str, max, addNull = true) {
    const data = common_util_text__WEBPACK_IMPORTED_MODULE_4__.encode(str);
    let len = data.length;
    let remain = addNull ? 1 : 0;
    if (max && len - remain > max) {
        len = max - remain;
    }
    memcpyFromUint8Array(dst, len, data);
    if (addNull) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[11 /* CTypeEnum.int8 */](dst + len, 0);
    }
}


/***/ }),

/***/ "./src/cheap/std/sizeof.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/sizeof.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sizeof)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typedef */ "./src/cheap/typedef.ts");



function sizeof(type) {
    if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(type)) {
        return _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] || 0;
    }
    else if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(type) && type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct]) {
        return type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength];
    }
    return 0;
}


/***/ }),

/***/ "./src/cheap/std/string.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/string.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strlen: () => (/* binding */ strlen)
/* harmony export */ });
/* unused harmony exports strcpy, strcat, strcmp */
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");


/**
 * 获取字符串长度，不包括字符串末尾的空字符（\0）
 *
 * @param pointer
 */
function strlen(pointer) {
    let len = 0;
    while (_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */]((pointer = pointer + 1, pointer - 1))) {
        len++;
    }
    return len;
}
/**
 * 将一个字符串复制到另一个字符串
 *
 * @param destination
 * @param source
 */
function strcpy(destination, source) {
    const len = strlen(source) + 1;
    (0,_memory__WEBPACK_IMPORTED_MODULE_1__.memcpyFromUint8Array)(destination, len, (0,_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(source, len));
}
/**
 * 将一个字符串追加到另一个字符串的末尾
 *
 * @param destination
 * @param source
 */
function strcat(destination, source) {
    const len = strlen(source) + 1;
    const len1 = strlen(destination);
    (0,_memory__WEBPACK_IMPORTED_MODULE_1__.memcpyFromUint8Array)(destination + len1, len, (0,_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(source, len));
}
/**
 * 比较两个字符串的大小
 */
function strcmp(str1, str2) {
    const len1 = strlen(str1);
    const len2 = strlen(str2);
    const len = Math.min(len1, len2);
    for (let i = 0; i < len; i++) {
        const char1 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */](str1 + i);
        const char2 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */](str2 + i);
        if (char1 > char2) {
            return 1;
        }
        else if (char1 < char2) {
            return -1;
        }
    }
    if (len1 > len2) {
        return 1;
    }
    else if (len1 < len2) {
        return -1;
    }
    else {
        return 0;
    }
}


/***/ }),

/***/ "./src/cheap/std/structAccess.ts":
/*!***************************************!*\
  !*** ./src/cheap/std/structAccess.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ structAccess)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_keypath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/keypath */ "./src/common/util/keypath.ts");






/**
 * 访问 struct 指针
 *
 * @param target
 * @param address
 * @returns
 */
function structAccess(address, struct) {
    if (arguments[2] && common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(arguments[2])) {
        struct = struct.prototype;
        common_util_keypath__WEBPACK_IMPORTED_MODULE_1__.each(arguments[2], (key) => {
            const meta = struct[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta];
            struct = meta.get(key)[0 /* KeyMetaKey.Type */];
        });
    }
    return common_util_support__WEBPACK_IMPORTED_MODULE_3__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_4__.proxyStruct)(address, struct) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_5__.definedStruct)(address, struct);
}


/***/ }),

/***/ "./src/cheap/std/unmake.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/unmake.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unmake)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");





/**
 * 销毁一个 struct 实例，调用 make 创建的对象必须调用 unmake，否则内存泄漏
 *
 * @param target
 */
function unmake(target) {
    const p = target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress];
    if (p) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
        target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress] = 0;
        common_util_support__WEBPACK_IMPORTED_MODULE_2__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_3__.revokeProxyStruct)(target) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_4__.revokeDefinedStruct)(target);
    }
}


/***/ }),

/***/ "./src/cheap/symbol.ts":
/*!*****************************!*\
  !*** ./src/cheap/symbol.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   symbolStruct: () => (/* binding */ symbolStruct),
/* harmony export */   symbolStructAddress: () => (/* binding */ symbolStructAddress),
/* harmony export */   symbolStructKeysMeta: () => (/* binding */ symbolStructKeysMeta),
/* harmony export */   symbolStructLength: () => (/* binding */ symbolStructLength),
/* harmony export */   symbolStructMaxBaseTypeByteLength: () => (/* binding */ symbolStructMaxBaseTypeByteLength),
/* harmony export */   symbolStructProxyRevoke: () => (/* binding */ symbolStructProxyRevoke)
/* harmony export */ });
/* unused harmony exports symbolStructKeysQueue, symbolStructKeysInstance */
const symbolStruct = Symbol('Struct');
const symbolStructLength = Symbol('StructLength');
const symbolStructMaxBaseTypeByteLength = Symbol('StructMaxBaseTypeByteLength');
const symbolStructAddress = Symbol('StructAddress');
const symbolStructKeysQueue = Symbol('StructKeysQueue');
const symbolStructKeysMeta = Symbol('StructKeysMeta');
const symbolStructKeysInstance = Symbol('StructKeysInstance');
const symbolStructProxyRevoke = Symbol('StructProxyRevoke');


/***/ }),

/***/ "./src/cheap/thread/asm/atomics.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/asm/atomics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   isSupport: () => (/* binding */ isSupport)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atomics.asm */ "./src/cheap/thread/asm/atomics.asm");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_atomics_asm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../atomics */ "./src/cheap/thread/atomics.ts");
var cheap__fileName__0 = "src/cheap/thread/asm/atomics.ts";





/**
 * WebAssembly runtime 实例
 */
let instance;
function isSupport() {
    return !!instance;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_atomics_asm__WEBPACK_IMPORTED_MODULE_1___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            instance = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            return;
        }
        (0,_atomics__WEBPACK_IMPORTED_MODULE_3__.override)({
            add: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.add8(address, value) & 0xff);
                    case 12:
                        return instance.exports.add8(address, value);
                    case 14:
                        return instance.exports.add16(address, value);
                    case 7:
                        return (instance.exports.add16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.add32(address, value);
                    case 9:
                        return (instance.exports.add32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.add64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.add64(address, value));
                }
            },
            sub: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.sub8(address, value) & 0xff);
                    case 12:
                        return instance.exports.sub8(address, value);
                    case 14:
                        return instance.exports.sub16(address, value);
                    case 7:
                        return (instance.exports.sub16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.sub32(address, value);
                    case 9:
                        return (instance.exports.sub32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.sub64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.sub64(address, value));
                }
            },
            and: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.and8(address, value) & 0xff);
                    case 12:
                        return instance.exports.and8(address, value);
                    case 14:
                        return instance.exports.and16(address, value);
                    case 7:
                        return (instance.exports.and16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.and32(address, value);
                    case 9:
                        return (instance.exports.and32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.and64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.and64(address, value));
                }
            },
            or: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.or8(address, value) & 0xff);
                    case 12:
                        return instance.exports.or8(address, value);
                    case 14:
                        return instance.exports.or16(address, value);
                    case 7:
                        return (instance.exports.or16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.or32(address, value);
                    case 9:
                        return instance.exports.or32(address, value);
                    case 21:
                        return instance.exports.or64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.or64(address, value));
                }
            },
            xor: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.xor8(address, value) & 0xff);
                    case 12:
                        return instance.exports.xor8(address, value);
                    case 14:
                        return instance.exports.xor16(address, value);
                    case 7:
                        return (instance.exports.xor16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.xor32(address, value);
                    case 9:
                        return instance.exports.xor32(address, value);
                    case 21:
                        return instance.exports.xor64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.xor64(address, value));
                }
            },
            store: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 12:
                    case 3:
                        return instance.exports.store8(address, value);
                    case 14:
                    case 7:
                        return instance.exports.store16(address, value);
                    case 16:
                    case 9:
                        return instance.exports.store32(address, value);
                    case 21:
                    case 22:
                        return instance.exports.store64(address, value);
                }
            },
            load: function (address, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.load8(address) & 0xff);
                    case 12:
                        return instance.exports.load8(address);
                    case 14:
                        return instance.exports.load16(address);
                    case 7:
                        return instance.exports.load16(address);
                    case 16:
                        return instance.exports.load32(address);
                    case 9:
                        return (instance.exports.load32(address) & 0xffffffff);
                    case 21:
                        return instance.exports.load64(address);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.load64(address));
                }
            },
            compareExchange: function (address, expectedValue, replacementValue, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.compare_exchange8(address, expectedValue, replacementValue) & 0xff);
                    case 12:
                        return instance.exports.compare_exchange8(address, expectedValue, replacementValue);
                    case 14:
                        return instance.exports.compare_exchange16(address, expectedValue, replacementValue);
                    case 7:
                        return (instance.exports.compare_exchange16(address, expectedValue, replacementValue) & 0xffff);
                    case 16:
                        return instance.exports.compare_exchange32(address, expectedValue, replacementValue);
                    case 9:
                        return (instance.exports.compare_exchange32(address, expectedValue, replacementValue) & 0xffffffff);
                    case 21:
                        return instance.exports.compare_exchange64(address, expectedValue, replacementValue);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.compare_exchange64(address, expectedValue, replacementValue));
                }
            },
            exchange: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.exchange8(address, value) & 0xff);
                    case 12:
                        return instance.exports.exchange8(address, value);
                    case 14:
                        return instance.exports.exchange16(address, value);
                    case 7:
                        return (instance.exports.exchange16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.exchange32(address, value);
                    case 9:
                        return (instance.exports.exchange32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.exchange64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.exchange64(address, value));
                }
            },
            notify: function (address, count) {
                return instance.exports.notify(address, count);
            },
            wait: function (address, value) {
                return instance.exports.wait(address, value);
            },
            waitTimeout: function (address, value, timeout) {
                return instance.exports.waitTimeout(address, value, BigInt(timeout >>> 0));
            }
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.warn('atomics asm not support, cannot use asm atomics function', cheap__fileName__0, 284);
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomics.ts":
/*!*************************************!*\
  !*** ./src/cheap/thread/atomics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   and: () => (/* binding */ and),
/* harmony export */   compareExchange: () => (/* binding */ compareExchange),
/* harmony export */   exchange: () => (/* binding */ exchange),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   notify: () => (/* binding */ notify),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   wait: () => (/* binding */ wait),
/* harmony export */   waitAsync: () => (/* binding */ waitAsync),
/* harmony export */   waitTimeout: () => (/* binding */ waitTimeout),
/* harmony export */   waitTimeoutAsync: () => (/* binding */ waitTimeoutAsync),
/* harmony export */   xor: () => (/* binding */ xor)
/* harmony export */ });
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
let add;
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
let sub;
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
let and;
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
let or;
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
let xor;
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
let store;
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
let load;
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该元素原先的值
 *
 * 返回该位置的旧值
 *
 */
let compareExchange;
/**
 * 将指定位置的值更新为给定的值，并返回该元素更新前的值。
 *
 * 返回该位置的旧值
 *
 */
let exchange;
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量 0 将不会唤醒任何线程
 *
 */
let notify;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let wait;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时（毫秒）
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeout;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let waitAsync;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeoutAsync;
function override(funcs) {
    if (funcs.add) {
        add = funcs.add;
    }
    if (funcs.sub) {
        sub = funcs.sub;
    }
    if (funcs.and) {
        and = funcs.and;
    }
    if (funcs.or) {
        or = funcs.or;
    }
    if (funcs.xor) {
        xor = funcs.xor;
    }
    if (funcs.store) {
        store = funcs.store;
    }
    if (funcs.load) {
        load = funcs.load;
    }
    if (funcs.compareExchange) {
        compareExchange = funcs.compareExchange;
    }
    if (funcs.exchange) {
        exchange = funcs.exchange;
    }
    if (funcs.notify) {
        notify = funcs.notify;
    }
    if (funcs.wait) {
        wait = funcs.wait;
    }
    if (funcs.waitTimeout) {
        waitTimeout = funcs.waitTimeout;
    }
    if (funcs.waitAsync) {
        waitAsync = funcs.waitAsync;
    }
    if (funcs.waitTimeoutAsync) {
        waitTimeoutAsync = funcs.waitTimeoutAsync;
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomicsImpl.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/atomicsImpl.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");






let getAtomicsBuffer;
const useAtomics = _config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS || (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__["default"])() || (!common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].majorVersion, '94', true));
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
function add(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.add(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] += value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
function sub(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.sub(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] -= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
function and(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.and(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] &= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
function or(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.or(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] |= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
function xor(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.xor(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] ^= value;
        return old;
    }
}
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
function store(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.store(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
function load(address, type, shift) {
    if ( true && useAtomics) {
        return Atomics.load(getAtomicsBuffer(type), address >>> shift);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        return old;
    }
}
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该位置原先的值
 *
 * 返回该位置的旧值
 *
 */
function compareExchange(address, expectedValue, replacementValue, type, shift) {
    if ( true && useAtomics) {
        return Atomics.compareExchange(getAtomicsBuffer(type), address >>> shift, expectedValue, replacementValue);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        if (old === expectedValue) {
            buffer[index] = replacementValue;
        }
        return old;
    }
}
/**
 * 将指定位置的值更新为给定的值，并返回该位置更新前的值。
 *
 * 返回该位置的旧值
 *
 */
function exchange(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.exchange(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量
 *
 */
function notify(address, count) {
    if ( true && useAtomics) {
        return Atomics.notify(getAtomicsBuffer(16), address >>> 2, count);
    }
    else {
        return;
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
const waitMap = {
    'ok': 0,
    'not-equal': 1,
    'timed-out': 2
};
function wait(address, value) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
function waitTimeout(address, value, timeout) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value, timeout)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
async function waitAsync(address, value) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            while (load(address) === value) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__["default"])(() => {
                        resolve();
                    });
                });
            }
            return 0;
        }
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
async function waitTimeoutAsync(address, value, timeout) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value, timeout);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__["default"])();
            while (load(address) === value && ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__["default"])() - now < timeout)) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__["default"])(() => {
                        resolve();
                    });
                });
            }
            return load(address) !== value ? 0 : 2;
        }
    }
}
function init(getAtomicsBuffer_) {
    getAtomicsBuffer = getAtomicsBuffer_;
    (0,_atomics__WEBPACK_IMPORTED_MODULE_5__.override)({
        add,
        sub,
        and,
        or,
        xor,
        store,
        load,
        compareExchange,
        exchange,
        notify,
        wait,
        waitTimeout,
        waitAsync,
        waitTimeoutAsync
    });
}


/***/ }),

/***/ "./src/cheap/thread/cond.ts":
/*!**********************************!*\
  !*** ./src/cheap/thread/cond.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   broadcast: () => (/* binding */ broadcast),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Cond, waitAsync, timedwaitAsync */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");



/**
 * 参考 https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Cond {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Cond.prototype);
/**
 * 初始化条件变量
 */
function init(cond, attr) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 销毁条件变量
 */
function destroy(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 唤醒条件变量上的一个等待线程
 *
 * @param cond
 */
function signal(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(cond, 1);
    return 0;
}
/**
 * 唤醒条件变量上的所有等待线程
 *
 * @param cond
 */
function broadcast(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(cond, 1073741824);
    return 0;
}
/**
 * 线程在条件变量处等待
 *
 * @param cond
 * @param mutex
 * @returns
 */
function wait(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.wait(cond, c);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return 0;
}
/**
 * 线程在条件变量处异步等待
 *
 * @param cond
 * @param mutex
 */
async function waitAsync(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitAsync(cond, c);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return 0;
}
/**
 * 线程在条件变量处超时等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
function timedWait(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_2__.waitTimeout(cond, c, timeout);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return ret === 2 ? 110 : 0;
}
/**
 * 线程在条件变量处超时异步等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
async function timedwaitAsync(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitTimeoutAsync(cond, c, timeout);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return ret === 2 ? 110 : 0;
}


/***/ }),

/***/ "./src/cheap/thread/initClass.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/initClass.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let ipc;
    let target;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.func(target[method])) {
                try {
                    const transfer = [];
                    const result = await target[method](...params.params, transfer);
                    ipc.reply(data, result, null, transfer);
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                target = run(data.params);
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initFunction.ts":
/*!******************************************!*\
  !*** ./src/cheap/thread/initFunction.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let retval;
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                retval = run(data.params);
                break;
            case 'stop':
                if (retval && retval.then) {
                    retval.then((res) => {
                        parentPort.postMessage({
                            type: 'stopped',
                            data: res
                        });
                    });
                }
                else {
                    parentPort.postMessage({
                        type: 'stopped',
                        data: retval
                    });
                }
                break;
            default:
                console.log('default');
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initModule.ts":
/*!****************************************!*\
  !*** ./src/cheap/thread/initModule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(module) {
    let ipc;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.func(module[method])) {
                try {
                    const transfer = [];
                    const result = await module[method](...params.params, transfer);
                    ipc.reply(data, result, null, transfer);
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/mutex.ts":
/*!***********************************!*\
  !*** ./src/cheap/thread/mutex.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   lock: () => (/* binding */ lock),
/* harmony export */   lockAsync: () => (/* binding */ lockAsync),
/* harmony export */   unlock: () => (/* binding */ unlock)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");



/**
 * 参考 https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Mutex {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Mutex.prototype);
/**
 * 初始化锁
 *
 * @param mutex
 * @returns
 */
function init(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}
/**
 * 加锁
 *
 * @param mutex
 * @param spin 是否自旋
 */
function lock(mutex, spin = false) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                // 主线程不能 wait，直接自旋（需要注意所有线程各自的持锁时间，避免出现忙等占用大量 cpu 时间）
                if (!spin && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_3__["default"])()) {
                    _atomics__WEBPACK_IMPORTED_MODULE_2__.wait(mutex, 2 /* STATUS.WAITED */);
                }
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 异步加锁
 *
 * @param mutex
 */
async function lockAsync(mutex) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitAsync(mutex, 2 /* STATUS.WAITED */);
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 释放锁
 *
 * @param mutex
 */
function unlock(mutex) {
    let status = _atomics__WEBPACK_IMPORTED_MODULE_2__.sub(mutex, 1, 16, 2);
    // 此时拥有锁，状态为 LOCKED 或 WAITED
    if (status !== 1 /* STATUS.LOCKED */) {
        // 释放锁
        _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
        // 唤醒一个 wait 的线程
        _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(mutex, 1);
    }
    return 0;
}
/**
 * 销毁锁
 *
 * @param mutex
 * @returns
 */
function destroy(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}


/***/ }),

/***/ "./src/cheap/thread/semaphore.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/semaphore.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   post: () => (/* binding */ post),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   tryWait: () => (/* binding */ tryWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Sem, waitAsync, timedWaitAsync, set, get */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");








class Sem {
    atomic;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("mutex", { 0: _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(Sem.prototype);
/**
 * 初始化信号量
 *
 * @param sem
 * @param value 信号量初始值
 */
function init(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(sem, (value >> 0), 16, 2);
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.init(sem + 4);
    return 0;
}
function destroy(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.destroy(sem + 4);
    return 0;
}
/**
 * 生产信号量
 *
 * @param sem
 */
function post(sem) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_3__.notify(sem, 1);
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function wait(sem) {
    while (true) {
        _atomics__WEBPACK_IMPORTED_MODULE_3__.wait(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function tryWait(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.lock(sem + 4);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[16](sem) > 0) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[16](sem, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[16](sem) - 1);
        _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.unlock(sem + 4);
        return 0;
    }
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.unlock(sem + 4);
    return 11;
}
/**
 * 消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 * @returns
 */
function timedWait(sem, timeout) {
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_3__.waitTimeout(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
/**
 * 异步消费信号量
 *
 * @param sem
 */
async function waitAsync(sem) {
    while (true) {
        await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitAsync(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 异步消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 */
async function timedWaitAsync(sem, timeout) {
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitTimeoutAsync(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
function set(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(sem, value, 16, 2);
    return 0;
}
function get(sem) {
    return _atomics__WEBPACK_IMPORTED_MODULE_3__.load(sem, 16, 2);
}


/***/ }),

/***/ "./src/cheap/thread/thread.ts":
/*!************************************!*\
  !*** ./src/cheap/thread/thread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeThread: () => (/* binding */ closeThread),
/* harmony export */   createThreadFromClass: () => (/* binding */ createThreadFromClass)
/* harmony export */ });
/* unused harmony exports createThreadFromFunction, createThreadFromModule, joinThread */
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");










// @ts-ignore
let Worker = common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.Worker;
// @ts-ignore
let MessageChannel = common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.MessageChannel;
{
    // 保证打包工具可以包含下面的模块代码
    __webpack_require__(/*! ./initClass */ "./src/cheap/thread/initClass.ts");
    __webpack_require__(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts");
    __webpack_require__(/*! ./initModule */ "./src/cheap/thread/initModule.ts");
}
const initClass =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initClass */ "./src/cheap/thread/initClass.ts"), {
    varName: 'init'
}) : 0;
const initFunction =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts"), {
    varName: 'init'
}) : 0;
const initModule =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initModule */ "./src/cheap/thread/initModule.ts"), {
    varName: 'init'
}) : 0;
const symbolRevoke = Symbol('revoke');
const caches = new Map();
function getCacheKey(moduleId, type) {
    return `${moduleId}_${type}`;
}
function createThreadFromClass(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'class');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name,
                        exportIsClass: true
                    });
                    const source = `
            ${module}
            function run(params) {
              params.unshift(null)
              return new (Function.prototype.bind.apply(__module_${entity.name}__.__${entity.name}__, params))()
            }
            ${initClass}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'class'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2,
                                    params: args
                                }
                            }, [channel.port2, ...transferData]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        const worker = new entity(...args);
        return new Promise((resolve) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: 0,
                $instance: worker,
                $type: 'class'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                        const call = function (...args) {
                            return worker[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return worker[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromFunction(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'function');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name
                    });
                    const source = `
            ${module}
            function run(params) {
              return __module_${entity.name}__.__${entity.name}__.apply(${ false ? 0 : 'self'}, params)
            }
            ${initFunction}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const obj = {
                        $worker: worker,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'function'
                    };
                    resolve(obj);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    params: args
                                }
                            }, transferData);
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: null,
                $type: 'function'
            };
            resolve(obj);
            obj.$retval = new Promise((resolve) => {
                resolve(entity(...args));
            });
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromModule(entity, options = {}, moduleId) {
    let runInWorker;
    {
        runInWorker = () => {
            let worker;
            let moduleName = `__module_${moduleId}__`.replace(/\.|\//g, '_');
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'module');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: moduleName
                    });
                    const source = `
            ${module}
            ${initModule}
            init.default(${moduleName});
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'module'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2
                                }
                            }, [channel.port2]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || moduleName,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain() {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: 0,
                $instance: entity,
                $type: 'module'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                        const call = function (...args) {
                            return entity[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return entity[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
    };
}
function closeThread(thread) {
    if (thread.$worker) {
        thread.$worker.terminate();
        thread.$worker = null;
    }
    if (thread.$moduleId) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.string(thread.$moduleId)) {
            const cacheKey = getCacheKey(thread.$moduleId, thread.$type);
            if (caches.has(cacheKey)) {
                caches.get(cacheKey).refCount--;
                if (caches.get(cacheKey).refCount === 0) {
                    {
                        URL.revokeObjectURL(caches.get(cacheKey).url);
                    }
                    caches.delete(cacheKey);
                }
            }
        }
        thread.$moduleId = null;
    }
    if (thread.$ipc) {
        thread.$ipc.destroy();
        thread.$ipc = null;
    }
    if (thread.$stackPointer) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.$stackPointer);
        thread.$stackPointer = 0;
    }
    thread.$channel = null;
    thread.$instance = null;
    if (thread[symbolRevoke]) {
        const revoke = thread[symbolRevoke];
        thread[symbolRevoke] = null;
        revoke();
    }
}
async function joinThread(thread) {
    if (thread.$worker) {
        return new Promise((resolve) => {
            function handler(message) {
                const origin =  false ? 0 : message.data;
                const type = origin.type;
                const data = origin.data;
                switch (type) {
                    case 'stopped':
                        closeThread(thread);
                        resolve(data);
                        break;
                    default:
                        break;
                }
            }
            {
                thread.$worker.onmessage = handler;
            }
            thread.$worker.postMessage({
                type: 'stop'
            });
        });
    }
    else if (thread.$retval) {
        return thread.$retval;
    }
}


/***/ }),

/***/ "./src/cheap/typedef.ts":
/*!******************************!*\
  !*** ./src/cheap/typedef.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnum2Bytes: () => (/* binding */ CTypeEnum2Bytes),
/* harmony export */   CTypeEnumPointerShiftMap: () => (/* binding */ CTypeEnumPointerShiftMap)
/* harmony export */ });
const CTypeEnum2Bytes = {
    [2 /* CTypeEnum.uint8 */]: 1,
    [3 /* CTypeEnum.atomic_uint8 */]: 1,
    [4 /* CTypeEnum.char */]: 1,
    [5 /* CTypeEnum.atomic_char */]: 1,
    [6 /* CTypeEnum.uint16 */]: 2,
    [7 /* CTypeEnum.atomic_uint16 */]: 2,
    [8 /* CTypeEnum.uint32 */]: 4,
    [9 /* CTypeEnum.atomic_uint32 */]: 4,
    [10 /* CTypeEnum.uint64 */]: 8,
    [11 /* CTypeEnum.int8 */]: 1,
    [12 /* CTypeEnum.atomic_int8 */]: 1,
    [13 /* CTypeEnum.int16 */]: 2,
    [14 /* CTypeEnum.atomic_int16 */]: 2,
    [15 /* CTypeEnum.int32 */]: 4,
    [16 /* CTypeEnum.atomic_int32 */]: 4,
    [17 /* CTypeEnum.int64 */]: 8,
    [18 /* CTypeEnum.float */]: 4,
    [19 /* CTypeEnum.double */]: 8,
    [20 /* CTypeEnum.pointer */]: 4,
    [0 /* CTypeEnum.null */]: 4,
    [1 /* CTypeEnum.void */]: 4,
    [22 /* CTypeEnum.atomic_uint64 */]: 8,
    [21 /* CTypeEnum.atomic_int64 */]: 8
};
const CTypeEnumPointerShiftMap = {
    [2 /* CTypeEnum.uint8 */]: 0,
    [3 /* CTypeEnum.atomic_uint8 */]: 0,
    [4 /* CTypeEnum.char */]: 0,
    [5 /* CTypeEnum.atomic_char */]: 0,
    [6 /* CTypeEnum.uint16 */]: 1,
    [7 /* CTypeEnum.atomic_uint16 */]: 1,
    [8 /* CTypeEnum.uint32 */]: 2,
    [9 /* CTypeEnum.atomic_uint32 */]: 2,
    [10 /* CTypeEnum.uint64 */]: 4,
    [11 /* CTypeEnum.int8 */]: 0,
    [12 /* CTypeEnum.atomic_int8 */]: 0,
    [13 /* CTypeEnum.int16 */]: 1,
    [14 /* CTypeEnum.atomic_int16 */]: 1,
    [15 /* CTypeEnum.int32 */]: 2,
    [16 /* CTypeEnum.atomic_int32 */]: 2,
    [17 /* CTypeEnum.int64 */]: 4,
    [18 /* CTypeEnum.float */]: 2,
    [19 /* CTypeEnum.double */]: 4,
    [20 /* CTypeEnum.pointer */]: 2,
    [1 /* CTypeEnum.void */]: 2,
    [0 /* CTypeEnum.null */]: 2,
    [22 /* CTypeEnum.atomic_uint64 */]: 4,
    [21 /* CTypeEnum.atomic_int64 */]: 4
};


/***/ }),

/***/ "./src/cheap/webassembly/WebAssemblyRunner.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/WebAssemblyRunner.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAssemblyRunner)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _runtime_clib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./runtime/clib */ "./src/cheap/webassembly/runtime/clib.ts");
/* harmony import */ var _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./runtime/atomic */ "./src/cheap/webassembly/runtime/atomic.ts");
/* harmony import */ var _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./runtime/pthread */ "./src/cheap/webassembly/runtime/pthread.ts");
/* harmony import */ var _runtime_semaphore__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./runtime/semaphore */ "./src/cheap/webassembly/runtime/semaphore.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./runtime/asm/thread */ "./src/cheap/webassembly/runtime/asm/thread.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
var cheap__fileName__6 = "src/cheap/webassembly/WebAssemblyRunner.ts";





/* eslint-disable camelcase */
















{
    // 保证打包工具包含下面的模块代码
    __webpack_require__(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts");
}
const runThread =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__["default"])(/*require.resolve*/(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts"), {
    varName: 'init'
}) : 0;
function emptyFunction() { }
let atomicAsmOverride = false;
class ThreadDescriptor {
    flags;
}
(function (prototype) {
    var map = new Map();
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(ThreadDescriptor.prototype);
class WebAssemblyRunner {
    static getTable() {
        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table;
    }
    resource;
    /**
     * WebAssembly runtime 实例
     */
    instance;
    /**
     * 配置项
     */
    options;
    builtinMalloc;
    memoryBase;
    tableBase;
    childImports;
    childUrl;
    childBlob;
    childThreads;
    imports;
    childReadyPromises;
    constructor(resource, options = {}) {
        this.resource = resource;
        this.builtinMalloc = [];
        this.childThreads = new Map();
        this.childReadyPromises = [];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(options.childImports)) {
            this.childImports = options.childImports;
        }
        else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(options.childImports) && options.childImports instanceof Blob) {
            this.childImports = URL.createObjectURL(options.childImports);
        }
        this.memoryBase = resource.dataSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(resource.dataSize) : 0;
        // 子线程的 tableBase 需要和父线程一致
        if (options.thread && options.tableBase) {
            if (cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.getPointer() !== options.tableBase) {
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.alloc(options.tableBase - cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.getPointer());
            }
        }
        this.tableBase = resource.tableSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.alloc(resource.tableSize) : 0;
        this.options = options;
        this.imports = {
            env: {
                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                __stack_pointer: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer,
                __indirect_function_table: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.table,
                clock_time_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.clock_time_get,
                clock_res_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.clock_res_get,
                random_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.random_get,
                abort: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.abort,
                proc_exit: function (exitCode) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`wasm module exit, code: ${exitCode}`, cheap__fileName__6, 133);
                },
                environ_get: emptyFunction,
                environ_sizes_get: emptyFunction,
                fd_close: emptyFunction,
                fd_fdstat_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.fd_fdstat_get,
                fd_read: emptyFunction,
                fd_seek: emptyFunction,
                fd_write: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.fd_write,
                emscripten_builtin_malloc: (size) => {
                    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                    this.builtinMalloc.push(p);
                    return p;
                },
                emscripten_builtin_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                },
                emscripten_builtin_memalign: (memptr, alignment, size) => {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](memptr, address);
                        this.builtinMalloc.push(address);
                        return 0;
                    }
                    return -1;
                },
                emscripten_memcpy_big: function (dest, src, num) {
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memcpy)(dest, src, num);
                },
                __libc_malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                },
                malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                },
                calloc: function (num, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.calloc(num, size);
                },
                realloc: function (pointer, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(pointer, size);
                },
                aligned_alloc(alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                },
                free: function (pointer) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                },
                posix_memalign: function (memptr, alignment, size) {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](memptr, address);
                        return 0;
                    }
                    return -1;
                }
            }
        };
        {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                wasm_pthread_create: (thread, attr, func, args) => {
                    if (!this.childUrl) {
                        const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__["default"])(/*require.resolve*/(/*! ./WebAssemblyRunner.ts */ "./src/cheap/webassembly/WebAssemblyRunner.ts"), {
                            varName: '__WebAssemblyRunner__',
                            exportName: '__WebAssemblyRunner__',
                            pointName: WebAssemblyRunner.name,
                            exportIsClass: true
                        });
                        const source = `
              ${module}
              ${runThread}
              var preRun;
              ${this.childImports ? `
              preRun = import('${this.childImports}')
              ` : ''}
              init.default(preRun);
            `;
                        this.childBlob = new Blob([source], { type: 'text/javascript' });
                        this.childUrl = URL.createObjectURL(this.childBlob);
                    }
                    const worker = new Worker(this.childUrl);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread, (0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.allocThreadId)());
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](thread + 12, 1 /* PthreadStatus.RUN */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread + 8, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](thread + 4, 0);
                    const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_10__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_10__.STACK_SIZE);
                    const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(4);
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(threadDescriptor, 0, 4);
                    this.childThreads.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread), {
                        thread,
                        worker,
                        stackPointer,
                        threadDescriptor
                    });
                    let resolve;
                    this.childReadyPromises.push(new Promise((r) => {
                        resolve = r;
                    }));
                    worker.onmessage = (message) => {
                        const origin = message.data;
                        const type = origin.type;
                        const data = origin.data;
                        switch (type) {
                            case 'run':
                                resolve();
                                break;
                        }
                    };
                    /**
                     * postMessage 并不是同步的，而是在事件循环中处理的
                     * 因此父线程不能被阻塞在当前的事件循环中，否则子线程无法成功运行
                     * 只有 childReadyPromises 中的 Promise 都 resolve 了之后才能阻塞
                     */
                    worker.postMessage({
                        type: 'run',
                        data: {
                            cheap: {
                                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                                stackPointer,
                                stackSize: _config__WEBPACK_IMPORTED_MODULE_10__.STACK_SIZE,
                                id: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread)
                            },
                            runner: {
                                resource: {
                                    tableSize: this.resource.tableSize,
                                    module: this.resource.threadModule.module,
                                    initFuncs: this.resource.threadModule.initFuncs
                                },
                                options: {
                                    memoryBase: this.options.memoryBase || this.memoryBase,
                                    tableBase: this.tableBase,
                                    thread,
                                    threadDescriptor,
                                    childImports: this.childImports
                                },
                                func,
                                args,
                                imports: this.childImports,
                                thread
                            }
                        }
                    });
                    return 0;
                },
                wasm_pthread_join2: (thread, retval) => {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
                        this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                        return 0;
                    }
                    // 等待子线程退出
                    _thread_atomics__WEBPACK_IMPORTED_MODULE_12__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
                    if (retval !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](thread + 4));
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    // 回收栈
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(child.stackPointer);
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(child.threadDescriptor);
                    child.worker.terminate();
                    this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    return 0;
                },
                wasm_pthread_detach2: (thread) => {
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](child.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](child.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
                }
            });
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_semaphore__WEBPACK_IMPORTED_MODULE_15__);
        }
        if (this.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __memory_base: this.memoryBase
            });
        }
        // 使用父线程的 memoryBase
        else if (options.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __memory_base: options.memoryBase
            });
        }
        if (this.tableBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __table_base: this.tableBase
            });
        }
        if (options.imports?.env) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, options.imports.env);
            if (options.envKey && options.importMap) {
                const env = {};
                common_util_object__WEBPACK_IMPORTED_MODULE_9__.each(this.imports.env, (value, key) => {
                    if (options.importMap[key]) {
                        env[options.importMap[key]] = value;
                    }
                });
                this.imports[options.envKey] = env;
            }
        }
        this.imports['wasi_snapshot_preview1'] = this.imports.env;
    }
    overrideAtomic() {
        _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__.override({
            atomic_add_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add8,
            atomic_sub_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub8,
            atomic_and_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and8,
            atomic_or_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or8,
            atomic_xor_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor8,
            atomic_store_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store8,
            atomic_load_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load8,
            atomic_compare_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange8,
            atomic_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange8,
            atomic_add_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add16,
            atomic_sub_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub16,
            atomic_and_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and16,
            atomic_or_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or16,
            atomic_xor_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor16,
            atomic_store_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store16,
            atomic_load_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load16,
            atomic_compare_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange16,
            atomic_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange16,
            atomic_add_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add32,
            atomic_sub_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub32,
            atomic_and_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and32,
            atomic_or_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or32,
            atomic_xor_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor32,
            atomic_store_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store32,
            atomic_load_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load32,
            atomic_compare_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange32,
            atomic_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange32,
            atomic_add_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add64,
            atomic_sub_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub64,
            atomic_and_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and64,
            atomic_or_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or64,
            atomic_xor_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor64,
            atomic_store_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store64,
            atomic_load_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load64,
            atomic_compare_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange64,
            atomic_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange64,
            atomics_notify: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.notify,
            atomics_wait: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.wait
        });
        common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__);
    }
    /**
     * 运行 wasm 实例
     */
    async run(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.options.imports, imports);
        }
        if ( true
            && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__["default"])()
            && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.wasmThreadProxy
            && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.isSupport()
            && this.resource.threadModule) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = await WebAssembly.instantiate(this.resource.module, this.imports);
        this.initRunTime();
    }
    async runAsChild(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.options.imports, imports);
        }
        if ( true && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.wasmThreadProxy && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.isSupport()) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = new WebAssembly.Instance(this.resource.module, this.imports);
        this.initRunTime();
    }
    async childrenThreadReady() {
        if (!this.childReadyPromises.length) {
            return;
        }
        const promise = this.childReadyPromises;
        this.childReadyPromises = [];
        await Promise.all(promise);
    }
    initRunTime() {
        this.builtinMalloc = [];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.array(this.resource.initFuncs)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(this.resource.initFuncs, (func) => {
                this.call(func);
            });
        }
    }
    /**
     * 调用 wasm 模块暴露的方法
     *
     * @param func 方法名
     * @param args 参数，只能是 number 和 bigint( 有浏览器版本要求， 建议 64 位数据使用指针传递） 类型，如果是其他类型参数使用指针传递
     */
    call(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        let call;
        if (this.asm[func]) {
            call = this.asm[func];
        }
        else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
            call = this.asm[this.options.exportMap[func]];
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`the wasm module has not function ${func} to call`, cheap__fileName__6, 489);
        }
    }
    get asm() {
        return this.instance && this.instance.exports;
    }
    getInstance() {
        return this.instance;
    }
    destroy() {
        if (this.builtinMalloc?.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(this.builtinMalloc, (pointer) => {
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
            });
            this.builtinMalloc.length = 0;
        }
        if (this.memoryBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.memoryBase);
            this.memoryBase = null;
        }
        if (this.tableBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.free(this.tableBase);
            this.tableBase = null;
        }
        if (this.childImports) {
            URL.revokeObjectURL(this.childImports);
            this.childImports = null;
        }
        if (this.childUrl) {
            URL.revokeObjectURL(this.childUrl);
            this.childUrl = null;
        }
        this.childBlob = null;
        this.childReadyPromises.length = 0;
        if (this.childThreads.size) {
            this.childThreads.forEach((thread, id) => {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread.threadDescriptor) & 1 /* PthreadFlags.DETACH */)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn('has child thread running, maybe resource leakage', cheap__fileName__6, 534);
                    thread.worker.terminate();
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](thread.thread + 12, 0 /* PthreadStatus.STOP */);
                    if (thread.stackPointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.stackPointer);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.threadDescriptor);
                    this.childThreads.delete(id);
                }
            });
        }
        this.builtinMalloc = null;
        this.instance = null;
        if (this.options.thread) {
            if (this.options.threadDescriptor && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](this.options.threadDescriptor) & 1 /* PthreadFlags.DETACH */) {
                if (cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackTop) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackTop);
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.options.threadDescriptor);
                self.close();
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](this.options.thread + 12, 0 /* PthreadStatus.STOP */
                // 唤醒父线程收回资源
                );
                // 唤醒父线程收回资源
                _thread_atomics__WEBPACK_IMPORTED_MODULE_12__.notify(this.options.thread + 12, 1);
            }
        }
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/compiler.ts":
/*!*******************************************!*\
  !*** ./src/cheap/webassembly/compiler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var common_io_IOWriter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/IOWriter */ "./src/common/io/IOWriter.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");







async function process(context) {
    try {
        // `\0asm`
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        // Version
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        while (true) {
            if (context.compileStopped) {
                if (context.abortController) {
                    context.abortController.abort();
                }
                break;
            }
            const sectionId = await context.ioReader.readUint8();
            if (context.options.child) {
                if (sectionId === 11 /* SectionId.Data */) {
                    await context.ioWriter.writeUint8(sectionId);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 7);
                    // count
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 1);
                    // index
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 0);
                    // init_expr i32_const 0
                    await context.ioWriter.writeUint8(0x41);
                    await context.ioWriter.writeUint8(0x00);
                    await context.ioWriter.writeUint8(0x0b);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 1);
                    await context.ioWriter.writeUint8(0x00);
                    const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await context.ioReader.skip(size);
                    continue;
                }
            }
            await context.ioWriter.writeUint8(sectionId);
            const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, size);
            const now = context.ioReader.getPos();
            if (sectionId === 11 /* SectionId.Data */) {
                /**
                 * - count: varuint32
                 * - entries: data_segment*
                 *   - index varuint32 the linear memory index (0 in the MVP)
                 *   - offset init_expr
                 *   - size varuint32
                 *   - data bytes
                 */
                const count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, count);
                if (count) {
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                    while (true) {
                        const byte = await context.ioReader.readUint8();
                        await context.ioWriter.writeUint8(byte);
                        if (byte === 0x0b) {
                            break;
                        }
                    }
                    context.data.dataSize = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, context.data.dataSize);
                }
            }
            else if (sectionId === 2 /* SectionId.Import */) {
                /**
                 * - count: varuint32
                 * - entries: import_entry*
                 *   - module_len varuint32
                 *   - module_str bytes
                 *   - field_len varuint32
                 *   - field_str bytes
                 *   - external_kind
                 */
                let count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, count);
                let counter = 0;
                while (count--) {
                    const moduleLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, moduleLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(moduleLen));
                    const fieldLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, fieldLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(fieldLen));
                    const externalKind = await context.ioReader.readUint8();
                    await context.ioWriter.writeUint8(externalKind);
                    switch (externalKind) {
                        case 0 /* ExternalKind.Function */: {
                            // type index of the function signature
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 3 /* ExternalKind.Global */: {
                            // content_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readSLeb128Async)(context.ioReader));
                            // mutability
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 2 /* ExternalKind.Memory */: {
                            let flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            if (context.options.enableThread) {
                                flags |= 2;
                            }
                            else {
                                flags &= ~2;
                            }
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, flags);
                            // initial
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                        case 1 /* ExternalKind.Table */: {
                            // elem_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readSLeb128Async)(context.ioReader));
                            const flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, flags);
                            const initial = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, initial);
                            context.data.tableSize = initial;
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                    }
                    if (counter === 2) {
                        break;
                    }
                }
            }
            const remainingLength = size - Number(context.ioReader.getPos() - now);
            if (remainingLength) {
                await context.ioReader.pipe(context.ioWriter, size - Number(context.ioReader.getPos() - now));
            }
        }
    }
    catch (e) {
        if (context.ioReader.error === -1048576 /* IOError.END */) {
            context.bufferEnded = true;
        }
        else {
            context.error = e;
        }
        if (context.ioReader.remainingLength()) {
            await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(context.ioReader.remainingLength()));
        }
        await context.ioWriter.flush();
    }
}
async function compile(source, options = {}) {
    let module;
    let tableSize;
    let dataSize;
    let buffer;
    options = common_util_object__WEBPACK_IMPORTED_MODULE_1__.extend({
        enableThread: _config__WEBPACK_IMPORTED_MODULE_2__.USE_THREADS,
        initFuncs: options.child ? [] : ['__wasm_apply_data_relocs']
    }, options);
    if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(source.dataSize) && common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(source.tableSize)) {
        tableSize = source.dataSize;
        dataSize = source.dataSize;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)) {
            const params = {
                method: 'GET',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(WebAssembly.compileStreaming)) {
                module = await WebAssembly.compileStreaming(fetch(source.source, params));
            }
            else {
                const response = await fetch(source.source, params);
                buffer = await response.arrayBuffer();
                module = await WebAssembly.compile(buffer);
            }
        }
        else {
            module = await WebAssembly.compile(source.source);
            buffer = common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? source.source : source.source.buffer;
        }
    }
    else {
        const context = {
            ioReader: new common_io_IOReader__WEBPACK_IMPORTED_MODULE_4__["default"](1048576),
            ioWriter: new common_io_IOWriter__WEBPACK_IMPORTED_MODULE_5__["default"](1048576),
            bufferEnded: false,
            compileStopped: false,
            error: '',
            abortController: null,
            pullResolve: null,
            bufferResolve: null,
            buffers: [],
            data: {},
            options
        };
        const response = new Response(new ReadableStream({
            async start(controller) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)) {
                    if (AbortController) {
                        context.abortController = new AbortController();
                    }
                    const params = {
                        method: 'GET',
                        headers: {},
                        mode: 'cors',
                        cache: 'default',
                        referrerPolicy: 'no-referrer-when-downgrade',
                        signal: context.abortController?.signal
                    };
                    const res = await fetch(source.source, params);
                    let reader;
                    if (res.ok && (res.status >= 200 && res.status <= 299)) {
                        reader = res.body.getReader();
                    }
                    else {
                        controller.error(`Http code invalid, ${res.status} ${res.statusText}`);
                    }
                    const buffers = [];
                    context.ioReader.onFlush = async (buffer) => {
                        let pos = 0;
                        while (buffers.length && pos < buffer.length) {
                            const cache = buffers.shift();
                            if (cache.length > buffer.length - pos) {
                                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                                buffers.unshift(cache.subarray(buffer.length - pos));
                                pos = buffer.length;
                            }
                            else {
                                buffer.set(cache, pos);
                                pos += cache.length;
                            }
                        }
                        if (pos >= buffer.length) {
                            return buffer.length;
                        }
                        const { value, done } = await reader.read();
                        if (done) {
                            return pos > 0 ? pos : -1048576 /* IOError.END */;
                        }
                        else {
                            context.buffers.push(value);
                            if (value.length > buffer.length - pos) {
                                buffer.set(value.subarray(0, buffer.length - pos), pos);
                                buffers.push(value.subarray(buffer.length - pos));
                                return buffer.length;
                            }
                            else {
                                buffer.set(value, pos);
                                pos += value.length;
                                return pos;
                            }
                        }
                    };
                }
                else {
                    let readPos = 0;
                    let readFileLength = source.source.byteLength;
                    const wasm = common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? new Uint8Array(source.source) : source.source;
                    context.ioReader.onFlush = async (buffer) => {
                        if (readPos >= readFileLength) {
                            return -1048576 /* IOError.END */;
                        }
                        const len = Math.min(buffer.length, readFileLength - readPos);
                        buffer.set(wasm.subarray(readPos, readPos + len), 0);
                        readPos += len;
                        return len;
                    };
                }
                context.ioWriter.onFlush = async (buffer) => {
                    if (context.pullResolve) {
                        context.pullResolve(buffer.slice());
                        context.pullResolve = null;
                        return 0;
                    }
                    (await new Promise((resolve, reject) => {
                        context.bufferResolve = resolve;
                    })).enqueue(buffer.slice());
                    return 0;
                };
                process(context);
            },
            async pull(controller) {
                if (context.error) {
                    controller.close();
                    return;
                }
                if (context.bufferResolve) {
                    context.bufferResolve(controller);
                    context.bufferResolve = null;
                    return;
                }
                controller.enqueue(await new Promise((resolve, reject) => {
                    context.pullResolve = resolve;
                }));
                if (context.bufferEnded) {
                    controller.close();
                }
                else if (context.error) {
                    controller.error(context.error);
                }
            },
            cancel(reason) {
                context.compileStopped = true;
            }
        }), {
            headers: {
                'Content-Type': 'application/wasm'
            }
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(WebAssembly.compileStreaming)) {
            module = await WebAssembly.compileStreaming(response);
        }
        else {
            module = await WebAssembly.compile(await response.arrayBuffer());
        }
        buffer = common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)
            ? (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_6__["default"])(Uint8Array, context.buffers).buffer
            : (common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? source.source : source.source.buffer);
        tableSize = context.data.tableSize;
        dataSize = context.data.dataSize;
    }
    if (options.child) {
        return {
            module,
            initFuncs: options.initFuncs || []
        };
    }
    return {
        module,
        tableSize,
        dataSize,
        initFuncs: options.initFuncs || [],
        buffer: buffer
    };
}


/***/ }),

/***/ "./src/cheap/webassembly/runThread.ts":
/*!********************************************!*\
  !*** ./src/cheap/webassembly/runThread.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

// @ts-ignore
common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.imports = {
    env: {}
};
let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(preRun) {
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        let runner;
        switch (type) {
            case 'run':
                parentPort.postMessage({
                    type: 'run'
                });
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data.cheap).then(() => {
                        function run() {
                            common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__SELF_THREAD__ = data.runner.thread;
                            // @ts-ignore
                            data.runner.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.imports;
                            // @ts-ignore
                            runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(data.runner.resource, data.runner.options);
                            runner.runAsChild().then(() => {
                                // @ts-ignore
                                __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(data.runner.func)(data.runner.args);
                                runner.destroy();
                            });
                        }
                        if (preRun) {
                            preRun.then(() => {
                                run();
                            });
                        }
                        else {
                            run();
                        }
                    });
                }
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.ts":
/*!*****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thread.asm */ "./src/cheap/webassembly/runtime/asm/thread.asm");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_thread_asm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__0 = "src/cheap/webassembly/runtime/asm/thread.ts";
/* eslint-disable camelcase */




/**
 * WebAssembly runtime 实例
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory, override) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_thread_asm__WEBPACK_IMPORTED_MODULE_1___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            support = false;
            return;
        }
        override({
            wasm_pthread_mutex_lock: wasmThreadProxy.exports.lock,
            wasm_pthread_mutex_unlock: wasmThreadProxy.exports.unlock,
            wasm_pthread_cond_wait: wasmThreadProxy.exports.wait,
            wasm_pthread_cond_timedwait: wasmThreadProxy.exports.timedwait,
            wasm_pthread_cond_signal: wasmThreadProxy.exports.signal,
            wasm_pthread_cond_broadcast: wasmThreadProxy.exports.broadcast
        });
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__0, 65);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/atomic.ts":
/*!*************************************************!*\
  !*** ./src/cheap/webassembly/runtime/atomic.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atomic_add_i16: () => (/* binding */ atomic_add_i16),
/* harmony export */   atomic_add_i32: () => (/* binding */ atomic_add_i32),
/* harmony export */   atomic_add_i64: () => (/* binding */ atomic_add_i64),
/* harmony export */   atomic_add_i8: () => (/* binding */ atomic_add_i8),
/* harmony export */   atomic_and_i16: () => (/* binding */ atomic_and_i16),
/* harmony export */   atomic_and_i32: () => (/* binding */ atomic_and_i32),
/* harmony export */   atomic_and_i64: () => (/* binding */ atomic_and_i64),
/* harmony export */   atomic_and_i8: () => (/* binding */ atomic_and_i8),
/* harmony export */   atomic_compare_exchange_i16: () => (/* binding */ atomic_compare_exchange_i16),
/* harmony export */   atomic_compare_exchange_i32: () => (/* binding */ atomic_compare_exchange_i32),
/* harmony export */   atomic_compare_exchange_i64: () => (/* binding */ atomic_compare_exchange_i64),
/* harmony export */   atomic_compare_exchange_i8: () => (/* binding */ atomic_compare_exchange_i8),
/* harmony export */   atomic_exchange_i16: () => (/* binding */ atomic_exchange_i16),
/* harmony export */   atomic_exchange_i32: () => (/* binding */ atomic_exchange_i32),
/* harmony export */   atomic_exchange_i64: () => (/* binding */ atomic_exchange_i64),
/* harmony export */   atomic_exchange_i8: () => (/* binding */ atomic_exchange_i8),
/* harmony export */   atomic_load_i16: () => (/* binding */ atomic_load_i16),
/* harmony export */   atomic_load_i32: () => (/* binding */ atomic_load_i32),
/* harmony export */   atomic_load_i64: () => (/* binding */ atomic_load_i64),
/* harmony export */   atomic_load_i8: () => (/* binding */ atomic_load_i8),
/* harmony export */   atomic_or_i16: () => (/* binding */ atomic_or_i16),
/* harmony export */   atomic_or_i32: () => (/* binding */ atomic_or_i32),
/* harmony export */   atomic_or_i64: () => (/* binding */ atomic_or_i64),
/* harmony export */   atomic_or_i8: () => (/* binding */ atomic_or_i8),
/* harmony export */   atomic_store_i16: () => (/* binding */ atomic_store_i16),
/* harmony export */   atomic_store_i32: () => (/* binding */ atomic_store_i32),
/* harmony export */   atomic_store_i64: () => (/* binding */ atomic_store_i64),
/* harmony export */   atomic_store_i8: () => (/* binding */ atomic_store_i8),
/* harmony export */   atomic_sub_i16: () => (/* binding */ atomic_sub_i16),
/* harmony export */   atomic_sub_i32: () => (/* binding */ atomic_sub_i32),
/* harmony export */   atomic_sub_i64: () => (/* binding */ atomic_sub_i64),
/* harmony export */   atomic_sub_i8: () => (/* binding */ atomic_sub_i8),
/* harmony export */   atomic_xor_i16: () => (/* binding */ atomic_xor_i16),
/* harmony export */   atomic_xor_i32: () => (/* binding */ atomic_xor_i32),
/* harmony export */   atomic_xor_i64: () => (/* binding */ atomic_xor_i64),
/* harmony export */   atomic_xor_i8: () => (/* binding */ atomic_xor_i8),
/* harmony export */   atomics_notify: () => (/* binding */ atomics_notify),
/* harmony export */   atomics_wait: () => (/* binding */ atomics_wait),
/* harmony export */   atomics_wait_timeout: () => (/* binding */ atomics_wait_timeout),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../typedef */ "./src/cheap/typedef.ts");
/* eslint-disable camelcase */


let atomic_add_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_sub_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_and_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_or_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_xor_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_store_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_load_i8 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_compare_exchange_i8 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_exchange_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_add_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_sub_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_and_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_or_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_xor_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_store_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_load_i16 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_compare_exchange_i16 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_exchange_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_add_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_sub_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_and_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_or_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_xor_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_store_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_load_i32 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_compare_exchange_i32 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_exchange_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_add_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_sub_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_and_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_or_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_xor_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_store_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_load_i64 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_compare_exchange_i64 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_exchange_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomics_notify = function (p, count) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.notify(p, count);
};
let atomics_wait = function (p, value) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.wait(p, value);
};
let atomics_wait_timeout = function (p, value, timeout) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.waitTimeout(p, value, (Number(timeout & 0xffffffffn) >> 0));
};
function override(data) {
    if (data.atomic_add_i8) {
        atomic_add_i8 = data.atomic_add_i8;
    }
    if (data.atomic_sub_i8) {
        atomic_sub_i8 = data.atomic_sub_i8;
    }
    if (data.atomic_and_i8) {
        atomic_and_i8 = data.atomic_and_i8;
    }
    if (data.atomic_or_i8) {
        atomic_or_i8 = data.atomic_or_i8;
    }
    if (data.atomic_xor_i8) {
        atomic_xor_i8 = data.atomic_xor_i8;
    }
    if (data.atomic_store_i8) {
        atomic_store_i8 = data.atomic_store_i8;
    }
    if (data.atomic_load_i8) {
        atomic_load_i8 = data.atomic_load_i8;
    }
    if (data.atomic_compare_exchange_i8) {
        atomic_compare_exchange_i8 = data.atomic_compare_exchange_i8;
    }
    if (data.atomic_exchange_i8) {
        atomic_exchange_i8 = data.atomic_exchange_i8;
    }
    if (data.atomic_add_i16) {
        atomic_add_i16 = data.atomic_add_i16;
    }
    if (data.atomic_sub_i16) {
        atomic_sub_i16 = data.atomic_sub_i16;
    }
    if (data.atomic_and_i16) {
        atomic_and_i16 = data.atomic_and_i16;
    }
    if (data.atomic_or_i16) {
        atomic_or_i16 = data.atomic_or_i16;
    }
    if (data.atomic_xor_i16) {
        atomic_xor_i16 = data.atomic_xor_i16;
    }
    if (data.atomic_store_i16) {
        atomic_store_i16 = data.atomic_store_i16;
    }
    if (data.atomic_load_i16) {
        atomic_load_i16 = data.atomic_load_i16;
    }
    if (data.atomic_compare_exchange_i16) {
        atomic_compare_exchange_i16 = data.atomic_compare_exchange_i16;
    }
    if (data.atomic_exchange_i16) {
        atomic_exchange_i16 = data.atomic_exchange_i16;
    }
    if (data.atomic_add_i32) {
        atomic_add_i32 = data.atomic_add_i32;
    }
    if (data.atomic_sub_i32) {
        atomic_sub_i32 = data.atomic_sub_i32;
    }
    if (data.atomic_and_i32) {
        atomic_and_i32 = data.atomic_and_i32;
    }
    if (data.atomic_or_i32) {
        atomic_or_i32 = data.atomic_or_i32;
    }
    if (data.atomic_xor_i32) {
        atomic_xor_i32 = data.atomic_xor_i32;
    }
    if (data.atomic_store_i32) {
        atomic_store_i32 = data.atomic_store_i32;
    }
    if (data.atomic_load_i32) {
        atomic_load_i32 = data.atomic_load_i32;
    }
    if (data.atomic_compare_exchange_i32) {
        atomic_compare_exchange_i32 = data.atomic_compare_exchange_i32;
    }
    if (data.atomic_exchange_i32) {
        atomic_exchange_i32 = data.atomic_exchange_i32;
    }
    if (data.atomic_add_i64) {
        atomic_add_i64 = data.atomic_add_i64;
    }
    if (data.atomic_sub_i64) {
        atomic_sub_i64 = data.atomic_sub_i64;
    }
    if (data.atomic_and_i64) {
        atomic_and_i64 = data.atomic_and_i64;
    }
    if (data.atomic_or_i64) {
        atomic_or_i64 = data.atomic_or_i64;
    }
    if (data.atomic_xor_i64) {
        atomic_xor_i64 = data.atomic_xor_i64;
    }
    if (data.atomic_store_i64) {
        atomic_store_i64 = data.atomic_store_i64;
    }
    if (data.atomic_load_i64) {
        atomic_load_i64 = data.atomic_load_i64;
    }
    if (data.atomic_compare_exchange_i64) {
        atomic_compare_exchange_i64 = data.atomic_compare_exchange_i64;
    }
    if (data.atomic_exchange_i64) {
        atomic_exchange_i64 = data.atomic_exchange_i64;
    }
    if (data.atomics_notify) {
        atomics_notify = data.atomics_notify;
    }
    if (data.atomics_wait) {
        atomics_wait = data.atomics_wait;
    }
    if (data.atomics_wait_timeout) {
        atomics_wait_timeout = data.atomics_wait_timeout;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/clib.ts":
/*!***********************************************!*\
  !*** ./src/cheap/webassembly/runtime/clib.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abort: () => (/* binding */ abort),
/* harmony export */   clock_res_get: () => (/* binding */ clock_res_get),
/* harmony export */   clock_time_get: () => (/* binding */ clock_time_get),
/* harmony export */   fd_fdstat_get: () => (/* binding */ fd_fdstat_get),
/* harmony export */   fd_write: () => (/* binding */ fd_write),
/* harmony export */   random_get: () => (/* binding */ random_get)
/* harmony export */ });
/* unused harmony exports printChar, writeAsciiToMemory, fd_read, fd_seek, fd_close */
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");


/* eslint-disable camelcase */


const buffers = [null, [], []];
const WASI_ERRNO_SUCCESS = 0;
const WASI_ERRNO_NOSYS = 52;
const WASI_ERRNO_INVAL = 28;
function printChar(stream, curr) {
    const buffer = buffers[stream];
    if (curr === 0 || curr === 10) {
        (stream === 1 ? console.log.bind(console) : console.log.bind(console))(common_util_text__WEBPACK_IMPORTED_MODULE_0__.decode(buffer));
        buffer.length = 0;
    }
    else {
        buffer.push(curr);
    }
}
function writeAsciiToMemory(str, buffer, doNotAddNull) {
    for (let i = 0; i < str.length; ++i) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[4](buffer, ((((str.charCodeAt(i)) >> 0) & 0xff) & 0x80) ? -(0x100 - (((str.charCodeAt(i)) >> 0) & 0xff)) : (((str.charCodeAt(i)) >> 0) & 0xff));
        buffer = buffer + 1;
    }
    if (!doNotAddNull) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[4](buffer, ( false) ? 0 : (0 & 0xff));
    }
}
function fd_fdstat_get(fd, pBuf) {
    let rightsBase = 0;
    if (fd == 0) {
        rightsBase = 2;
    }
    else if (fd == 1 || fd == 2) {
        rightsBase = 64;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[11](pBuf, ( false) ? 0 : (2 & 0xff));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[13](pBuf + 2, ( false) ? 0 : (1 & 0xffff));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pBuf + 8, ((rightsBase) >> 0));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pBuf + 12, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](pBuf + 16, BigInt(0));
    return WASI_ERRNO_SUCCESS;
}
function fd_read(fd, iov, iovCnt, pNum) {
    return WASI_ERRNO_NOSYS;
}
function fd_seek(fd, offsetLow, offsetHigh, whence, newOffset) {
    return WASI_ERRNO_NOSYS;
}
function fd_write(fd, iov, iovCnt, pNum) {
    let num = 0;
    for (let i = 0; i < iovCnt; i++) {
        let ptr = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](iov);
        let len = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](iov + 4);
        iov = iov + 8;
        for (let j = 0; j < len; j++) {
            printChar(fd, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[4](ptr + j));
        }
        num += len;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](pNum, (((num) >> 0) >>> 0));
    return WASI_ERRNO_SUCCESS;
}
function fd_close(fd) {
    return WASI_ERRNO_NOSYS;
}
function abort(what) {
    what += '';
    what = `abort(${what}). Build with -s ASSERTIONS=1 for more info.`;
    throw new WebAssembly.RuntimeError(what);
}
function clock_time_get(id, precision, timeOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    const now = new Date().getTime();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](timeOut, BigInt(now) * BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function clock_res_get(id, resOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](resOut, BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function random_get(pointer, size) {
    const buffer = (0,_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(pointer, size);
    {
        crypto.getRandomValues(buffer);
    }
    return WASI_ERRNO_SUCCESS;
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/pthread.ts":
/*!**************************************************!*\
  !*** ./src/cheap/webassembly/runtime/pthread.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pthread: () => (/* binding */ Pthread),
/* harmony export */   PthreadOnce: () => (/* binding */ PthreadOnce),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   wasm_cpu_core_count: () => (/* binding */ wasm_cpu_core_count),
/* harmony export */   wasm_pthread_cond_broadcast: () => (/* binding */ wasm_pthread_cond_broadcast),
/* harmony export */   wasm_pthread_cond_destroy: () => (/* binding */ wasm_pthread_cond_destroy),
/* harmony export */   wasm_pthread_cond_init: () => (/* binding */ wasm_pthread_cond_init),
/* harmony export */   wasm_pthread_cond_signal: () => (/* binding */ wasm_pthread_cond_signal),
/* harmony export */   wasm_pthread_cond_timedwait: () => (/* binding */ wasm_pthread_cond_timedwait),
/* harmony export */   wasm_pthread_cond_wait: () => (/* binding */ wasm_pthread_cond_wait),
/* harmony export */   wasm_pthread_equal2: () => (/* binding */ wasm_pthread_equal2),
/* harmony export */   wasm_pthread_exit: () => (/* binding */ wasm_pthread_exit),
/* harmony export */   wasm_pthread_mutex_destroy: () => (/* binding */ wasm_pthread_mutex_destroy),
/* harmony export */   wasm_pthread_mutex_init: () => (/* binding */ wasm_pthread_mutex_init),
/* harmony export */   wasm_pthread_mutex_lock: () => (/* binding */ wasm_pthread_mutex_lock),
/* harmony export */   wasm_pthread_mutex_unlock: () => (/* binding */ wasm_pthread_mutex_unlock),
/* harmony export */   wasm_pthread_once: () => (/* binding */ wasm_pthread_once),
/* harmony export */   wasm_pthread_support: () => (/* binding */ wasm_pthread_support)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _thread_cond__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config */ "./src/cheap/config.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");




/* eslint-disable camelcase */






class PthreadOnce {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(PthreadOnce.prototype);
class Pthread {
    id;
    retval;
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("retval", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("status", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(Pthread.prototype);
let wasm_pthread_mutex_init;
let wasm_pthread_mutex_destroy;
let wasm_pthread_mutex_lock;
let wasm_pthread_mutex_unlock;
let wasm_pthread_cond_init;
let wasm_pthread_cond_destroy;
let wasm_pthread_cond_wait;
let wasm_pthread_cond_timedwait;
let wasm_pthread_cond_signal;
let wasm_pthread_cond_broadcast;
let wasm_pthread_once;
function wasm_pthread_exit(retval) {
    const thread = common_util_constant__WEBPACK_IMPORTED_MODULE_3__.SELF.__SELF_THREAD__;
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](thread + 4, retval);
}
function wasm_pthread_equal2(t1, t2) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](t1) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](t2) ? 1 : 0;
}
function wasm_pthread_support() {
    return _config__WEBPACK_IMPORTED_MODULE_6__.USE_THREADS ? 1 : 0;
}
function wasm_cpu_core_count() {
    return navigator.hardwareConcurrency;
}
wasm_pthread_mutex_init = function (mutex, attr) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.init(mutex);
};
wasm_pthread_mutex_destroy = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.destroy(mutex);
};
wasm_pthread_mutex_lock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.lock(mutex);
};
wasm_pthread_mutex_unlock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.unlock(mutex);
};
wasm_pthread_cond_init = function (cond, attr) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.init(cond, attr);
};
wasm_pthread_cond_destroy = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.destroy(cond);
};
wasm_pthread_cond_wait = function (cond, mutex) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.wait(cond, mutex);
};
wasm_pthread_cond_timedwait = function (cond, mutex, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.timedWait(cond, mutex, timeout);
};
wasm_pthread_cond_signal = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.signal(cond);
};
wasm_pthread_cond_broadcast = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.broadcast(cond);
};
wasm_pthread_once = function (control, func) {
    if (_thread_atomics__WEBPACK_IMPORTED_MODULE_9__.add(control, 1, 16, 2) === 0) {
        _heap__WEBPACK_IMPORTED_MODULE_0__.Table.get(func)();
    }
    return 0;
};
function override(data) {
    if (data.wasm_pthread_mutex_lock) {
        wasm_pthread_mutex_lock = data.wasm_pthread_mutex_lock;
    }
    if (data.wasm_pthread_mutex_unlock) {
        wasm_pthread_mutex_unlock = data.wasm_pthread_mutex_unlock;
    }
    if (data.wasm_pthread_cond_wait) {
        wasm_pthread_cond_wait = data.wasm_pthread_cond_wait;
    }
    if (data.wasm_pthread_cond_timedwait) {
        wasm_pthread_cond_timedwait = data.wasm_pthread_cond_timedwait;
    }
    if (data.wasm_pthread_cond_signal) {
        wasm_pthread_cond_signal = data.wasm_pthread_cond_signal;
    }
    if (data.wasm_pthread_cond_broadcast) {
        wasm_pthread_cond_broadcast = data.wasm_pthread_cond_broadcast;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/semaphore.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/semaphore.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timespec: () => (/* binding */ Timespec),
/* harmony export */   wasm_sem_destroy: () => (/* binding */ wasm_sem_destroy),
/* harmony export */   wasm_sem_init: () => (/* binding */ wasm_sem_init),
/* harmony export */   wasm_sem_post: () => (/* binding */ wasm_sem_post),
/* harmony export */   wasm_sem_timedwait: () => (/* binding */ wasm_sem_timedwait),
/* harmony export */   wasm_sem_trywait: () => (/* binding */ wasm_sem_trywait),
/* harmony export */   wasm_sem_wait: () => (/* binding */ wasm_sem_wait)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../thread/semaphore */ "./src/cheap/thread/semaphore.ts");



/* eslint-disable camelcase */

class Timespec {
    tvSec;
    tvNSec;
}
(function (prototype) {
    var map = new Map();
    map.set("tvSec", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("tvNSec", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Timespec.prototype);
function wasm_sem_init(sem, pshared, value) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.init(sem, value);
}
function wasm_sem_destroy(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.destroy(sem);
}
function wasm_sem_wait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.wait(sem);
}
function wasm_sem_trywait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.tryWait(sem);
}
function wasm_sem_timedwait(sem, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.timedWait(sem, timeout);
}
function wasm_sem_post(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.post(sem);
}


/***/ }),

/***/ "./src/common/event/CustomEvent.ts":
/*!*****************************************!*\
  !*** ./src/common/event/CustomEvent.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomEvent)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/CustomEvent.ts
 * MIT License
 *
 * @file 事件
 */

class CustomEvent {
    static PHASE_CURRENT = 0;
    static PHASE_UPWARD = 1;
    static PHASE_DOWNWARD = _util_constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    // 事件名称
    type;
    // 事件当前阶段
    phase;
    // 事件命名空间
    ns;
    // 哪个组件发出的事件
    target;
    // 原始事件，比如 DOM 事件
    originalEvent;
    // 是否已阻止事件的默认行为
    isPrevented;
    // 是否已停止事件冒泡
    isStopped;
    // 处理当前事件的监听器，方便外部获取 listener 进行解绑
    listener;
    /**
     * 构造函数
     *
     * 可以传事件名称，也可以传原生事件对象
     */
    constructor(type, originalEvent) {
        /*
         * 这里不设置命名空间
         * 因为有没有命名空间取决于 Emitter 的构造函数有没有传 true
         * CustomEvent 自己无法决定
         */
        this.type = type;
        this.phase = CustomEvent.PHASE_CURRENT;
        if (originalEvent) {
            this.originalEvent = originalEvent;
        }
    }
    /**
     * 阻止事件的默认行为
     */
    preventDefault() {
        const instance = this;
        if (!instance.isPrevented) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.preventDefault();
            }
            instance.isPrevented = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    /**
     * 停止事件广播
     */
    stopPropagation() {
        const instance = this;
        if (!instance.isStopped) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.stopPropagation();
            }
            instance.isStopped = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    prevent() {
        return this.preventDefault();
    }
    stop() {
        return this.stopPropagation();
    }
}


/***/ }),

/***/ "./src/common/event/Emitter.ts":
/*!*************************************!*\
  !*** ./src/common/event/Emitter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Emitter)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _CustomEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CustomEvent */ "./src/common/event/CustomEvent.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
var cheap__fileName__0 = "src/common/event/Emitter.ts";
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/Emitter.ts
 * MIT License
 *
 * @file 事件代理
 */








class Emitter {
    /**
     * 是否开启命名空间
     */
    ns;
    /**
     * 已注册的事件监听
     */
    listeners;
    /**
     * 原生事件监听，一个事件对应一个 listener
     */
    nativeListeners;
    constructor(ns) {
        this.ns = ns || _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
        this.listeners = {};
    }
    /**
     * 发射事件
     *
     * @param type 事件名称或命名空间
     * @param args 事件处理函数的参数列表
     * @param filter 自定义过滤器
     */
    fire(type, args, filter) {
        let instance = this, namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, list = instance.listeners[namespace.type], isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        if (list) {
            // 避免遍历过程中，数组发生变化，比如增删了
            list = _util_object__WEBPACK_IMPORTED_MODULE_2__.copy(list);
            /*
             * 判断是否是发射事件
             * 如果 args 的第一个参数是 CustomEvent 类型，表示发射事件
             * 因为事件处理函数的参数列表是 (event, data)
             */
            const event = args && args[0] instanceof _CustomEvent__WEBPACK_IMPORTED_MODULE_3__["default"]
                ? args[0]
                : _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                // 命名空间不匹配
                if (!matchNamespace(namespace.ns, options, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE)
                    // 在 fire 过程中被移除了
                    || !_util_array__WEBPACK_IMPORTED_MODULE_4__.has(list, options)
                    // 传了 filter，则用 filter 判断是否过滤此 options
                    || (filter && !filter(namespace, args, options))) {
                    return;
                }
                /*
                 * 为 event 对象加上当前正在处理的 listener
                 * 这样方便业务层移除事件绑定
                 * 比如 on('xx', function) 这样定义了匿名 listener
                 * 在这个 listener 里面获取不到当前 listener 的引用
                 * 为了能引用到，有时候会先定义 var listener = function
                 * 然后再 on('xx', listener) 这样其实是没有必要的
                 */
                if (event) {
                    event.listener = options.fn;
                }
                let result = (0,_function_execute__WEBPACK_IMPORTED_MODULE_5__["default"])(options.fn, options.ctx, args);
                if (event) {
                    event.listener = _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
                }
                // 执行次数
                options.num = options.num ? (options.num + 1) : 1;
                // 注册的 listener 可以指定最大执行次数
                if (options.num === options.max) {
                    instance.off(namespace, options.fn);
                }
                // 如果没有返回 false，而是调用了 event.stop 也算是返回 false
                if (event) {
                    if (result === _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                        event.prevent().stop();
                    }
                    else if (event.isStopped) {
                        result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                    }
                }
                if (result === _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    return isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
        }
        return isComplete;
    }
    /**
     * 注册监听
     *
     * @param type
     * @param listener
     */
    on(type, listener) {
        const instance = this, listeners = instance.listeners, options = _util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)
            ? { fn: listener }
            : listener;
        if (_util_is__WEBPACK_IMPORTED_MODULE_1__.object(options) && _util_is__WEBPACK_IMPORTED_MODULE_1__.func(options.fn)) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type;
            options.ns = namespace.ns;
            _util_array__WEBPACK_IMPORTED_MODULE_4__.push(listeners[namespace.type] || (listeners[namespace.type] = []), options);
        }
        else if (true) {
            _util_logger__WEBPACK_IMPORTED_MODULE_6__.fatal('emitter.on(type, listener) invoke failed：\n\n"listener" is expected to be a Function or an EmitterOptions.\n', cheap__fileName__0, 196);
        }
        return this;
    }
    one(type, listener) {
        if (_util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)) {
            listener = {
                fn: listener,
                max: 1
            };
        }
        else {
            listener.max = 1;
        }
        return this.on(type, listener);
    }
    /**
     * 取消监听
     *
     * @param type
     * @param listener
     */
    off(type, listener) {
        const instance = this, listeners = instance.listeners;
        if (type) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, matchListener = createMatchListener(listener), each = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options, index) {
                    if (matchListener(options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            }, eachNS = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options, index) {
                    if (matchNamespace(ns, options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            };
            if (name) {
                if (listeners[name]) {
                    each(listeners[name], name);
                }
            }
            else if (ns) {
                _util_object__WEBPACK_IMPORTED_MODULE_2__.each(listeners, eachNS);
            }
            /*
             * 在开发阶段进行警告，比如传了 listener 进来，listener 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 1 && listener == _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`emitter.off(type, listener) is invoked, but "listener" is ${listener}.`, cheap__fileName__0, 288);
                }
            }
        }
        else {
            // 清空
            instance.listeners = {};
            /*
             * 在开发阶段进行警告，比如传了 type 进来，type 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 0) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`emitter.off(type) is invoked, but "type" is ${type}.`, cheap__fileName__0, 302);
                }
            }
        }
    }
    /**
     * 是否已监听某个事件
     *
     * @param type
     * @param listener
     */
    has(type, listener) {
        let instance = this, listeners = instance.listeners, namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE, matchListener = createMatchListener(listener), each = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                if (matchListener(options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
            return result;
        }, eachNS = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                if (matchNamespace(ns, options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
            return result;
        };
        if (name) {
            if (listeners[name]) {
                each(listeners[name]);
            }
        }
        else if (ns) {
            _util_object__WEBPACK_IMPORTED_MODULE_2__.each(listeners, eachNS);
        }
        return !result;
    }
    /**
     * 把事件类型解析成命名空间格式
     *
     * @param type
     */
    parse(type) {
        /*
         * 这里 ns 必须为字符串
         * 用于区分 event 对象是否已完成命名空间的解析
         */
        const result = {
            type,
            ns: _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING,
        };
        // 是否开启命名空间
        if (this.ns) {
            const index = _util_string__WEBPACK_IMPORTED_MODULE_7__.indexOf(type, _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT);
            if (index >= 0) {
                result.type = _util_string__WEBPACK_IMPORTED_MODULE_7__.slice(type, 0, index);
                result.ns = _util_string__WEBPACK_IMPORTED_MODULE_7__.slice(type, index + 1);
            }
        }
        return result;
    }
}
function matchTrue() {
    return _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
}
/**
 * 外部会传入 Function 或 EmitterOptions 或 空
 *
 * 这里根据传入值的不同类型，创建不同的判断函数
 *
 * 如果传入的是 EmitterOptions，则全等判断
 *
 * 如果传入的是 Function，则判断函数是否全等
 *
 * 如果传入的是空，则直接返回 true
 *
 * @param listener
 */
function createMatchListener(listener) {
    return _util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)
        ? function (options) {
            return listener === options.fn;
        }
        : matchTrue;
}
/**
 * 判断 options 是否能匹配命名空间
 *
 * 如果 namespace 和 options.ns 都不为空，则需完全匹配
 *
 * 如果他们两个其中任何一个为空，则不判断命名空间
 *
 * @param namespace
 * @param options
 */
function matchNamespace(namespace, options, isFire) {
    const { ns } = options;
    return ns && namespace
        ? ns === namespace
        : (isFire ? _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE : _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE);
}


/***/ }),

/***/ "./src/common/function/checkVersion.ts":
/*!*********************************************!*\
  !*** ./src/common/function/checkVersion.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ checkVersion)
/* harmony export */ });
/* harmony import */ var _toNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber */ "./src/common/function/toNumber.ts");
/**
 * @file 判断版本
 */

/**
 * 判断给定版本是否符合条件
 *
 * @param version 待检查版本
 * @param checkVersion 版本基准
 * @param equal 是否判等
 *
 * @returns 是否符合条件
 */
function checkVersion(version, checkVersion, equal = false) {
    const checkVersionArr = checkVersion.split('.');
    const versionArr = version.split('.');
    for (let i = 0; i < versionArr.length; i++) {
        if (equal && i == (versionArr.length - 1) && (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) >= (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return versionArr.length >= checkVersionArr.length;
        }
        if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) > (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return true;
        }
        else if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) < (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return false;
        }
        if (i === checkVersionArr.length - 1 && i === versionArr.length - 1) {
            return equal;
        }
        if (i === checkVersionArr.length - 1) {
            return true;
        }
        else if (i === versionArr.length - 1) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/common/function/concatTypeArray.ts":
/*!************************************************!*\
  !*** ./src/common/function/concatTypeArray.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ concatTypeArray)
/* harmony export */ });
/**
 * @file 合并 TypeArray
 */
function concatTypeArray(constructor, arrays) {
    if (!arrays.length) {
        return null;
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    let array;
    for (array of arrays) {
        totalLength += array.length;
    }
    let result = new constructor(totalLength);
    let offset = 0;
    for (array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/debounce.ts":
/*!*****************************************!*\
  !*** ./src/common/function/debounce.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var _execute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 防抖函数
 */



/**
 * 防抖函数
 *
 * @param fn 需要节制调用的函数
 * @param delay 调用的时间间隔，单位毫秒
 * @param immediate 是否立即触发
 * @return 节流函数
 */
function debounce(fn, delay, immediate) {
    let timer;
    return function () {
        let context = this;
        if (!timer) {
            const args = _util_array__WEBPACK_IMPORTED_MODULE_0__.toArray(arguments);
            if (immediate) {
                (0,_execute__WEBPACK_IMPORTED_MODULE_1__["default"])(fn, context, args);
            }
            timer = setTimeout(function () {
                timer = _util_constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                if (!immediate) {
                    (0,_execute__WEBPACK_IMPORTED_MODULE_1__["default"])(fn, context, args);
                }
            }, delay);
        }
    };
}


/***/ }),

/***/ "./src/common/function/execute.ts":
/*!****************************************!*\
  !*** ./src/common/function/execute.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ execute)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 使用指定上下文执行函数
 */


/**
 * 任性地执行一个函数，不管它有没有、是不是
 *
 * @param fn 调用的函数
 * @param context 执行函数时的 this 指向
 * @param args 调用函数的参数，多参数时传入数组
 * @return 调用函数的返回值
 */
function execute(fn, context, args) {
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(fn)) {
        return _util_is__WEBPACK_IMPORTED_MODULE_0__.array(args)
            ? fn.apply(context, args)
            : context !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                ? fn.call(context, args)
                : args !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                    ? fn(args)
                    : fn();
    }
}


/***/ }),

/***/ "./src/common/function/generateUUID.ts":
/*!*********************************************!*\
  !*** ./src/common/function/generateUUID.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateUUID)
/* harmony export */ });
/**
 * 生成唯一 id
 *
 * @internal
 * @returns id
 */
function generateUUID() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}


/***/ }),

/***/ "./src/common/function/getTimestamp.ts":
/*!*********************************************!*\
  !*** ./src/common/function/getTimestamp.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimestamp)
/* harmony export */ });
function getTimestamp() {
    return Date.now();
}


/***/ }),

/***/ "./src/common/function/isAudioWorklet.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isAudioWorklet.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAudioWorklet)
/* harmony export */ });
function isAudioWorklet() {
    // @ts-ignore
    return typeof registerProcessor === 'function' && typeof sampleRate === 'number' && typeof currentFrame === 'number' && typeof currentTime === 'number';
}


/***/ }),

/***/ "./src/common/function/isDef.ts":
/*!**************************************!*\
  !*** ./src/common/function/isDef.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDef)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 判断是否定义
 */

/**
 * 判断是否定义
 *
 * @param target 待判定变量
 */
function isDef(target) {
    return target !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
}


/***/ }),

/***/ "./src/common/function/isLittleEndian.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isLittleEndian.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLittleEndian)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");

let _isLittleEndian;
function isLittleEndian() {
    if ((0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(_isLittleEndian)) {
        return _isLittleEndian;
    }
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    // little-endian write
    view.setInt16(0, 256, true);
    // platform-spec read, if equal then LE
    _isLittleEndian = (new Int16Array(buf))[0] === 256;
    return _isLittleEndian;
}


/***/ }),

/***/ "./src/common/function/isNative.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isNative.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNative)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toString */ "./src/common/function/toString.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/**
 * @file 判断是否是 native 方法
 */



/**
 * 判断是否是 native 方法
 *
 * @param target 待判定函数
 */
function isNative(target) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(target) && _util_string__WEBPACK_IMPORTED_MODULE_1__.has((0,_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(target), '[native code]');
}


/***/ }),

/***/ "./src/common/function/isWorker.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isWorker.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isWorker)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");


function isWorker() {
    return !(typeof window === 'object' && (0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(window.document)) && !(0,_isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__["default"])();
}


/***/ }),

/***/ "./src/common/function/nextTick.ts":
/*!*****************************************!*\
  !*** ./src/common/function/nextTick.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isNative__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNative */ "./src/common/function/isNative.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 下一个时间片
 */


let nextTick;
// IE (10+) 和 node
if (typeof setImmediate === _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_1__["default"])(setImmediate)) {
    nextTick = setImmediate;
}
/*
 * 用 MessageChannel 去做 setImmediate 的 polyfill
 * 原理是将新的 message 事件加入到原有的 dom events 之后
 * 兼容性 IE10+ 和其他标准浏览器
 */
if (typeof MessageChannel === _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_1__["default"])(MessageChannel)) {
    nextTick = function (fn) {
        const channel = new MessageChannel();
        channel.port1.onmessage = fn;
        channel.port2.postMessage(1);
    };
}
else if (typeof setTimeout === 'function') {
    nextTick = setTimeout;
}
// 没有 setTimeout 是环境，比如 WorkletGlobalScope，先固定一个插槽
else {
    nextTick = function (fn) {
        setTimeout(fn);
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nextTick);


/***/ }),

/***/ "./src/common/function/restrain.ts":
/*!*****************************************!*\
  !*** ./src/common/function/restrain.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ restrain)
/* harmony export */ });
/**
 * @file 对值的范围进行约束
 */
/**
 * 对值的范围进行约束
 *
 * @param value 值
 * @param min 最小值
 * @param max 最大值
 *
 * @returns 约束之后的值
 */
function restrain(value, min, max) {
    if (value < min) {
        value = min;
    }
    else if (value > max) {
        value = max;
    }
    return value;
}


/***/ }),

/***/ "./src/common/function/sourceLoad.ts":
/*!*******************************************!*\
  !*** ./src/common/function/sourceLoad.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * 将某个文件的代码变成字符串（Webpack 使用）
 */
const webpackBootstrapFunc = `
function webpackBootstrapFunc (modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if(installedModules[moduleId])
    return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    if (!modules[moduleId]) {
      console.log('can not found module:', moduleId)
    }
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.i = function(value) { return value; };
  __webpack_require__.d = function(exports, definition, getter) {
    if (typeof definition === 'string') {
      if(!__webpack_require__.o(exports, definition)) {
        Object.defineProperty(exports, definition, {
          enumerable: true,
          get: getter
        });
      }
    }
    else {
      for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
        }
      }
    }
  };
  __webpack_require__.r = function(exports) {
    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    	Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    }
    Object.defineProperty(exports, '__esModule', { value: true });
  };
  __webpack_require__.f = {};
  __webpack_require__.e = function(chunkId) {
    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {
      __webpack_require__.f[key](chunkId, promises);
        return promises;
    	}, []));
	};
  __webpack_require__.u = function(chunkId) {
    return chunkId + "LIB_NAME";
  };
  __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ?
      function getDefault() { return module['default']; } :
      function getModuleExports() { return module; };
    __webpack_require__.d(getter, 'a', getter);
    return getter;
  };
  (function() {
    var installedChunks = {
      "main": 0
    };
    __webpack_require__.f.j = function(chunkId, promises) {
      var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
      if (installedChunkData !== 0) {
        if(installedChunkData) {
          promises.push(installedChunkData[2]);
        } else {
          if (true) {
            var promise = new Promise(function(resolve, reject){installedChunkData = installedChunks[chunkId] = [resolve, reject]});
            promises.push(installedChunkData[2] = promise);
            var url = __webpack_require__.p + __webpack_require__.u(chunkId);
            var error = new Error();
            var loadingEnded = function(event) {
              if(__webpack_require__.o(installedChunks, chunkId)) {
                installedChunkData = installedChunks[chunkId];
                if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
                if(installedChunkData) {
                  var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                  var realSrc = url;
                  error.message = "Loading chunk " + chunkId + " failed.\\n(" + errorType + ": " + realSrc + ")";
                  error.name = "ChunkLoadError";
                  error.type = errorType;
                  error.request = realSrc;
                  installedChunkData[1](error);
                }
              }
            };
            __webpack_require__.l(url, loadingEnded);
          }
        }
      }
    };
    var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
    var [chunkIds, moreModules, runtime] = data;
    var moduleId, chunkId, i = 0;
    if (chunkIds.some(function(id){return installedChunks[id] !== 0})) {
      for(moduleId in moreModules) {
        if(__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if(runtime) runtime(__webpack_require__);
    }
    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
      for (;i < chunkIds.length; i++) {
        chunkId = chunkIds[i];
        if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
          installedChunks[chunkId][0]();
        }
        installedChunks[chunkId] = 0;
      }
    }
    var self = typeof globalThis !== undefined ? globalThis : self
    var chunkLoadingGlobal = self["webpackChunkAVPlayer"] = self["webpackChunkAVPlayer"] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
  })();
  (function() {
    var inProgress = {};
    __webpack_require__.l = function(url, done) {
      if (inProgress[url]) { inProgress[url].push(done); return; }
        inProgress[url] = [done];
        var onComplete = function(event) {
          clearTimeout(timeout);
          var doneFns = inProgress[url];
          delete inProgress[url];
          doneFns && doneFns.forEach(function(fn){fn(event)});
        }
        var timeout = setTimeout(onComplete.bind(null, undefined, { type: "timeout" }), 120000);
      import(url).then(function() {
        onComplete({
          type: "load"
        })
      }, function (error) {
        onComplete({
          type: "missing"
        })
      });
    };
  })();
  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  __webpack_require__.p = "ROOT_URL";
  __webpack_require__.oe = function(err) { console.error(err); throw err; };
  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);
  return f;
}
`;
const moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@|!]+';
// additional chars when output.path info is true
const dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)';
// http://stackoverflow.com/a/2593661/130442
function quoteRegExp(str) {
    return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}
function isNumeric(n) {
    // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
    return !isNaN(n);
}
function getModuleDependencies(sources, module, queueName, requiredModules) {
    const retval = {};
    retval[queueName] = [];
    let fnString = module.toString();
    const wrapperSignature = fnString.match(/^(function)?\s?\w*\(\w+,\s*(\w+),\s*(\w+)\)/);
    if (!wrapperSignature) {
        return retval;
    }
    const webpackRequireName = wrapperSignature[3];
    if (!requiredModules.__webpack_exports_process__) {
        requiredModules.__webpack_require__ = webpackRequireName;
        requiredModules.__webpack_exports__ = wrapperSignature[2];
        requiredModules.__webpack_exports_process__ = true;
    }
    // main bundle deps
    let re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');
    let match;
    while ((match = re.exec(fnString))) {
        if (match[3] === 'dll-reference') {
            continue;
        }
        retval[queueName].push(match[3]);
    }
    // dll deps
    re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g');
    while ((match = re.exec(fnString))) {
        if (!sources[match[2]]) {
            retval[queueName].push(match[1]);
            // @ts-ignore
            sources[match[2]] = __webpack_require__(match[1]).m;
        }
        retval[match[2]] = retval[match[2]] || [];
        retval[match[2]].push(match[4]);
    }
    // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
    const keys = Object.keys(retval);
    for (let i = 0; i < keys.length; i++) {
        for (let j = 0; j < retval[keys[i]].length; j++) {
            if (isNumeric(+retval[keys[i]][j])) {
                retval[keys[i]][j] = +retval[keys[i]][j];
            }
        }
    }
    return retval;
}
function hasValuesInQueues(queues) {
    const keys = Object.keys(queues);
    return keys.reduce(function (hasValues, key) {
        return hasValues || queues[key].length > 0;
    }, false);
}
function getRequiredModules(sources, moduleId) {
    const modulesQueue = {
        main: [moduleId]
    };
    const requiredModules = {
        main: [],
        __webpack_exports__: '__webpack_exports__',
        __webpack_require__: '__webpack_require__',
        __webpack_exports_process__: false
    };
    const seenModules = {
        main: {}
    };
    while (hasValuesInQueues(modulesQueue)) {
        const queues = Object.keys(modulesQueue);
        for (let i = 0; i < queues.length; i++) {
            let queueName = queues[i];
            let queue = modulesQueue[queueName];
            let moduleToCheck = queue.pop();
            seenModules[queueName] = seenModules[queueName] || {};
            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) {
                continue;
            }
            seenModules[queueName][moduleToCheck] = true;
            requiredModules[queueName] = requiredModules[queueName] || [];
            requiredModules[queueName].push(moduleToCheck);
            let newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName, requiredModules);
            let newModulesKeys = Object.keys(newModules);
            for (let j = 0; j < newModulesKeys.length; j++) {
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
            }
        }
    }
    return requiredModules;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {
    const sources = {
        // @ts-ignore
        main: __webpack_require__.m
    };
    const requiredModules = getRequiredModules(sources, moduleId);
    let src = '';
    let stringifyModuleId = JSON.stringify(moduleId);
    return src + 'var ' + options.varName + '=(' + webpackBootstrapFunc.replace('ENTRY_MODULE', stringifyModuleId)
        // @ts-ignore
        .replace('ROOT_URL', __webpack_require__.p || '')
        // @ts-ignore
        .replace('LIB_NAME', __webpack_require__.u && __webpack_require__.u('') || '')
        + ')({' + requiredModules.main.map(function (id) {
        const stringifyId = JSON.stringify(id);
        let source = '' + stringifyId + ': ' + sources.main[id].toString();
        if (stringifyId === stringifyModuleId && options.exportName && options.pointName) {
            const line = `;${requiredModules.__webpack_require__}.d(
          ${requiredModules.__webpack_exports__},
          "${options.exportName}",
          function() {
            if (${options.exportIsClass}) {
              for (var key in ${requiredModules.__webpack_exports__}) {
                if (key === '${options.exportName}') {
                  continue;
                }
                var v = ${requiredModules.__webpack_exports__}[key];
                if (typeof v === 'function' && v.name === '${options.pointName}') {
                  return v;
                }
              }
            }
            return ${options.pointName};
          }
        );`;
            source = source.slice(0, source.length - 1) + line + '}';
        }
        return source;
    }).join(',') + '});';
}


/***/ }),

/***/ "./src/common/function/split.ts":
/*!**************************************!*\
  !*** ./src/common/function/split.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ split)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * @file 拆解字符串，并 trim 每个部分
 */


/**
 * 拆解字符串，并 trim 每个部分
 *
 * @param str 字符串
 * @param sep 分隔符
 */
function split(str, sep) {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.number(str)) {
        str = str + '';
    }
    if (str && _util_is__WEBPACK_IMPORTED_MODULE_0__.string(str)) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(str.split(sep), (part, index) => {
            part = part.trim();
            if (part) {
                result.push(part);
            }
        });
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/toNumber.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toNumber.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toNumber)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 number
 */


/**
 * 强转为 number
 *
 * @param target 待转换值
 * @param defaultValue 默认值
 *
 * @returns 转换之后的值
 */
function toNumber(target, defaultValue) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(target)
        ? +target
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
            ? defaultValue
            : 0;
}


/***/ }),

/***/ "./src/common/function/toString.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toString.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 string
 */

/**
 * 强转为 string
 *
 * @param target 待转换的值
 * @param defaultValue 默认值
 * @returns 转换之后的值
 */
function toString(target, defaultValue) {
    return target != _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL && target.toString
        ? target.toString()
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED
            ? defaultValue
            : _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING;
}


/***/ }),

/***/ "./src/common/interface/ArrayLike.ts":
/*!*******************************************!*\
  !*** ./src/common/interface/ArrayLike.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayLike)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");

class ArrayLike {
    proxy;
    constructor() {
        this.proxy = new Proxy(this, {
            get(target, p, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    return target.getIndexValue(+p);
                }
                else {
                    return target[p];
                }
            },
            set(target, p, newValue, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    target.setIndexValue(+p, newValue);
                }
                else {
                    target[p] = newValue;
                }
                return true;
            }
        });
    }
}


/***/ }),

/***/ "./src/common/io/BitReader.ts":
/*!************************************!*\
  !*** ./src/common/io/BitReader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/common/io/BitReader.ts";

class BitReader {
    buffer;
    pointer;
    bitsLeft;
    size;
    endPointer;
    error;
    onFlush;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitsLeft = 8;
        this.size = size;
        this.endPointer = 0;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     * 不影响原读取操作的情况下，读取 1 个比特
     */
    peekU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        let pointer = this.pointer;
        let bitsLeft = this.bitsLeft;
        if (bitsLeft === 0) {
            pointer++;
            bitsLeft = 8;
        }
        result = (this.buffer[pointer] >> (bitsLeft - 1)) & 0x01;
        return result;
    }
    /**
     * 读取 1 个比特
     */
    readU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        this.bitsLeft--;
        result = (this.buffer[this.pointer] >> this.bitsLeft) & 0x01;
        if (this.bitsLeft === 0) {
            this.pointer++;
            this.bitsLeft = 8;
        }
        return result;
    }
    /**
     * 读取 n 个比特
     *
     * @param n
     */
    readU(n) {
        let result = 0;
        for (let i = 0; i < n; i++) {
            result |= (this.readU1() << (n - i - 1));
        }
        return result;
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOReader error, flush failed because of no flush callback');
        }
        if (this.bitsLeft === 0) {
            this.pointer++;
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            const len = this.onFlush(this.buffer.subarray(this.endPointer - this.pointer, this.size));
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
            this.endPointer = this.endPointer - this.pointer + len;
            this.pointer = 0;
        }
        else {
            const len = this.onFlush(this.buffer);
            this.endPointer = len;
            this.pointer = 0;
            this.bitsLeft = 8;
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('BSReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 170);
            }
        }
    }
    clear() {
        this.pointer = this.endPointer = 0;
        this.bitsLeft = 8;
        this.error = 0;
    }
    skipPadding() {
        if (this.bitsLeft < 8) {
            this.bitsLeft = 8;
            this.pointer++;
        }
    }
}


/***/ }),

/***/ "./src/common/io/BufferReader.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferReader.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferReader)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 读字节流工具
 */


class BufferReader {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    readUint8() {
        return this.data.getUint8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    readUint16() {
        const value = this.data.getUint16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    readUint24() {
        const high = this.readUint16();
        const low = this.readUint8();
        return high << 8 | low;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    readUint32() {
        const value = this.data.getUint32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    readUint64() {
        const high = BigInt(this.readUint32());
        const low = BigInt(this.readUint32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    readInt8() {
        return this.data.getInt8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    readInt16() {
        const value = this.data.getInt16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    readInt32() {
        const value = this.data.getInt32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    readInt64() {
        const high = BigInt(this.readInt32());
        const low = BigInt(this.readInt32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    readFloat() {
        const value = this.data.getFloat32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    readDouble() {
        const value = this.data.getFloat64(this.pos + this.byteStart, this.littleEndian);
        this.pos += 8;
        return value;
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = this.readUint8().toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    readString(length = 1) {
        let str = '';
        if (length) {
            let start = this.pos;
            for (let i = 0; i < length; i++) {
                if (this.buffer[this.pos + i] === 0) {
                    start++;
                }
                else {
                    break;
                }
            }
            str = _util_text__WEBPACK_IMPORTED_MODULE_0__.decode(this.buffer.subarray(start, start + length));
        }
        this.pos += length;
        return str;
    }
    /**
     * 读取一行字符
     */
    readLine() {
        let str = '';
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += this.readString(i - this.pos);
                break;
            }
        }
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPos() {
        return BigInt(this.pos);
    }
    /**
     * seek 读取指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 读取指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    readBuffer(length) {
        length = Math.min(length, this.remainingSize());
        const buffer = this.buffer.slice(this.pos, this.pos + length);
        this.pos += length;
        return buffer;
    }
    /**
     * 追加 buffer
     *
     * @param buffer
     */
    appendBuffer(buffer) {
        this.buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Uint8Array, [
            this.buffer.slice(),
            buffer.slice()
        ]);
        this.data = new DataView(this.buffer.buffer);
        this.size += buffer.byteLength;
        this.byteStart = 0;
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/BufferWriter.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferWriter.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferWriter)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
var cheap__fileName__0 = "src/common/io/BufferWriter.ts";
/**
 * 写字节流工具
 */


class BufferWriter {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        this.data.setUint8(this.pos++ + this.byteStart, value);
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        this.data.setUint16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        const high = value & 0xf00;
        const middle = value & 0x0f0;
        const low = value & 0x00f;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        this.data.setUint32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeUint32(Number(low));
            this.writeUint32(Number(high));
        }
        else {
            this.writeUint32(Number(high));
            this.writeUint32(Number(low));
        }
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        this.data.setInt8(this.pos++ + this.byteStart, value);
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        this.data.setInt16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        this.data.setInt32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeInt32(Number(low));
            this.writeInt32(Number(high));
        }
        else {
            this.writeInt32(Number(high));
            this.writeInt32(Number(low));
        }
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        this.data.setFloat32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        this.data.setFloat64(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 8;
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * seek 写指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        let length = buffer.length;
        if (this.remainingSize() < length) {
            length = this.remainingSize();
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`the remaining buffer size is smaller then the wrote buffer, hope set ${buffer.length}, but set ${length}`, cheap__fileName__0, 211);
        }
        this.buffer.set(buffer, this.pos);
        this.pos += buffer.length;
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_1__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    getWroteBuffer() {
        return this.buffer.subarray(0, this.pos);
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/IOReader.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOReader.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/* harmony import */ var _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../timer/Sleep */ "./src/common/timer/Sleep.ts");
var cheap__fileName__0 = "src/common/io/IOReader.ts";



class IOReader {
    data;
    buffer;
    pointer;
    endPointer;
    pos;
    size;
    littleEndian;
    fileSize_;
    error;
    onFlush;
    onSeek;
    onSize;
    flags;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pos = BigInt(0);
        this.pointer = 0;
        this.error = 0;
        this.endPointer = 0;
        this.littleEndian = !bigEndian;
        this.flags = 0;
        if (map) {
            this.size = size;
            this.buffer = map;
            this.data = map.view;
        }
        else {
            this.size = Math.max(size, 102400);
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    async readUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getUint8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getUint8(this.pointer);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    async readUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getUint16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getUint16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    async readUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const high = await this.readUint16();
        const low = await this.readUint8();
        return high << 8 | low;
    }
    async peekUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        const high = await this.readUint16();
        const low = await this.readUint8();
        const value = high << 8 | low;
        this.pointer = pointer;
        this.pos = pos;
        return value;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    async readUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getUint32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getUint32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    async readUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigUint64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigUint64(this.pointer, this.littleEndian);
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    async readInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getInt8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getInt8(this.pointer);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    async readInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getInt16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getInt16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    async readInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getInt32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getInt32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    async readInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigInt64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigInt64(this.pointer, this.littleEndian);
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    async readFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getFloat32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getFloat32(this.pointer, this.littleEndian);
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    async readDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getFloat64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getFloat64(this.pointer, this.littleEndian);
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    async readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    async peekHex(length = 1) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekHex, length too large', cheap__fileName__0, 324);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        this.pointer = pointer;
        this.pos = pos;
        return hexStr;
    }
    async readBuffer(length, buffer) {
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
        }
        return buffer;
    }
    async peekBuffer(length, buffer) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekBuffer, length too large', cheap__fileName__0, 400);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
        return buffer;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    async readString(length = 1) {
        const buffer = await this.readBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    async peekString(length = 1) {
        const buffer = await this.peekBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    /**
     * 读取一行字符
     */
    async readLine() {
        let str = '';
        while (true) {
            let got = false;
            for (let i = this.pointer; i < this.endPointer; i++) {
                if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                    str += await this.readString(i - this.pointer);
                    got = true;
                    break;
                }
            }
            if (!got) {
                str += await this.readString(this.remainingLength());
                await this.flush();
            }
            else {
                break;
            }
        }
        while (true) {
            const next = await this.peekUint8();
            if (next === 0x0a || next === 0x0d) {
                await this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    async peekLine() {
        if (this.remainingLength() < this.size) {
            await this.flush();
        }
        let str = '';
        let got = false;
        for (let i = this.pointer; i < this.endPointer; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += await this.peekString(i - this.pointer);
                got = true;
                break;
            }
        }
        if (!got) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekLine, out of buffer', cheap__fileName__0, 486);
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 获取已读字节偏移
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    async skip(length) {
        const backup = length;
        while (this.remainingLength() < length) {
            length -= this.remainingLength();
            this.pointer = this.endPointer;
            await this.flush();
        }
        if (this.remainingLength() >= length) {
            this.pointer += length;
        }
        this.pos += BigInt(backup);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    async flush_(buffer) {
        while (true) {
            const len = await this.onFlush(buffer);
            if (len !== -1048575 /* IOError.AGAIN */) {
                return len;
            }
            await new _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__["default"](0);
        }
    }
    async flush(need = 0) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, flush failed because of no flush callback', cheap__fileName__0, 554);
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        need = Math.min(need, this.size);
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
        }
        else {
            this.endPointer = 0;
        }
        this.pointer = 0;
        if (need) {
            while (this.remainingLength() < need) {
                const len = await this.flush_(this.buffer.subarray(this.endPointer));
                if (len < 0) {
                    this.error = len;
                    throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
                }
                this.endPointer += len;
            }
        }
        else {
            const len = await this.flush_(this.buffer.subarray(this.endPointer));
            if (len < 0) {
                this.error = len;
                throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
            }
            this.endPointer += len;
        }
    }
    async seek(pos, force = false, flush = true) {
        if (!force) {
            const len = Number(pos - this.pos);
            // 可以往回 seek
            if (len < 0 && Math.abs(len) < this.pointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            // 可以直接往后 seek
            else if (len > 0 && this.pointer + len < this.endPointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            else if (len === 0) {
                return;
            }
        }
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed because of no seek callback', cheap__fileName__0, 615);
        }
        this.pointer = this.endPointer = 0;
        this.pos = pos;
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed', cheap__fileName__0, 624);
        }
        if (flush) {
            await this.flush();
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('IOReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 654);
            }
        }
    }
    reset() {
        this.pointer = this.endPointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    async fileSize() {
        if (this.fileSize_) {
            return this.fileSize_;
        }
        if (!this.onSize) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, fileSize failed because of no onSize callback', cheap__fileName__0, 675);
        }
        this.fileSize_ = await this.onSize();
        return this.fileSize_;
    }
    getBufferSize() {
        return this.size;
    }
    async pipe(ioWriter, length) {
        if (length) {
            if (this.remainingLength() < length) {
                if (this.remainingLength() > 0) {
                    const len = this.remainingLength();
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
                while (length > 0) {
                    await this.flush();
                    const len = Math.min(this.remainingLength(), length);
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
            }
            else {
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + length));
                this.pointer += length;
                this.pos += BigInt(length);
            }
        }
        else {
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
            while (await this.flush_(this.buffer.subarray(0)) > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
        }
    }
}


/***/ }),

/***/ "./src/common/io/IOWriter.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOWriter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriter)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriter {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map) {
            this.buffer = map;
            this.data = map.view;
        }
        else {
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    async writeUint8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    async writeUint16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    async writeUint24(value) {
        if (this.remainingLength() < 3) {
            await this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            await this.writeUint8(low);
            await this.writeUint8(middle);
            await this.writeUint8(high);
        }
        else {
            await this.writeUint8(high);
            await this.writeUint8(middle);
            await this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    async writeUint32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    async writeUint64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    async writeInt8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    async writeInt16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    async writeInt32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    async writeInt64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    async writeFloat(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    async writeDouble(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    async writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    async writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        await this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    async flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        await this.flush();
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/IOWriterSync.ts":
/*!***************************************!*\
  !*** ./src/common/io/IOWriterSync.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriterSync)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriterSync {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map) {
            this.buffer = map;
            this.data = map.view;
        }
        else {
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        if (this.remainingLength() < 3) {
            this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        this.flush();
        const ret = this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/SeekableWriteBufferQueue.ts":
/*!***************************************************!*\
  !*** ./src/common/io/SeekableWriteBufferQueue.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SeekableWriteBufferQueue)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");

class SeekableWriteBufferQueue {
    queue;
    pos;
    startPos;
    endPos;
    index;
    offset;
    constructor() {
        this.queue = [];
        this.startPos = BigInt(0);
        this.endPos = BigInt(0);
        this.pos = BigInt(0);
    }
    push(buffer) {
        if (this.pos === this.endPos) {
            this.queue.push(buffer);
            this.endPos += BigInt(buffer.length);
            this.pos += BigInt(buffer.length);
        }
        else {
            if (buffer.length < this.queue[this.index].length - this.offset) {
                this.queue[this.index].set(buffer, this.offset);
                this.offset += buffer.length;
                this.pos += BigInt(buffer.length);
                if (this.offset === this.queue[this.index].length) {
                    this.index++;
                    this.offset = 0;
                }
                if (this.index === this.queue.length) {
                    this.index = -1;
                    this.offset = -1;
                    this.pos = this.endPos;
                }
            }
            else {
                let offset = 0;
                while (offset < buffer.length) {
                    const length = Math.min(this.queue[this.index].length - this.offset, buffer.length - offset);
                    this.queue[this.index].set(buffer.subarray(offset, offset + length), this.offset);
                    offset += length;
                    this.offset += length;
                    this.pos += BigInt(length);
                    if (this.offset === this.queue[this.index].length) {
                        if (this.index + 1 === this.queue.length) {
                            if (offset < buffer.length) {
                                const remain = buffer.subarray(buffer.length - offset);
                                this.queue.push(remain);
                                this.endPos += BigInt(remain.length);
                            }
                            this.pos = this.endPos;
                            this.index = -1;
                            this.offset = -1;
                            break;
                        }
                        else {
                            this.index++;
                            this.offset = 0;
                        }
                    }
                }
            }
        }
    }
    seek(pos) {
        if (pos < this.startPos || pos > this.endPos) {
            return false;
        }
        this.pos = pos;
        this.index = -1;
        this.offset = -1;
        let now = this.startPos;
        for (let i = 0; i < this.queue.length; i++) {
            if (pos <= now + BigInt(this.queue[i].length)) {
                this.index = i;
                this.offset = Number(pos - now);
                break;
            }
            now += BigInt(this.queue[i].length);
        }
        if (this.index < 0) {
            this.pos = this.endPos;
        }
        return true;
    }
    flush() {
        this.startPos = this.endPos;
        this.pos = this.endPos;
        this.index = -1;
        this.offset = -1;
        const buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(Uint8Array, this.queue);
        this.queue.length = 0;
        return buffer;
    }
    get size() {
        return this.queue.length;
    }
}


/***/ }),

/***/ "./src/common/math/Matrix3.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix3)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/common/math/Matrix3.ts";


class Matrix3 {
    element;
    static RowMajor(matrix) {
        return new Matrix3([
            matrix[0], matrix[3], matrix[6],
            matrix[1], matrix[4], matrix[7],
            matrix[2], matrix[5], matrix[8],
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix3(matrix);
    }
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(9);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1,
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 3 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 3 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index < 9) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 47);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index < 9) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 56);
        }
    }
    /**
     * 设置成单位矩阵
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1,
        ]);
        return this;
    }
    /**
     * 设置矩阵值
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    invert() {
        const te = this.element, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            return this.set([0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 9; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix3().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Matrix4.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix4.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix4)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");
var cheap__fileName__0 = "src/common/math/Matrix4.ts";



let shared;
class Matrix4 {
    /**
     * 全局单例
     */
    static shared() {
        return shared || (shared = new Matrix4());
    }
    static RowMajor(matrix) {
        return new Matrix4([
            matrix[0], matrix[4], matrix[8], matrix[12],
            matrix[1], matrix[5], matrix[9], matrix[13],
            matrix[2], matrix[6], matrix[10], matrix[14],
            matrix[3], matrix[7], matrix[11], matrix[15]
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix4(matrix);
    }
    element;
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(16);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 4 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 4 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index <= 15) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 58);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index <= 15) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 67);
        }
    }
    /**
     * 设置成单位矩阵
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 设置矩阵值
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    /**
     * 矩阵乘法
     * @param matrix
     */
    multiply(matrix) {
        let i, a, b, e, ai0, ai1, ai2, ai3;
        e = a = this.element;
        b = matrix.element;
        if (e === b) {
            b = new Float32Array(16);
            for (i = 0; i < 16; i++) {
                b[i] = e[i];
            }
        }
        for (i = 0; i < 4; i++) {
            ai0 = a[i];
            ai1 = a[i + 4];
            ai2 = a[i + 8];
            ai3 = a[i + 12];
            e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
            e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
            e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
            e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return this;
    }
    /**
     * 矩阵乘以 3 维向量
     * @param vector3
     */
    multiplyVector3(vector3) {
        let e = this.element;
        let p = vector3.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14]
        ]);
    }
    /**
     * 矩阵乘以 4 维向量
     * @param vector4
     */
    multiplyVector4(vector4) {
        let e = this.element;
        let p = vector4.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector4([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14],
            p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15]
        ]);
    }
    /**
     * 矩阵转置
     */
    transpose() {
        let e, t;
        e = this.element;
        t = e[1], e[1] = e[4], e[4] = t;
        t = e[2], e[2] = e[8], e[8] = t;
        t = e[3], e[3] = e[12], e[12] = t;
        t = e[6], e[6] = e[9], e[9] = t;
        t = e[7], e[7] = e[13], e[13] = t;
        t = e[11], e[11] = e[14], e[14] = t;
        return this;
    }
    /**
     * 求特定矩阵的逆矩阵，并设置成当前矩阵
     * @param matrix
     */
    setInverseOf(matrix) {
        let i, s, d, inv, det;
        s = matrix.element;
        d = this.element;
        inv = new Float32Array(16);
        inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
        inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
        inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
        inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
        inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
        inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
        inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
        inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
        inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
        inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
        inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
        inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
        inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
        inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
        inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
        inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
        det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];
        if (det === 0) {
            return this;
        }
        det = 1 / det;
        for (i = 0; i < 16; i++) {
            d[i] = inv[i] * det;
        }
        return this;
    }
    /**
     * 求自身的逆矩阵
     */
    invert() {
        this.setInverseOf(this);
        return this;
    }
    /**
     * 设置成正射投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setOrtho(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('null frustum', cheap__fileName__0, 240);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * rw, 0, 0, 0,
            0, 2 * rh, 0, 0,
            0, 0, -2 * rd, 0,
            -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
        ]);
        return this;
    }
    /**
     * 右乘正射投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    ortho(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 设置成透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setFrustum(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('null frustum', cheap__fileName__0, 281);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('near <= 0', cheap__fileName__0, 284);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('far <= 0', cheap__fileName__0, 287);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * near * rw, 0, 0, 0,
            0, 2 * near * rh, 0, 0,
            (right + left) * rw, (top + bottom) * rh, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 右乘透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    frustum(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 设置成透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setPerspective(fovy, aspect, near, far) {
        let rd, s, ct;
        if (near === far || aspect === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('null frustum', cheap__fileName__0, 328);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('near <= 0', cheap__fileName__0, 331);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('far <= 0', cheap__fileName__0, 334);
        }
        fovy = Math.PI * fovy / 180 / 2;
        s = Math.sin(fovy);
        if (s === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('null frustum', cheap__fileName__0, 342);
        }
        rd = 1 / (far - near);
        ct = Math.cos(fovy) / s;
        this.set([
            ct / aspect, 0, 0, 0,
            0, ct, 0, 0,
            0, 0, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 右乘透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    perspective(fovy, aspect, near, far) {
        return this.multiply(new Matrix4().setPerspective(fovy, aspect, near, far));
    }
    /**
     * 将 Matrix4 实例设置为缩放变换矩阵
     * @param vector3 缩放因子
     */
    setScale(vector3) {
        this.set([
            vector3.x, 0, 0, 0,
            0, vector3.y, 0, 0,
            0, 0, vector3.z, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 右乘缩放变换矩阵
     * @param vector3 缩放因子
     */
    scale(vector3) {
        let e = this.element;
        e[0] *= vector3.x, e[1] *= vector3.x, e[2] *= vector3.x, e[3] *= vector3.x;
        e[4] *= vector3.y, e[5] *= vector3.y, e[6] *= vector3.y, e[7] *= vector3.y;
        e[8] *= vector3.z, e[9] *= vector3.z, e[10] *= vector3.z, e[11] *= vector3.z;
        return this;
    }
    /**
     * 将 Matrix4 实例设置为平移变换矩阵
     * @param vector3 平移因子
     */
    setTranslate(vector3) {
        this.set([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            vector3.x, vector3.y, vector3.z, 1
        ]);
        return this;
    }
    /**
     * 右乘平移变换矩阵
     * @param vector3 平移因子
     */
    preTranslate(vector3) {
        let e = this.element;
        e[12] += e[0] * vector3.x + e[4] * vector3.y + e[8] * vector3.z;
        e[13] += e[1] * vector3.x + e[5] * vector3.y + e[9] * vector3.z;
        e[14] += e[2] * vector3.x + e[6] * vector3.y + e[10] * vector3.z;
        e[15] += e[3] * vector3.x + e[7] * vector3.y + e[11] * vector3.z;
        return this;
    }
    /**
     * 右乘平移变换矩阵
     * @param vector3 平移因子
     */
    postTranslate(vector3) {
        let e = this.element;
        e[0] += vector3.x * e[3];
        e[1] += vector3.y * e[3];
        e[2] += vector3.z * e[3];
        e[4] += vector3.x * e[7];
        e[5] += vector3.y * e[7];
        e[6] += vector3.z * e[7];
        e[8] += vector3.x * e[11];
        e[9] += vector3.y * e[11];
        e[10] += vector3.z * e[11];
        e[12] += vector3.x * e[15];
        e[13] += vector3.y * e[15];
        e[14] += vector3.z * e[15];
        return this;
    }
    /**
     * 将 Matrix4  实例设置为旋转变换矩阵
     * @param angle 旋转角度（角度制 0-360）
     * @param vector3 旋转轴
     */
    setRotate(angle, vector3) {
        let x, y, z, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
        angle = Math.PI * angle / 180;
        x = vector3.x;
        y = vector3.y;
        z = vector3.z;
        s = Math.sin(angle);
        c = Math.cos(angle);
        if (0 !== vector3.x && 0 === vector3.y && 0 === vector3.z) {
            // Rotation around X axis
            if (vector3.x < 0) {
                s = -s;
            }
            this.set([
                1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 !== vector3.y && 0 === vector3.z) {
            // Rotation around Y axis
            if (vector3.y < 0) {
                s = -s;
            }
            this.set([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 === vector3.y && 0 !== vector3.z) {
            // Rotation around Z axis
            if (vector3.z < 0) {
                s = -s;
            }
            this.set([
                c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        else {
            // Rotation around another axis
            len = vector3.magnitude;
            if (len !== 1) {
                rlen = 1 / len;
                x *= rlen;
                y *= rlen;
                z *= rlen;
            }
            nc = 1 - c;
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;
            this.set([
                x * x * nc + c, xy * nc + zs, zx * nc - ys, 0,
                xy * nc - zs, y * y * nc + c, yz * nc + xs, 0,
                zx * nc + ys, yz * nc - xs, z * z * nc + c, 0,
                0, 0, 0, 1
            ]);
        }
        return this;
    }
    /**
     * 右乘旋转矩阵
     * @param angle 旋转角度（角度制 0-360）
     * @param vector3 旋转轴
     */
    rotate(angle, vector3) {
        this.multiply(new Matrix4().setRotate(angle, vector3));
        return this;
    }
    /**
     * 设置成一个观察矩阵
     * @param eye 视点
     * @param center 目标
     * @param up 上方向
     */
    setLookAt(eye, center, up) {
        let fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
        fx = center.x - eye.x;
        fy = center.y - eye.y;
        fz = center.z - eye.z;
        // Normalize f.
        rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);
        fx *= rlf;
        fy *= rlf;
        fz *= rlf;
        // Calculate cross product of f and up.
        sx = fy * up.z - fz * up.y;
        sy = fz * up.x - fx * up.z;
        sz = fx * up.y - fy * up.x;
        // Normalize s.
        rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);
        sx *= rls;
        sy *= rls;
        sz *= rls;
        // Calculate cross product of s and f.
        ux = sy * fz - sz * fy;
        uy = sz * fx - sx * fz;
        uz = sx * fy - sy * fx;
        this.set([
            sx, ux, -fx, 0,
            sy, uy, -fy, 0,
            sz, uz, -fz, 0,
            0, 0, 0, 1
        ]);
        // Translate.
        return this.preTranslate(new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([-eye.x, -eye.y, -eye.z]));
    }
    /**
     * 右乘视图矩阵
     * @param eye 视点
     * @param center 目标
     * @param up 上方向
     */
    lookAt(eye, center, up) {
        return this.multiply(new Matrix4().setLookAt(eye, center, up));
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 16; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix4().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Vector3.ts":
/*!************************************!*\
  !*** ./src/common/math/Vector3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vector3: () => (/* binding */ Vector3),
/* harmony export */   Vector4: () => (/* binding */ Vector4)
/* harmony export */ });
class Vector3 {
    element;
    constructor(vector) {
        this.element = new Float32Array(3);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
        }
    }
    /**
     * 归一化
     */
    normalize() {
        let c = this.x, d = this.y, e = this.z, g = this.magnitude;
        if (g) {
            if (g === 1) {
                return this;
            }
            else {
                g = 1 / g;
                this.x = c * g;
                this.y = d * g;
                this.z = e * g;
                return this;
            }
        }
        else {
            this.x = this.y = this.z = 0;
            return this;
        }
    }
    toArray() {
        return [this.x, this.y, this.z];
    }
    get magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    get sqrMagnitude() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    get x() {
        return this.element[0];
    }
    set x(value) {
        this.element[0] = value;
    }
    get y() {
        return this.element[1];
    }
    set y(value) {
        this.element[1] = value;
    }
    get z() {
        return this.element[2];
    }
    set z(value) {
        this.element[2] = value;
    }
}
class Vector4 {
    element;
    constructor(vector) {
        this.element = new Float32Array(4);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
            this.element[4] = vector[3];
        }
    }
}


/***/ }),

/***/ "./src/common/math/matrix.ts":
/*!***********************************!*\
  !*** ./src/common/math/matrix.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat3x3: () => (/* binding */ concat3x3)
/* harmony export */ });
/* unused harmony export concat4x4 */
/* harmony import */ var _Matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");


function concat3x3(a, b) {
    const m = new _Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}
function concat4x4(a, b) {
    const m = new _Matrix4__WEBPACK_IMPORTED_MODULE_1__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c) + a.rc(r, 3) * b.rc(3, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}


/***/ }),

/***/ "./src/common/math/vector.ts":
/*!***********************************!*\
  !*** ./src/common/math/vector.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mvMul: () => (/* binding */ mvMul)
/* harmony export */ });
/* unused harmony exports add, minus, scalarProduct, dotProduct, crossProduct, rotate, vertical, angleCos, angle, extendPoint */
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");


/**
 * 向量加法
 */
function add(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([
        a.x + b.x,
        a.y + b.y,
        a.z + b.z
    ]);
}
/**
 * 向量减法
 */
function minus(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    ]);
}
/**
 * 向量乘以标量
 */
function scalarProduct(vector, scalar) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([
        vector.x * scalar,
        vector.y * scalar,
        vector.z * scalar
    ]);
}
/**
 * 向量点乘
 */
function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * 向量叉乘
 */
function crossProduct(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    ]);
}
/**
 * 向量旋转
 */
function rotate(vector, angle, axis) {
    return new _Matrix4__WEBPACK_IMPORTED_MODULE_1__["default"]().setRotate(angle, axis).multiplyVector3(vector);
}
/**
 * 求两个向量的单位法向量
 */
function vertical(a, b) {
    return crossProduct(a, b).normalize();
}
/**
 * 求两个向量的夹角余弦值
 */
function angleCos(a, b) {
    return dotProduct(a, b) / (a.magnitude * b.magnitude);
}
/**
 * 求两个向量的夹角
 */
function angle(a, b) {
    return Math.acos(angleCos(a, b));
}
/**
 * 求两个向量的线段拓展向量
 */
function extendPoint(a, b) {
    let sum = add(a, b);
    // 如果向量 a 和向量 b 方向相反，长度相等，则直接使用向量 a 或者向量 b 计算，因为其合向量为 0，使用其中一个即可计算出正交向量
    if (sum.magnitude === 0) {
        sum = a;
    }
    return crossProduct(sum, new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([0, 0, 1])).normalize();
}
/**
 * 矩阵向量相乘
 */
function mvMul(m, v) {
    const dst = new _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3([0, 0, 0]);
    for (let row = 0; row < 3; row++) {
        dst.element[row] = m.rc(row, 0) * v.x + m.rc(row, 1) * v.y + m.rc(row, 2) * v.z;
    }
    return dst;
}


/***/ }),

/***/ "./src/common/network/FakeMessageChannel.ts":
/*!**************************************************!*\
  !*** ./src/common/network/FakeMessageChannel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FakeMessageChannel)
/* harmony export */ });
class FakeMessageChannelPort extends EventTarget {
    peer;
    postMessage(message, transfer) {
        if (this.peer?.onmessage) {
            this.peer.onmessage({
                data: message
            });
        }
    }
    onmessage;
    onmessageerror;
    close() {
        this.peer = null;
    }
    start() {
    }
}
class FakeMessageChannel {
    port1;
    port2;
    constructor() {
        this.port1 = new FakeMessageChannelPort();
        this.port2 = new FakeMessageChannelPort();
        this.port1.peer = this.port2;
        this.port2.peer = this.port1;
    }
}


/***/ }),

/***/ "./src/common/network/IPCPort.ts":
/*!***************************************!*\
  !*** ./src/common/network/IPCPort.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOTIFY: () => (/* binding */ NOTIFY),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   "default": () => (/* binding */ IPCPort)
/* harmony export */ });
/* harmony import */ var _event_Emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");


const NOTIFY = 'notify';
const REQUEST = 'request';
class IPCPort extends _event_Emitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    port;
    requestMap;
    seq;
    closed;
    constructor(port) {
        super(true);
        this.port = port;
        this.port.onmessage = this.handle.bind(this);
        this.seq = 0;
        this.requestMap = new Map();
        this.port.start();
        this.closed = false;
    }
    handle(event) {
        const origin = event.data;
        const type = origin.type;
        const data = origin.data;
        if (type === 'notify') {
            this.fire(NOTIFY, data);
        }
        else if (type === 'reply') {
            const request = this.requestMap.get(data.seq);
            if (request) {
                if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(data.result)) {
                    request.resolve(data.result);
                }
                else if (data.error) {
                    request.reject(data.error);
                }
                else {
                    request.resolve(undefined);
                }
                this.requestMap.delete(data.seq);
            }
        }
        else if (type === 'request') {
            this.fire(REQUEST, data);
        }
    }
    notify(method, params = {}, transfer = []) {
        this.port.postMessage({
            type: 'notify',
            data: {
                method,
                params
            }
        }, transfer);
    }
    async request(method, params = {}, transfer = []) {
        return new Promise((resolve, reject) => {
            const id = this.seq++;
            this.requestMap.set(id, {
                resolve,
                reject
            });
            this.port.postMessage({
                type: 'request',
                data: {
                    seq: id,
                    method,
                    params
                }
            }, transfer);
        });
    }
    reply(request, result, error, transfer = []) {
        const data = {
            seq: request.seq
        };
        if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
            data.result = result;
        }
        else if (error) {
            data.error = error;
        }
        if (transfer?.length) {
            this.port.postMessage({
                type: 'reply',
                data
            }, transfer);
        }
        else {
            this.port.postMessage({
                type: 'reply',
                data
            });
        }
    }
    getPort() {
        return this.port;
    }
    destroy() {
        if (this.requestMap.size) {
            this.requestMap.forEach((req) => {
                req.reject('ipc port close');
            });
            this.requestMap.clear();
        }
        if (this.port) {
            this.port.close();
            this.port = null;
        }
        this.closed = true;
    }
}


/***/ }),

/***/ "./src/common/timer/Clock.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Clock.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clock)
/* harmony export */ });
/* harmony import */ var _function_isWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WorkerSetTimeout */ "./src/common/timer/WorkerSetTimeout.ts");
/* harmony import */ var _function_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../function/debounce */ "./src/common/function/debounce.ts");




let workerSetTimeout;
let workerSetTimeoutCounter = 0;
function createWorkerSetTimeout() {
    if (workerSetTimeout) {
        workerSetTimeoutCounter++;
        return workerSetTimeout;
    }
    workerSetTimeout = new _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_0__["default"]();
    workerSetTimeoutCounter = 1;
    return workerSetTimeout;
}
function deleteWorkerSetTimeout() {
    if (workerSetTimeoutCounter === 0) {
        return;
    }
    workerSetTimeoutCounter--;
    if (workerSetTimeoutCounter === 0) {
        workerSetTimeout.destroy();
        workerSetTimeout = null;
    }
}
class Clock {
    messageChannel;
    interval;
    started;
    timer;
    workerTimer;
    workerSetTimeout;
    onClock;
    nextTick;
    /**
     * messageChannel 执行间隔，默认 0.2
     */
    a;
    /**
     * setTimeout 最小执行间隔，默认 4
     */
    b;
    /**
     * 50 毫秒内  messageChannel 执行次数
     */
    beta;
    /**
     * 50 毫秒内  setTimeout 执行次数
     */
    alpha;
    count;
    /**
     * 等效时间
     */
    equivalent;
    timestamp;
    onVisibilityChange;
    timeoutNext;
    running;
    highPerformance;
    constructor(interval, highPerformance = true) {
        this.started = false;
        this.interval = interval;
        this.highPerformance = highPerformance;
        this.a = 0.2;
        this.b = 4;
        this.equivalent = 50;
        this.timestamp = 0;
        this.nextTick = () => {
            if (!this.started || this.running) {
                return;
            }
            this.running = true;
            if (this.interval >= 4 || !this.highPerformance) {
                this.timeoutTick();
            }
            else if (this.interval <= 0) {
                this.messageChannel.port1.postMessage(null);
            }
            else {
                const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                if (now - this.timestamp > this.equivalent) {
                    this.count = 0;
                    this.timestamp = now;
                }
                if (this.count < this.beta) {
                    this.messageChannel.port1.postMessage(null);
                }
                else {
                    this.timeoutTick();
                }
            }
        };
        this.compute();
        this.messageChannel = new MessageChannel();
        this.handleEvent();
        this.timeoutNext = (worker) => {
            if (worker) {
                this.workerTimer = null;
            }
            else {
                this.timer = null;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_2__["default"])() && document.visibilityState === 'hidden') {
            this.workerSetTimeout = createWorkerSetTimeout();
        }
        this.running = false;
    }
    compute(clear = true) {
        if (this.interval > 0) {
            this.beta = Math.ceil(this.equivalent * (1 - this.b / this.interval) / (this.a - this.b));
            this.alpha = Math.floor(this.equivalent / this.interval - this.beta);
            if (clear) {
                this.count = 0;
            }
        }
    }
    timeoutTick() {
        if (this.workerSetTimeout
            && document.visibilityState === 'hidden'
            && this.interval < 1000) {
            this.workerTimer = this.workerSetTimeout.setTimeout(this.timeoutNext, this.interval);
        }
        else {
            this.timer = setTimeout(this.timeoutNext, this.interval);
        }
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.nextTick();
    }
    stop() {
        this.started = false;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.workerTimer && this.workerSetTimeout) {
            this.workerSetTimeout.clearTimeout(this.workerTimer);
        }
        this.running = false;
    }
    isStarted() {
        return this.started;
    }
    setInterval(interval) {
        this.interval = Math.max(interval, 0);
        this.compute();
    }
    getInterval() {
        return this.interval;
    }
    isZeroTimeout() {
        return this.interval < 4;
    }
    destroy() {
        this.stop();
        if (this.workerSetTimeout) {
            deleteWorkerSetTimeout();
            this.workerSetTimeout = null;
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
    }
    handleEvent() {
        this.messageChannel.port2.onmessage = () => {
            if (!this.started) {
                return;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_2__["default"])()) {
            this.onVisibilityChange = (0,_function_debounce__WEBPACK_IMPORTED_MODULE_3__["default"])((event) => {
                if (document.visibilityState === 'hidden') {
                    this.workerSetTimeout = createWorkerSetTimeout();
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    this.nextTick();
                }
                else {
                    if (this.workerTimer) {
                        this.workerSetTimeout.clearTimeout(this.workerTimer);
                        this.workerTimer = null;
                        this.running = false;
                    }
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    deleteWorkerSetTimeout();
                    this.workerSetTimeout = null;
                    this.nextTick();
                }
            }, 20);
            document.addEventListener('visibilitychange', this.onVisibilityChange);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/LoopTask.ts":
/*!**************************************!*\
  !*** ./src/common/timer/LoopTask.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LoopTask)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/**
 * @file 可升缩循环任务队列
 */


class LoopTask {
    task;
    count;
    emptyCount;
    started;
    clock;
    timestamp;
    timeout;
    interval;
    startTimer;
    autoInterval;
    sync;
    tickAfter;
    processing;
    constructor(task, timeout = 0, interval = 0, autoInterval = true, sync = true) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.autoInterval = autoInterval;
        this.sync = sync;
        this.count = 0;
        this.emptyCount = 0;
        this.timestamp = 0;
        this.started = false;
        this.processing = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval);
        this.clock.onClock = (next) => {
            if (!this.started) {
                return;
            }
            this.count++;
            if (this.sync) {
                if (this.tickAfter) {
                    this.tickAfter();
                    this.tickAfter = null;
                }
                if (this.task() === false) {
                    this.stop();
                }
                else {
                    this.next(next);
                }
            }
            else {
                if (this.processing) {
                    return;
                }
                this.processing = true;
                this.task().then((result) => {
                    this.processing = false;
                    if (this.tickAfter) {
                        this.tickAfter();
                        this.tickAfter = null;
                    }
                    if (result === false) {
                        this.stop();
                    }
                    else {
                        this.next(next);
                    }
                });
            }
        };
    }
    next(next) {
        if (!this.started) {
            return;
        }
        const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        if (this.autoInterval && now - this.timestamp > 50) {
            const load = this.emptyCount / this.count;
            /**
             * 1000 毫秒被空闲任务调用超过 10%，将间隔减一
             * 没有空闲任务，将间隔重新置为 0
             */
            if (this.emptyCount === 0) {
                this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
            }
            else if (load < 0.1) {
                this.clock.setInterval(this.clock.getInterval() - 1);
            }
            else if (load > 0.2) {
                this.clock.setInterval(Math.min(this.clock.getInterval() + 1, 20));
            }
            else if (load > 0.5) {
                this.clock.setInterval(this.clock.getInterval() << 1);
            }
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = now;
        }
        next();
    }
    start() {
        this.started = true;
        if (this.timeout) {
            this.startTimer = setTimeout(() => {
                this.count = 0;
                this.emptyCount = 0;
                this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                this.clock.start();
                this.startTimer = null;
            }, this.timeout);
        }
        else {
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.processing = false;
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        this.clock.stop();
    }
    async stopBeforeNextTick() {
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        if (!this.clock.isStarted()) {
            return;
        }
        if (this.sync) {
            this.started = false;
            this.processing = false;
            this.clock.stop();
        }
        else {
            return new Promise((resolve) => {
                this.tickAfter = () => {
                    this.started = false;
                    this.processing = false;
                    this.clock.stop();
                    resolve();
                };
            });
        }
    }
    isStarted() {
        return this.started;
    }
    emptyTask() {
        this.emptyCount++;
    }
    isZeroTimeout() {
        return this.clock?.isZeroTimeout();
    }
    restart() {
        if (this.clock) {
            this.stop();
            this.clock.setInterval(this.interval);
            this.start();
        }
    }
    resetInterval() {
        this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
        this.emptyCount = 0;
        this.count = 0;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
    }
    destroy() {
        this.stop();
        this.task = null;
        this.timeout = null;
        this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/Sleep.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Sleep.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Sleep)
/* harmony export */ });
/**
 * @file sleep
 */
class Sleep {
    timeout;
    timer;
    resolve;
    reject;
    startTime;
    /**
     *
     * @param timeout 时间（秒）
     */
    constructor(timeout) {
        this.timeout = timeout;
    }
    then(res, rej) {
        this.resolve = res;
        this.reject = rej;
        this.startTime = Date.now();
        this.timer = setTimeout(() => {
            this.resolve(Date.now() - this.startTime);
            this.timer = null;
        }, this.timeout * 1000);
    }
    stop(resolve = true) {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
            if (this.resolve && resolve) {
                this.resolve(Date.now() - this.startTime);
            }
            else if (this.reject && !resolve) {
                this.reject(Date.now() - this.startTime);
            }
        }
    }
    reset(timeout) {
        if (timeout) {
            this.timeout = timeout;
        }
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
                this.resolve(Date.now() - this.startTime);
                this.timer = null;
            }, this.timeout * 1000);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/Timer.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Timer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Timer)
/* harmony export */ });
/**
 * @file 定时任务
 */
class Timer {
    task;
    timeout;
    interval;
    timer;
    /**
     *
     * @param task 定时任务
     * @param timeout 多久之后开始
     * @param interval 执行间隔
     */
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
    }
    /**
     * 开始执行
     */
    start() {
        const me = this;
        me.stop();
        let timeout = me.timeout;
        const interval = me.interval;
        const next = function () {
            if (me.task() !== false
                && me.timer) {
                me.timer = setTimeout(next, me.interval);
            }
            else {
                me.stop();
            }
        };
        if (timeout == null) {
            timeout = interval;
        }
        me.timer = setTimeout(next, timeout);
    }
    /**
     * 停止执行
     */
    stop() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    updateInterval(interval) {
        this.interval = interval;
    }
    /**
     * 是否正在执行
     */
    isStarted() {
        return !!this.timer;
    }
    /**
     * 销毁定时任务
     */
    destroy() {
        this.stop();
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerSetTimeout.ts":
/*!**********************************************!*\
  !*** ./src/common/timer/WorkerSetTimeout.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerSetTimeout)
/* harmony export */ });
/* harmony import */ var _function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/sourceLoad */ "./src/common/function/sourceLoad.ts");

__webpack_require__(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts");
class WorkerSetTimeout {
    worker;
    workerUrl;
    taskMap;
    id;
    constructor() {
        this.id = 0;
        this.taskMap = new Map();
        const workerSource = `
      ${(0,_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(/*require.resolve*/(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts"), { varName: 'workerSetTimeoutTask' })}
      workerSetTimeoutTask.default(self)
    `;
        const blob = new Blob([workerSource], { type: 'text/javascript' });
        this.workerUrl = URL.createObjectURL(blob);
        this.worker = new Worker(this.workerUrl);
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            const type = origin.type;
            const id = origin.id;
            switch (type) {
                case 'pong':
                    const task = this.taskMap.get(id);
                    if (task) {
                        task(true);
                    }
                    break;
            }
        });
    }
    setTimeout(task, timeout = 0) {
        const id = this.id++;
        this.taskMap.set(id, task);
        this.worker.postMessage({
            type: 'ping',
            data: {
                timeout,
                id
            }
        });
        return id;
    }
    clearTimeout(id) {
        this.taskMap.delete(id);
    }
    destroy() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        if (this.workerUrl) {
            URL.revokeObjectURL(this.workerUrl);
            this.workerUrl = null;
        }
        if (this.taskMap) {
            this.taskMap.clear();
            this.taskMap = null;
        }
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerTimer.ts":
/*!*****************************************!*\
  !*** ./src/common/timer/WorkerTimer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerTimer)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/**
 * @file worker 定时任务，规避后台 settimeout 最小间隔 1s 的问题
 */

class WorkerTimer {
    task;
    timeout;
    interval;
    clock;
    started;
    timer;
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.started = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval, false);
        this.clock.onClock = (next) => {
            if (this.started && this.task() === false) {
                this.stop();
            }
            else {
                next();
            }
        };
    }
    start() {
        this.started = true;
        if (this.timeout > 0) {
            this.timer = setTimeout(() => {
                this.timer = null;
                this.clock.start();
            }, this.timeout);
        }
        else {
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.clock.stop();
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    isStarted() {
        return this.started;
    }
    updateInterval(interval) {
        this.interval = interval;
        this.clock.setInterval(interval);
    }
    destroy() {
        if (this.clock) {
            this.stop();
            this.clock.destroy();
            this.clock = null;
        }
        this.started = false;
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/workerSetTimeoutTask.ts":
/*!**************************************************!*\
  !*** ./src/common/timer/workerSetTimeoutTask.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/common/timer/workerSetTimeoutTask.ts";

class WorkerSetTimeout {
    worker;
    constructor(self) {
        this.worker = self;
        this.handleEvents();
    }
    handleEvents() {
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            let data = origin.data;
            setTimeout(() => {
                this.worker.postMessage({
                    type: 'pong',
                    id: data.id
                });
            }, Math.max(data.timeout ?? 0, 4));
        });
    }
}
function run(self) {
    try {
        new WorkerSetTimeout(self);
    }
    catch (error) {
        _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('new WorkerSetTimeout failed', cheap__fileName__0, 32);
    }
}


/***/ }),

/***/ "./src/common/util/array.ts":
/*!**********************************!*\
  !*** ./src/common/util/array.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* unused harmony exports unshift, indexOf, last, pop, toObject, join, falsy, exclude */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/**
 * @file 数组操作
 */



/**
 * 遍历数组
 *
 * @param array
 * @param callback 返回 false 可停止遍历
 * @param reversed 是否逆序遍历
 */
function each(array, callback, reversed) {
    if (!array) {
        return;
    }
    const { length } = array;
    if (length) {
        if (reversed) {
            for (let i = length - 1; i >= 0; i--) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < length; i++) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    break;
                }
            }
        }
    }
}
function nativePush(array, item) {
    array[array.length] = item;
}
function nativeUnshift(array, item) {
    array.unshift(item);
}
/**
 * 添加
 *
 * @param array
 * @param value
 * @param action
 */
function addItem(array, value, action) {
    if (_is__WEBPACK_IMPORTED_MODULE_1__.array(value)) {
        each(value, function (item) {
            action(array, item);
        });
    }
    else {
        action(array, value);
    }
}
/**
 * 往后加
 *
 * @param array
 * @param target
 */
function push(array, target) {
    addItem(array, target, nativePush);
}
/**
 * 往前加
 *
 * @param array
 * @param target
 */
function unshift(array, target) {
    addItem(array, target, nativeUnshift);
}
/**
 * 数组项在数组中的位置
 *
 * @param array 数组
 * @param target 数组项
 * @param strict 是否全等判断，默认是全等
 * @return 如果未找到，返回 -1
 */
function indexOf(array, target, strict) {
    let result = _constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE ? item == target : item === target) {
            result = index;
            return _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
        }
    });
    return result;
}
/**
 * 获取数组最后一项
 *
 * @param array 数组
 * @return
 */
function last(array) {
    const { length } = array;
    if (length > 0) {
        return array[length - 1];
    }
}
/**
 * 弹出数组最后一项
 *
 * 项目里用的太多，仅用于节省字符
 *
 * @param array 数组
 * @return 弹出的数组项
 */
function pop(array) {
    const { length } = array;
    if (length > 0) {
        return array.pop();
    }
}
/**
 * 删除数组项
 *
 * @param array 数组
 * @param item 待删除项
 * @param strict 是否全等判断，默认是全等
 * @return 删除的数量
 */
function remove(array, target, strict) {
    let result = 0;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE ? item == target : item === target) {
            array.splice(index, 1);
            result++;
        }
    }, _constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
    return result;
}
/**
 * 数组是否包含 item
 *
 * @param array 数组
 * @param target 可能包含的数组项
 * @param strict 是否全等判断，默认是全等
 * @return
 */
function has(array, target, strict) {
    return indexOf(array, target, strict) >= 0;
}
/**
 * 把类数组转成数组
 *
 * @param array 类数组
 * @return
 */
function toArray(array) {
    return _is__WEBPACK_IMPORTED_MODULE_1__.array(array)
        ? array
        : (0,_function_execute__WEBPACK_IMPORTED_MODULE_2__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY.slice, array);
}
/**
 * 把数组转成对象
 *
 * @param array 数组
 * @param key 数组项包含的字段名称，如果数组项是基本类型，可不传
 * @param value
 * @return
 */
function toObject(array, key, value) {
    let result = {};
    each(array, function (item) {
        result[key ? item[key] : item] = value || item;
    });
    return result;
}
/**
 * 把数组合并成字符串
 *
 * @param array
 * @param separator
 * @return
 */
function join(array, separator) {
    return array.join(separator);
}
/**
 * 用于判断长度大于 0 的数组
 *
 * @param array
 * @return
 */
function falsy(array) {
    return !_is__WEBPACK_IMPORTED_MODULE_1__.array(array) || !array.length;
}
/**
 * 排除数组元素返回新数组
 *
 * @param source
 * @param exc
 * @returns
 */
function exclude(source, exc) {
    const items = [];
    each(source, (item, index) => {
        if (!has(exc, item)) {
            items.push(item);
        }
    });
    return items;
}
/**
 * 二分查找
 *
 * @param array
 * @param callback 相等返回 0， 往左边查返回 -1， 往右边查返回 1
 * @returns
 */
function binarySearch(array, callback) {
    let left = 0;
    let right = array.length - 1;
    let index = -1;
    while (left <= right) {
        let mid = ((left + right) / 2) >>> 0;
        const ret = callback(array[mid]);
        if (ret === 0) {
            index = mid;
            break;
        }
        else if (ret === 1) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
            index = mid;
        }
    }
    return index;
}


/***/ }),

/***/ "./src/common/util/base64.ts":
/*!***********************************!*\
  !*** ./src/common/util/base64.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array)
/* harmony export */ });
/* unused harmony exports base64Decode, list, map */
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
/**
 * utf8 编码
 * @param text
 */
function utf8Decode(text) {
    let string = '', i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;
    while (i < text.length) {
        c = text.charCodeAt(i);
        if (c < 128) {
            string += String.fromCharCode(c);
            i++;
        }
        else if ((c > 191) && (c < 224)) {
            c2 = text.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = text.charCodeAt(i + 1);
            c3 = text.charCodeAt(i + 2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return string;
}
/**
 * base64 解密
 */
function base64Decode(text) {
    let output = '';
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
    text = text.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    // 不是 4 的倍数补齐 =
    while (text.length % 4) {
        text += '=';
    }
    while (i < text.length) {
        enc1 = base64.indexOf(text.charAt(i++));
        enc2 = base64.indexOf(text.charAt(i++));
        enc3 = base64.indexOf(text.charAt(i++));
        enc4 = base64.indexOf(text.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    return utf8Decode(output);
}
function atobCustom(encodedString) {
    function decodeBase64(char) {
        const index = base64.indexOf(char);
        return index === -1 ? 0 : index;
    }
    let decodedString = '';
    for (let i = 0; i < encodedString.length;) {
        const enc1 = decodeBase64(encodedString[i++]);
        const enc2 = decodeBase64(encodedString[i++]);
        const enc3 = decodeBase64(encodedString[i++]);
        const enc4 = decodeBase64(encodedString[i++]);
        const chr1 = (enc1 << 2) | (enc2 >> 4);
        const chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        const chr3 = ((enc3 & 3) << 6) | enc4;
        decodedString += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            decodedString += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            decodedString += String.fromCharCode(chr3);
        }
    }
    return decodedString;
}
function base64ToUint8Array(string) {
    const binaryData = typeof atob === 'function' ? atob(string) : atobCustom(string);
    const uint8Array = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i);
    }
    return uint8Array;
}
const list = [
    'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R',
    'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1',
    '2', '3', '4', '5', '6', '7',
    '8', '9', '+', '/'
];
const _map = {};
_array__WEBPACK_IMPORTED_MODULE_0__.each(list, (char, index) => {
    _map[char] = index;
});
const map = _map;


/***/ }),

/***/ "./src/common/util/bigint.ts":
/*!***********************************!*\
  !*** ./src/common/util/bigint.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min)
/* harmony export */ });
function abs(a) {
    return a > 0 ? a : -a;
}
function max(a, b) {
    return a > b ? a : b;
}
function min(a, b) {
    return a > b ? b : a;
}


/***/ }),

/***/ "./src/common/util/browser.ts":
/*!************************************!*\
  !*** ./src/common/util/browser.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/checkVersion */ "./src/common/function/checkVersion.ts");
/**
 * @file browser
 */



function getMajorVersion(version) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.string(version)) {
        return '';
    }
    return version.split('.').shift() || '';
}
/**
 * UA 检测浏览器
 *
 * 返回结果如下：
 *
 * {
 *    name: 'ie',     // 判断多个浏览器时，便于用 name 去 switch
 *    ie: true,       // 判断某一个浏览器时，便于 if (ie) { ... }
 *    version: '8.0'  // 版本号，string 类型
 * }
 *
 */
// http://www.fynas.com/ua/search
const list = [
    ["alipay" /* BrowserType.ALIPAY */, /alipay/],
    ["wechat" /* BrowserType.WECHAT */, /micromessenger/],
    ["dingtalk" /* BrowserType.DING_TALK */, /dingtalk[ \/]([\d_.]+)/],
    ["baiduApp" /* BrowserType.BAIDU_APP */, /baiduboxapp/],
    ["baidu" /* BrowserType.BAIDU */, /baidubrowser/],
    ["baidu" /* BrowserType.BAIDU */, /bdbrowser/],
    ["uc" /* BrowserType.UC */, /ucbrowser/],
    ["uc" /* BrowserType.UC */, /ucweb/],
    ["qq" /* BrowserType.QQ */, /qqbrowser/],
    ["qqApp" /* BrowserType.QQ_APP */, /qq/],
    ["ie" /* BrowserType.IE */, /iemobile[ \/]([\d_.]+)/],
    // IE10- 所有版本都有的信息是 MSIE x.0
    ["ie" /* BrowserType.IE */, /msie[ \/]([\d_.]+)/],
    ["ie" /* BrowserType.IE */, /trident[ \/]([\d_.]+)/, 4],
    ["edge" /* BrowserType.EDGE */, /edge[ \/]([\d_.]+)/],
    ["newEdge" /* BrowserType.NEW_EDGE */, /edg[ \/]([\d_.]+)/],
    ["chrome" /* BrowserType.CHROME */, /chrome[ \/]([\d_.]+)/],
    ["firefox" /* BrowserType.FIREFOX */, /firefox[ \/]([\d_.]+)/],
    ["opera" /* BrowserType.OPERA */, /opera(?:.*version)?[ \/]([\d_.]+)/],
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) safari/],
    // 新版 Safari UA
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) \S* safari/],
    ["safari" /* BrowserType.SAFARI */, /safari/]
];
const getMajorVersionMap = {};
const checkVersionMap = {};
/**
 * 获取 UA 的结构化信息
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_1__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
                if (item[2]) {
                    version = (parseInt(version, 10) + item[2]) + '.0';
                }
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || '',
        majorVersion: (getMajorVersionMap[name] || getMajorVersion)(version),
        checkVersion: checkVersionMap[name] || _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__["default"]
    };
}
const browser = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (browser.name) {
    browser[browser.name] = true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browser);


/***/ }),

/***/ "./src/common/util/constant.ts":
/*!*************************************!*\
  !*** ./src/common/util/constant.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_FUNCTION: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   EMPTY_STRING: () => (/* binding */ EMPTY_STRING),
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   GLOBAL: () => (/* binding */ GLOBAL),
/* harmony export */   MINUS_ONE: () => (/* binding */ MINUS_ONE),
/* harmony export */   NULL: () => (/* binding */ NULL),
/* harmony export */   RAW_DOT: () => (/* binding */ RAW_DOT),
/* harmony export */   RAW_FUNCTION: () => (/* binding */ RAW_FUNCTION),
/* harmony export */   RAW_UNDEFINED: () => (/* binding */ RAW_UNDEFINED),
/* harmony export */   RAW_WILDCARD: () => (/* binding */ RAW_WILDCARD),
/* harmony export */   SELF: () => (/* binding */ SELF),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),
/* harmony export */   WINDOW: () => (/* binding */ WINDOW)
/* harmony export */ });
/* unused harmony exports RAW_TRUE, RAW_FALSE, RAW_NULL, RAW_THIS, RAW_VALUE, RAW_LENGTH, RAW_SLASH, RAW_TAG, KEYPATH_PARENT, KEYPATH_CURRENT, DOCUMENT, EMPTY_OBJECT */
/**
 * @file 为了压缩，定义的常量
 */
const TRUE = true;
const FALSE = false;
const NULL = null;
const UNDEFINED = void 0;
const MINUS_ONE = -1;
const RAW_TRUE = 'true';
const RAW_FALSE = 'false';
const RAW_NULL = 'null';
const RAW_UNDEFINED = 'undefined';
const RAW_THIS = 'this';
const RAW_VALUE = 'value';
const RAW_LENGTH = 'length';
const RAW_FUNCTION = 'function';
const RAW_WILDCARD = '*';
const RAW_DOT = '.';
const RAW_SLASH = '/';
const RAW_TAG = 'tag';
const KEYPATH_PARENT = '..';
const KEYPATH_CURRENT = RAW_THIS;
/**
 * Single instance for window in browser
 */
const WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;
/**
 * Single instance for document in browser
 */
const DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;
/**
 * Single instance for global in nodejs or browser
 */
// @ts-ignore
const GLOBAL = typeof globalThis !== RAW_UNDEFINED ? globalThis : (typeof __webpack_require__.g !== RAW_UNDEFINED ? __webpack_require__.g : WINDOW);
/**
 * Single instance for self in nodejs or browser
 */
// @ts-ignore
const SELF = typeof self !== RAW_UNDEFINED ? self : GLOBAL;
/**
 * Single instance for noop function
 */
const EMPTY_FUNCTION = function () {
    /** common */
};
/**
 * 空对象，很多地方会用到，比如 `a || EMPTY_OBJECT` 确保是个对象
 */
const EMPTY_OBJECT = Object.freeze({});
/**
 * 空数组
 */
const EMPTY_ARRAY = Object.freeze([]);
/**
 * 空字符串
 */
const EMPTY_STRING = '';


/***/ }),

/***/ "./src/common/util/is.ts":
/*!*******************************!*\
  !*** ./src/common/util/is.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   arrayBuffer: () => (/* binding */ arrayBuffer),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   func: () => (/* binding */ func),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   numeric: () => (/* binding */ numeric),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   string: () => (/* binding */ string)
/* harmony export */ });
/* unused harmony export range */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 判断
 */

/**
 * Check if value is a function.
 *
 * @param value
 * @return
 */
function func(value) {
    return typeof value === _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION;
}
/**
 * Check if value is an array.
 *
 * @param value
 * @return
 */
function array(value) {
    return Array.isArray(value);
}
/**
 * Check if value is an object.
 *
 * @param value
 * @return
 */
function object(value) {
    // 低版本 IE 会把 null 当作 object
    return value !== _constant__WEBPACK_IMPORTED_MODULE_0__.NULL && typeof value === 'object';
}
/**
 * Check if value is a string.
 *
 * @param value
 * @return
 */
function string(value) {
    return typeof value === 'string';
}
/**
 * Check if value is a number.
 *
 * @param value
 * @return
 */
function number(value) {
    return typeof value === 'number' && !isNaN(value);
}
/**
 * Check if value is a bigint.
 *
 * @param value
 * @return
 */
function bigint(value) {
    return typeof value === 'bigint';
}
/**
 * Check if value is boolean.
 *
 * @param value
 * @return
 */
function boolean(value) {
    return typeof value === 'boolean';
}
/**
 * Check if value is numeric.
 *
 * @param value
 * @return
 */
function numeric(value) {
    return number(value)
        || (string(value) && !isNaN(parseFloat(value)) && isFinite(+value));
}
const hasOwn = {}.hasOwnProperty;
/**
 * 判断是不是普通字面量对象
 *
 * @param {*} target
 * @return {boolean}
 */
function isPlainObject(target) {
    if (!object(target) || target.nodeType || target === target.window) {
        return false;
    }
    if (target.constructor
        && !hasOwn.call(target, 'constructor')
        && !hasOwn.call(target.constructor.prototype || {}, 'isPrototypeOf')) {
        return false;
    }
    let key;
    for (key in target) {
        /* empty */
    }
    return key === undefined || hasOwn.call(target, key);
}
/**
 * 判断 value 是否在指定范围中
 *
 * @param value 待判断值
 * @param min 范围左区间
 * @param max 范围右区间
 */
function range(value, min, max) {
    return value >= min && value <= max;
}
/**
 * Check if value is ArrayBuffer.
 *
 * @param value
 * @returns
 */
function arrayBuffer(value) {
    return value instanceof ArrayBuffer;
}


/***/ }),

/***/ "./src/common/util/keypath.ts":
/*!************************************!*\
  !*** ./src/common/util/keypath.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   each: () => (/* binding */ each)
/* harmony export */ });
/* unused harmony exports match, join, isFuzzy, matchFuzzy, rootPath */
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./src/common/util/string.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 路径操作
 */


const dotPattern = /\./g, asteriskPattern = /\*/g, doubleAsteriskPattern = /\*\*/g, splitCache = {}, patternCache = {};
/**
 * 判断 keypath 是否以 prefix 开头，如果是，返回匹配上的前缀长度，否则返回 -1
 *
 * @param keypath
 * @param prefix
 * @return
 */
function match(keypath, prefix) {
    if (keypath === prefix) {
        return prefix.length;
    }
    prefix += _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT;
    return _string__WEBPACK_IMPORTED_MODULE_1__.startsWith(keypath, prefix)
        ? prefix.length
        : _constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
}
/**
 * 遍历 keypath 的每个部分
 *
 * @param keypath
 * @param callback 返回 false 可中断遍历
 */
function each(keypath, callback) {
    /*
     * 如果 keypath 是 toString 之类的原型字段
     * splitCache[keypath] 会取到原型链上的对象
     */
    const list = splitCache.hasOwnProperty(keypath)
        ? splitCache[keypath]
        : (splitCache[keypath] = keypath.split(_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT));
    for (let i = 0, lastIndex = list.length - 1; i <= lastIndex; i++) {
        if (callback(list[i], i === lastIndex) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
            break;
        }
    }
}
/**
 * 路径组合
 *
 * @param keypath1
 * @param keypath2
 */
function join(keypath1, keypath2) {
    return keypath1 && keypath2
        ? keypath1 + _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT + keypath2
        : keypath1 || keypath2;
}
/**
 * 是否是模糊匹配
 *
 * @param keypath
 */
function isFuzzy(keypath) {
    return _string__WEBPACK_IMPORTED_MODULE_1__.has(keypath, _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_WILDCARD);
}
/**
 * 模糊匹配 keypath
 *
 * @param keypath 待匹配路径
 * @param pattern 匹配规则
 */
function matchFuzzy(keypath, pattern) {
    let cache = patternCache[pattern];
    if (!cache) {
        const str = pattern
            .replace(dotPattern, '\\.')
            .replace(asteriskPattern, '(\\w+)')
            .replace(doubleAsteriskPattern, '([\.\\w]+?)');
        cache = patternCache[pattern] = new RegExp(`^${str}$`);
    }
    const result = keypath.match(cache);
    if (result) {
        return result[1];
    }
}
/**
 * 返回 keypath 的根路径
 *
 * @param keypath
 */
function rootPath(keypath) {
    return keypath && keypath.split(_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT).shift();
}


/***/ }),

/***/ "./src/common/util/logger.ts":
/*!***********************************!*\
  !*** ./src/common/util/logger.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INFO: () => (/* binding */ INFO),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   fatal: () => (/* binding */ fatal),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* unused harmony exports TRACE, DEBUG, WARN, ERROR, FATAL, trace, log, enableUploadLog, disableUploadLog, canUploadLog, setUploadLevel, getUploadLevel */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file 日志
 */


const TRACE = 0;
const DEBUG = 1;
const INFO = 2;
const WARN = 3;
const ERROR = 4;
const FATAL = 5;
const nativeConsole = typeof console !== _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_UNDEFINED ? console : _constant__WEBPACK_IMPORTED_MODULE_0__.NULL, 
/**
 * 当前是否是源码调试，如果开启了代码压缩，empty function 里的注释会被干掉
 */
defaultLogLevel = /common/.test((0,_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION)) ? INFO : WARN, 
/**
 * console 样式前缀
 * ie 和 edge 不支持 console.log 样式
 */
stylePrefix = _constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW && /edge|msie|trident/i.test(_constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW.navigator.userAgent) || true
    ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
    : 0, 
/**
 * 日志打印函数
 */
printLog = nativeConsole
    ? stylePrefix
        ? function (tag, msg, style) {
            nativeConsole.log(stylePrefix + tag, style, msg);
        }
        : function (tag, msg) {
            nativeConsole.log(tag, msg);
        }
    : _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION;
/**
 * 全局调试开关
 */
function getLogLevel() {
    if (_constant__WEBPACK_IMPORTED_MODULE_0__.GLOBAL) {
        const logLevel = _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'];
        if (logLevel >= TRACE && logLevel <= FATAL) {
            return logLevel;
        }
    }
    return defaultLogLevel;
}
/**
 * 设置日志输出级别
 *
 * @param level 日志输出级别
 */
function setLevel(level) {
    _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'] = level;
}
function getStyle(backgroundColor) {
    return `background-color:${backgroundColor};border-radius:12px;color:#fff;font-size:10px;padding:3px 6px;`;
}
function trace(msg, file, line) {
    if (getLogLevel() <= TRACE) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [trace]`, msg, getStyle('#999'));
    }
}
function debug(msg, file, line) {
    if (getLogLevel() <= DEBUG) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [debug]`, msg, getStyle('#999'));
    }
}
function info(msg, file, line) {
    if (getLogLevel() <= INFO) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [info]`, msg, getStyle('#2db7f5'));
    }
}
function warn(msg, file, line) {
    if (getLogLevel() <= WARN) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [warn]`, msg, getStyle('#f90'));
    }
}
function error(msg, file, line) {
    if (getLogLevel() <= ERROR) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [error]`, msg, getStyle('#ed4014'));
    }
}
function fatal(msg, file, line) {
    if (getLogLevel() <= FATAL) {
        error(msg, file, line);
        throw new Error(`[${arguments[1]}][line ${arguments[2]}] [fatal]: ${msg}`);
    }
}
function log(level, msg, file, line) {
    if (level === TRACE) {
        trace(msg, arguments[2], arguments[3]);
    }
    else if (level === DEBUG) {
        debug(msg, arguments[2], arguments[3]);
    }
    else if (level === INFO) {
        info(msg, arguments[2], arguments[3]);
    }
    else if (level === WARN) {
        warn(msg, arguments[2], arguments[3]);
    }
    else if (level === ERROR) {
        error(msg, arguments[2], arguments[3]);
    }
    else if (level === FATAL) {
        fatal(msg, arguments[2], arguments[3]);
    }
}
/**
 * @internal
 * 是否上传，全局配置
 */
let enableUpload = true;
/**
 * @internal
 * 日志上传等级，全局配置
 */
let uploadLevel = WARN;
/**
 * 打开日志上传
 *
 */
function enableUploadLog() {
    enableUpload = true;
}
/**
 * 关闭日志上传
 */
function disableUploadLog() {
    enableUpload = false;
}
/**
 * 是否可以上传日志
 */
function canUploadLog() {
    return enableUpload;
}
/**
 * 设置日志上传等级
 */
function setUploadLevel(level) {
    uploadLevel = level;
}
/**
 * 获取日志上传等级
 */
function getUploadLevel() {
    return uploadLevel;
}


/***/ }),

/***/ "./src/common/util/object.ts":
/*!***********************************!*\
  !*** ./src/common/util/object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   param: () => (/* binding */ param)
/* harmony export */ });
/* unused harmony exports keys, sort, clear, merge, get, set, has, falsy, diff, toArray, update */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _keypath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypath */ "./src/common/util/keypath.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");
/**
 * @file 对象操作
 */





/**
 * 获取对象的 key 的数组
 *
 * @param object
 * @return
 */
function keys(object) {
    if (!(0,_function_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
        return [];
    }
    return Object.keys(object);
}
function sortKeyByAsc(a, b) {
    return a.length - b.length;
}
function sortKeyByDesc(a, b) {
    return b.length - a.length;
}
/**
 * 排序对象的 key
 *
 * @param object
 * @param desc 是否逆序，默认从小到大排序
 * @return
 */
function sort(object, desc) {
    return keys(object).sort(desc ? sortKeyByDesc : sortKeyByAsc);
}
/**
 * 遍历对象
 *
 * @param object
 * @param callback 返回 false 可停止遍历
 */
function each(object, callback) {
    for (let key in object) {
        if (callback(object[key], key) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
            break;
        }
    }
}
/**
 * 清空对象所有的键值对
 *
 * @param object
 */
function clear(object) {
    each(object, function (_, key) {
        delete object[key];
    });
}
function _extend(original, object) {
    if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(original)) {
        return object;
    }
    else if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(object)) {
        return original;
    }
    each(object, function (value, key) {
        original[key] = value;
    });
    return original;
}
/**
 * 扩展对象
 *
 * @return
 */
function extend(original, object, object2) {
    return _extend(_extend(original, object), object2);
}
/**
 * 合并对象
 *
 * @return
 */
function merge(object1, object2) {
    return object1 && object2
        ? extend(extend({}, object1), object2)
        : object1 || object2;
}
/**
 * 拷贝对象
 *
 * @param object
 * @param deep 是否需要深拷贝
 * @return
 */
function copy(object, deep) {
    let result = object;
    if (_is__WEBPACK_IMPORTED_MODULE_2__.array(object)) {
        if (deep) {
            result = [];
            _array__WEBPACK_IMPORTED_MODULE_3__.each(object, function (item, index) {
                result[index] = copy(item, deep);
            });
        }
        else {
            result = object.slice();
        }
    }
    else if (_is__WEBPACK_IMPORTED_MODULE_2__.object(object)) {
        result = {};
        each(object, function (value, key) {
            result[key] = deep ? copy(value, deep) : value;
        });
    }
    return result;
}
/**
 * 从对象中查找一个 keypath
 *
 * 返回值是空时，表示没找到值
 *
 * @param object
 * @param keypath
 * @return
 */
function get(object, keypath, defaultValue) {
    let result;
    _keypath__WEBPACK_IMPORTED_MODULE_4__.each(keypath, function (key, isLast) {
        if (object != _constant__WEBPACK_IMPORTED_MODULE_1__.NULL) {
            // 先直接取值
            let value = object[key], 
            // 紧接着判断值是否存在
            hasValue = value !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
            if (isLast) {
                if (hasValue) {
                    result = value;
                }
                else {
                    result = _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
                }
            }
            else {
                object = value;
            }
        }
        else {
            result = _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
    // 没找到使用默认值
    if (result === _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED) {
        result = defaultValue;
    }
    return result;
}
/**
 * 为对象设置一个键值对
 *
 * @param object
 * @param keypath
 * @param value
 * @param autofill 是否自动填充不存在的对象，默认自动填充
 */
function set(object, keypath, value, autofill) {
    _keypath__WEBPACK_IMPORTED_MODULE_4__.each(keypath, function (key, isLast) {
        if (isLast) {
            object[key] = value;
        }
        else if (object[key]) {
            object = object[key];
        }
        else if (autofill) {
            object = object[key] = {};
        }
        else {
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
}
/**
 * 对象是否包含某个 key
 *
 * @param object
 * @param key
 * @return
 */
function has(object, key) {
    // 不用 hasOwnProperty，性能差
    return object[key] !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
}
/**
 * 是否是空对象
 *
 * @param object
 * @return
 */
function falsy(object) {
    return !_is__WEBPACK_IMPORTED_MODULE_2__.object(object)
        || _is__WEBPACK_IMPORTED_MODULE_2__.array(object)
        || !keys(object).length;
}
/**
 * 获取两个对象的 value 不同的 key
 *
 * @param obj1
 * @param obj2
 */
function diff(obj1, obj2) {
    let differences = [];
    each(obj1, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.array(value) || _is__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(value)) {
            if (obj2[key] == null || diff(value, obj2[key]).length > 0) {
                differences.push(key);
            }
        }
        else if (value !== obj2[key]) {
            differences.push(key);
        }
    });
    return differences;
}
/**
 * 序列化对象
 *
 * @param data
 */
function param(data) {
    let result = [];
    const add = (key, value) => {
        value = _is__WEBPACK_IMPORTED_MODULE_2__.func(value) ? value() : (value == null ? '' : value);
        result[result.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
    };
    if (_is__WEBPACK_IMPORTED_MODULE_2__.array(data) || _is__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(data)) {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.array(data)) {
            _array__WEBPACK_IMPORTED_MODULE_3__.each(data, (value, key) => {
                add(key, value);
            });
        }
        else {
            each(data, (value, key) => {
                add(key, value);
            });
        }
    }
    return result.join('&').replace(/%20/g, '+');
}
/**
 * 将 object 的 value 变成数组
 */
function toArray(data) {
    const result = [];
    each(data, (value) => {
        result.push(value);
    });
    return result;
}
/**
 *
 * 更新两个同一类型的对象
 *
 * @param obj1
 * @param obj2
 * @returns
 */
function update(obj1, obj2) {
    if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(obj1) || !_is__WEBPACK_IMPORTED_MODULE_2__.object(obj2)) {
        return;
    }
    each(obj2, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.object(value) && _is__WEBPACK_IMPORTED_MODULE_2__.object(obj1[key])) {
            update(obj1[key], value);
        }
        else {
            obj1[key] = obj2[key];
        }
    });
    return obj1;
}


/***/ }),

/***/ "./src/common/util/os.ts":
/*!*******************************!*\
  !*** ./src/common/util/os.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * UA 检测操作系统
 *
 * 返回结果如下：
 *
 * {
 *    name: 'mac',     // 判断多个浏览器时，便于用 name 去 switch
 *    mac: true,       // 判断某一个浏览器时，便于 if (mac) { ... }
 *    version: '8.0'   // 版本号，string 类型
 * }
 *
 */

/**
 * linux 发行版太多了，很多是没有版本信息的，只匹配 Linux 标识
 */
// 优先判断移动版，因为移动版通常会带着 PC 的标识，反过来则不会
const list = [
    ['iphone', /iphone os ([\d_.]+)/],
    ['ipad', /ipad; cpu os ([\d_.]+)/],
    ['itouch', /itouch; cpu os ([\d_.]+)/],
    ['android', /android ([\d_.]+)/],
    ['wp', /windows phone ([\d_.]+)/],
    ['windows', /windows nt ([\d_.]+)/],
    ['linux', /linux/],
    ['mac', /mac os x ([\d_.]+)/]
];
const iosMap = {
    iphone: 1,
    ipad: 1,
    itouch: 1
};
/**
 * 获取 UA 的结构化信息
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_0__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || ''
    };
}
const os = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (os.name) {
    os[os.name] = true;
    if (iosMap[os.name]) {
        os.ios = true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (os);


/***/ }),

/***/ "./src/common/util/string.ts":
/*!***********************************!*\
  !*** ./src/common/util/string.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   startsWith: () => (/* binding */ startsWith)
/* harmony export */ });
/* unused harmony exports capitalize, trim, lastIndexOf, endsWith, charAt, codeAt, upper, lower, falsy */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file string 操作
 */



const capitalizePattern = /^[a-z]/, capitalizeCache = {};
/**
 * 首字母大写
 *
 * @param str
 * @return
 */
function capitalize(str) {
    if (!capitalizeCache[str]) {
        capitalizeCache[str] = str.replace(capitalizePattern, upper);
    }
    return capitalizeCache[str];
}
/**
 * 清除两侧空白符
 *
 * @param str
 * @return 清除两侧空白符的字符串
 */
function trim(str) {
    return falsy(str)
        ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
        : str.trim();
}
/**
 * 截取字符串
 *
 * @param str
 * @param start
 * @param end
 * @return
 */
function slice(str, start, end) {
    return _is__WEBPACK_IMPORTED_MODULE_1__.number(end)
        ? start === end
            ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
            : str.slice(start, end)
        : str.slice(start);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param start
 * @return
 */
function indexOf(str, part, start) {
    return str.indexOf(part, start !== _constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED ? start : 0);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param end
 * @return
 */
function lastIndexOf(str, part, end) {
    return str.lastIndexOf(part, end !== _constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED ? end : str.length);
}
/**
 * str 是否以 part 开头
 *
 * @param str
 * @param part
 * @return
 */
function startsWith(str, part) {
    return indexOf(str, part) === 0;
}
/**
 * str 是否以 part 结束
 *
 * @param str
 * @param part
 * @return
 */
function endsWith(str, part) {
    const offset = str.length - part.length;
    return offset >= 0 && lastIndexOf(str, part) === offset;
}
/**
 * 获取某个位置的字符
 */
function charAt(str, index) {
    return str.charAt(index || 0);
}
/**
 * 获取某个位置的字符编码
 */
function codeAt(str, index) {
    return str.charCodeAt(index || 0);
}
/**
 * 大写格式
 */
function upper(str) {
    return str.toUpperCase();
}
/**
 * 小写格式
 */
function lower(str) {
    return str.toLowerCase();
}
/**
 * str 是否包含 part
 *
 * @param str
 * @param part
 * @return 是否包含
 */
function has(str, part) {
    return indexOf(str, part) >= 0;
}
/**
 * 判断长度大于 0 的字符串
 *
 * @param str
 * @return
 */
function falsy(str) {
    return !_is__WEBPACK_IMPORTED_MODULE_1__.string(str) || !str.length;
}
/**
 * 格式化输出
 *
 * @param string
 * @param args
 * @returns
 */
function format(string, ...args) {
    let i = 0;
    const length = args.length;
    return string.replace(/(%[sdvx%])|(%0(\d)+[dx])/g, (str) => {
        if (i >= length) {
            // missing argument
            return str;
        }
        const arg = args[i++];
        if (/%0(\d)+[dx]/g.test(str)) {
            const length = parseInt(str.substring(1));
            let result = str[str.length - 1] === 'd' ? (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg)) : Number(arg).toString(16);
            if (length > result.length) {
                result = new Array(length - result.length).fill('0').join('') + result;
            }
            return result;
        }
        switch (str) {
            case '%%':
                return '%';
            case '%s':
                return String(arg);
            case '%d':
                return (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg));
            case '%v':
                return '';
            case '%x':
                return Number(arg).toString(16);
        }
        return str;
    });
}


/***/ }),

/***/ "./src/common/util/support.ts":
/*!************************************!*\
  !*** ./src/common/util/support.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser */ "./src/common/util/browser.ts");

function supportedFeatures() {
    let blob = typeof Blob === 'function';
    let wasm = typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';
    let fetchSupported = typeof fetch === 'function';
    let documentSupport = typeof document === 'object';
    let canvas = documentSupport && document.createElement('canvas');
    let webgl = canvas && !!canvas.getContext('webgl');
    let offscreenCanvas = typeof OffscreenCanvas === 'function';
    let worker = typeof Worker === 'function';
    let arrayBuffer = typeof ArrayBuffer === 'function';
    let atomics = typeof Atomics === 'object';
    let audioContext = typeof AudioContext === 'function' || typeof webkitAudioContext === 'function';
    let audioWorklet = typeof AudioWorklet === 'function';
    let videoDecoder = typeof VideoDecoder === 'function';
    let audioDecoder = typeof AudioDecoder === 'function';
    let shareArrayBuffer = typeof SharedArrayBuffer === 'function';
    let mse = typeof MediaSource == 'function' || typeof ManagedMediaSource === 'function';
    let proxy = typeof Proxy === 'function';
    let thread = worker && shareArrayBuffer && atomics && proxy;
    // safari 低于 11 不支持
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '11', true)) {
        wasm = false;
    }
    // chrome 94 以上才支持 webcodec
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
        videoDecoder = false;
        audioDecoder = false;
    }
    // safari 17 之前渲染 VideoFrame 有问题
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '17', true)) {
        videoDecoder = false;
    }
    let webgpu = typeof navigator === 'object' && typeof navigator.gpu === 'object';
    let workerMSE = typeof MediaSourceHandle === 'function';
    let webAssemblyGlobal = wasm && typeof WebAssembly.Global === 'function';
    return {
        browser: _browser__WEBPACK_IMPORTED_MODULE_0__["default"],
        blob,
        wasm,
        fetch: fetchSupported,
        webgl,
        worker,
        mse,
        arrayBuffer,
        audioContext,
        audioWorklet,
        videoDecoder,
        audioDecoder,
        atomics,
        shareArrayBuffer,
        thread,
        webgpu,
        offscreenCanvas,
        workerMSE,
        webAssemblyGlobal,
        proxy,
        simd: _browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '91', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].firefox && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '89', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].version, '16.4', true),
        wasmBaseSupported: fetchSupported && wasm && webgl && audioContext && arrayBuffer && webAssemblyGlobal
    };
}
const support = supportedFeatures();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (support);


/***/ }),

/***/ "./src/common/util/text.ts":
/*!*********************************!*\
  !*** ./src/common/util/text.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
const encoder = typeof TextEncoder === 'function' ? new TextEncoder() : null;
const decoder = typeof TextDecoder === 'function' ? new TextDecoder() : null;
function encode(data) {
    if (encoder) {
        return encoder.encode(data);
    }
    const array = [];
    for (let i = 0; i < data.length; ++i) {
        let u = data.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
            let u1 = data.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
            array.push(u);
        }
        else if (u <= 2047) {
            array.push(192 | u >> 6);
            array.push(128 | u & 63);
        }
        else if (u <= 65535) {
            array.push(224 | u >> 12);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
        else {
            array.push(240 | u >> 18);
            array.push(128 | u >> 12 & 63);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
    }
    return new Uint8Array(array);
}
function decode(data) {
    if (data instanceof Uint8Array && decoder && !(typeof SharedArrayBuffer === 'function' && data.buffer instanceof SharedArrayBuffer)) {
        return decoder.decode(data);
    }
    let result = '';
    for (let i = 0; i < data.length;) {
        let u0 = data[i++ >>> 0];
        if (!(u0 & 128)) {
            result += String.fromCharCode(u0);
            continue;
        }
        let u1 = data[i++ >>> 0] & 63;
        if ((u0 & 224) == 192) {
            result += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
        }
        let u2 = data[i++ >>> 0] & 63;
        if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        }
        else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | data[i++ >>> 0] & 63;
        }
        if (u0 < 65536) {
            result += String.fromCharCode(u0);
        }
        else {
            let ch = u0 - 65536;
            result += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
    }
    return result;
}


/***/ }),

/***/ "./src/common/util/url.ts":
/*!********************************!*\
  !*** ./src/common/util/url.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAbsoluteURL: () => (/* binding */ buildAbsoluteURL),
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* unused harmony exports parseQuery, stringifyQuery, mixin, normalizePath */
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _function_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/split */ "./src/common/function/split.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/**
 * @file url 操作
 */




/**
 * 把查询字符串解析成对象
 * @param queryStr
 */
function parseQuery(queryStr, separator = '&') {
    const result = {};
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.string(queryStr) && queryStr.indexOf('=') >= 0) {
        let firstChar = queryStr.charAt(0);
        let startIndex = (firstChar === '?' || firstChar === '#') ? 1 : 0;
        if (startIndex > 0) {
            queryStr = queryStr.substr(startIndex);
        }
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each((0,_function_split__WEBPACK_IMPORTED_MODULE_2__["default"])(queryStr, separator), (item) => {
            let terms = item.split('=');
            if (terms.length === 2) {
                let key = terms[0]?.trim();
                if (key) {
                    result[key] = decodeURIComponent(terms[1]);
                }
            }
        });
    }
    return result;
}
/**
 * 把对象序列化成查询字符串
 *
 * @param query
 * @return
 */
function stringifyQuery(query, separator = '&') {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(query)) {
        _util_object__WEBPACK_IMPORTED_MODULE_3__.each(query, (value, key) => {
            result.push(key + '=' + encodeURIComponent(_util_is__WEBPACK_IMPORTED_MODULE_0__.object(value) ? JSON.stringify(value) : value));
        });
    }
    return result.join(separator);
}
/**
 * 解析 url，返回格式遵循 location 属性的命名
 *
 * @param url 如果不传，使用当前地址
 */
function parse(url) {
    const key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    const parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    const result = {};
    const m = parser.exec(url);
    let i = 14;
    while (i--) {
        result[key[i]] = m[i] ?? '';
    }
    return {
        protocol: result.protocol,
        file: result.file,
        host: result.host,
        port: result.port,
        user: result.user,
        password: result.password,
        origin: `${result.protocol}://${result.authority}`,
        pathname: result.path,
        search: `?${result.query}`,
        hash: result.anchor ? `#${result.anchor}` : ''
    };
}
/**
 * 把参数混入一个 url
 *
 * @param query
 * @param url
 * @param applyHash
 */
function mixin(query, applyHash, url) {
    if (url == null) {
        url = document.URL;
    }
    let scheme = parse(url);
    let params = parseQuery(applyHash ? scheme.hash : scheme.search);
    _util_object__WEBPACK_IMPORTED_MODULE_3__.extend(params, query);
    params = _util_object__WEBPACK_IMPORTED_MODULE_3__.param(params);
    url = scheme.origin + scheme.pathname;
    if (applyHash) {
        url += scheme.search;
    }
    else if (params) {
        url += '?' + params;
    }
    if (!applyHash) {
        url += scheme.hash;
    }
    else if (params) {
        url += '#' + params;
    }
    return url;
}
const SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
const SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
const FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
const URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
function buildURLFromParts(parts) {
    return (parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment);
}
function parseURL(url) {
    const parts = URL_REGEX.exec(url);
    if (!parts) {
        return null;
    }
    return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
    };
}
function normalizePath(path) {
    // The following operations are
    // then applied, in order, to the new path:
    // 6a) All occurrences of "./", where "." is a complete path
    // segment, are removed.
    // 6b) If the path ends with "." as a complete path segment,
    // that "." is removed.
    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
    // 6c) All occurrences of "<segment>/../", where <segment> is a
    // complete path segment not equal to "..", are removed.
    // Removal of these path segments is performed iteratively,
    // removing the leftmost matching pattern on each iteration,
    // until no matching pattern remains.
    // 6d) If the path ends with "<segment>/..", where <segment> is a
    // complete path segment not equal to "..", that
    // "<segment>/.." is removed.
    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) { }
    return path.split('').reverse().join('');
}
/**
 * from https://github.com/tjenkinson/url-toolkit
 *
 */
function buildAbsoluteURL(baseURL, relativeURL, opts) {
    opts = opts || {};
    // remove any remaining space and CRLF
    baseURL = baseURL.trim();
    relativeURL = relativeURL.trim();
    if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
            return baseURL;
        }
        let basePartsForNormalize = parseURL(baseURL);
        if (!basePartsForNormalize) {
            throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalize.path = normalizePath(basePartsForNormalize.path);
        return buildURLFromParts(basePartsForNormalize);
    }
    let relativeParts = parseURL(relativeURL);
    if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
    }
    if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
            return relativeURL;
        }
        relativeParts.path = normalizePath(relativeParts.path);
        return buildURLFromParts(relativeParts);
    }
    let baseParts = parseURL(baseURL);
    if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
    }
    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everything before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        let pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
    }
    if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
    }
    const builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
    };
    if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
            if (!relativeParts.path) {
                // 5) If the embedded URL path is empty (and not preceded by a
                // slash), then the embedded URL inherits the base URL path
                builtParts.path = baseParts.path;
                // 5a) if the embedded URL's <params> is non-empty, we skip to
                // step 7; otherwise, it inherits the <params> of the base
                // URL (if any) and
                if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    // 5b) if the embedded URL's <query> is non-empty, we skip to
                    // step 7; otherwise, it inherits the <query> of the base
                    // URL (if any) and we skip to step 7.
                    if (!relativeParts.query) {
                        builtParts.query = baseParts.query;
                    }
                }
            }
            else {
                // 6) The last segment of the base URL's path (anything
                // following the rightmost slash "/", or the entire path if no
                // slash is present) is removed and the embedded URL's path is
                // appended in its place.
                let baseURLPath = baseParts.path;
                let newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
                    relativeParts.path;
                builtParts.path = normalizePath(newPath);
            }
        }
    }
    if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
            ? normalizePath(relativeParts.path)
            : relativeParts.path;
    }
    return buildURLFromParts(builtParts);
}


/***/ }),

/***/ "./src/common/util/wasm.ts":
/*!*********************************!*\
  !*** ./src/common/util/wasm.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSLeb128Async: () => (/* binding */ readSLeb128Async),
/* harmony export */   readULeb128Async: () => (/* binding */ readULeb128Async),
/* harmony export */   setMemoryShared: () => (/* binding */ setMemoryShared),
/* harmony export */   writeSleb128Async: () => (/* binding */ writeSleb128Async),
/* harmony export */   writeUleb128Async: () => (/* binding */ writeUleb128Async)
/* harmony export */ });
/* unused harmony exports readULeb128, readSLeb128, writeSleb128, writeUleb128 */
/* harmony import */ var _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/BufferReader */ "./src/common/io/BufferReader.ts");

function readULeb128(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
async function readULeb128Async(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
function readSLeb128(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
async function readSLeb128Async(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
function writeSleb128(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    }
}
async function writeSleb128Async(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    }
}
function writeUleb128(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    } while (value !== 0);
}
async function writeUleb128Async(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    } while (value !== 0);
}
function setMemoryShared(wasm, shared) {
    const reader = new _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](wasm, true);
    reader.skip(8);
    while (reader.remainingSize()) {
        const sectionId = reader.readUint8();
        const size = readULeb128(reader);
        if (sectionId === 2 /* SectionId.Import */) {
            let count = readULeb128(reader);
            while (count--) {
                const moduleLen = readULeb128(reader);
                reader.skip(moduleLen);
                const fieldLen = readULeb128(reader);
                reader.skip(fieldLen);
                const externalKind = reader.readUint8();
                switch (externalKind) {
                    case 0 /* ExternalKind.Function */: {
                        // type index of the function signature
                        readULeb128(reader);
                        break;
                    }
                    case 3 /* ExternalKind.Global */: {
                        // content_type
                        readSLeb128(reader);
                        // mutability
                        readULeb128(reader);
                        break;
                    }
                    case 2 /* ExternalKind.Memory */: {
                        const pos = Number(reader.getPos());
                        if (shared) {
                            wasm[pos] = wasm[pos] | 2;
                        }
                        else {
                            wasm[pos] = wasm[pos] & ~2;
                        }
                        return;
                    }
                    case 1 /* ExternalKind.Table */: {
                        // elem_type
                        readSLeb128(reader);
                        const flags = readULeb128(reader);
                        readULeb128(reader);
                        if (flags & 0x01) {
                            // maximum
                            readULeb128(reader);
                        }
                        break;
                    }
                }
            }
            return;
        }
        else {
            reader.skip(size);
        }
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.asm":
/*!**********************************!*\
  !*** ./src/cheap/asm/memory.asm ***!
  \**********************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABKQhgAn9/AGACf34AYAJ/fQBgAn98AGABfwF/YAF/AX5gAX8BfWABfwF8AhIBA2VudgZtZW1vcnkCAwGAgAIDDw4AAAABAgMEBAQEBAUGBweIAQ4Gd3JpdGU4AAAHd3JpdGUxNgABB3dyaXRlMzIAAgd3cml0ZTY0AAMId3JpdGVmMzIABAh3cml0ZWY2NAAFBXJlYWQ4AAYGcmVhZFU4AAcGcmVhZDE2AAgHcmVhZFUxNgAJBnJlYWQzMgAKBnJlYWQ2NAALB3JlYWRmMzIADAdyZWFkZjY0AA0KfQ4JACAAIAE6AAALCQAgACABOwEACwkAIAAgATYCAAsJACAAIAE3AwALCQAgACABOAIACwkAIAAgATkDAAsHACAALAAACwcAIAAtAAALBwAgAC4BAAsHACAALwEACwcAIAAoAgALBwAgACkDAAsHACAAKgIACwcAIAArAwAL";

/***/ }),

/***/ "./src/cheap/thread/asm/atomics.asm":
/*!******************************************!*\
  !*** ./src/cheap/thread/asm/atomics.asm ***!
  \******************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABLAdgAX8Bf2ABfwF+YAJ/fwF/YAJ/fgF+YAN/f38Bf2ADf35+AX5gA39/fgF/AhIBA2VudgZtZW1vcnkCAwGAgAIDKCcAAAABAgICAwICAgMCAgIDAgICAwICAgMCAgIDAgICAwQEBAUCAgYHhgMnBWxvYWQ4AAAGbG9hZDE2AAEGbG9hZDMyAAIGbG9hZDY0AAMGc3RvcmU4AAQHc3RvcmUxNgAFB3N0b3JlMzIABgdzdG9yZTY0AAcEYWRkOAAIBWFkZDE2AAkFYWRkMzIACgVhZGQ2NAALBHN1YjgADAVzdWIxNgANBXN1YjMyAA4Fc3ViNjQADwRhbmQ4ABAFYW5kMTYAEQVhbmQzMgASBWFuZDY0ABMDb3I4ABQEb3IxNgAVBG9yMzIAFgRvcjY0ABcEeG9yOAAYBXhvcjE2ABkFeG9yMzIAGgV4b3I2NAAbCWV4Y2hhbmdlOAAcCmV4Y2hhbmdlMTYAHQpleGNoYW5nZTMyAB4KZXhjaGFuZ2U2NAAfEWNvbXBhcmVfZXhjaGFuZ2U4ACASY29tcGFyZV9leGNoYW5nZTE2ACESY29tcGFyZV9leGNoYW5nZTMyACISY29tcGFyZV9leGNoYW5nZTY0ACMGbm90aWZ5ACQEd2FpdAAlC3dhaXRUaW1lb3V0ACYKugMnCAAgAP4SAAALCAAgAP4TAQALCAAgAP4QAgALCAAgAP4RAwALDAAgACAB/hkAACABCwwAIAAgAf4aAQAgAQsMACAAIAH+FwIAIAELDAAgACAB/hgDACABCwoAIAAgAf4gAAALCgAgACAB/iEBAAsKACAAIAH+HgIACwoAIAAgAf4fAwALCgAgACAB/icAAAsKACAAIAH+KAEACwoAIAAgAf4lAgALCgAgACAB/iYDAAsKACAAIAH+LgAACwoAIAAgAf4vAQALCgAgACAB/iwCAAsKACAAIAH+LQMACwoAIAAgAf41AAALCgAgACAB/jYBAAsKACAAIAH+MwIACwoAIAAgAf40AwALCgAgACAB/jwAAAsKACAAIAH+PQEACwoAIAAgAf46AgALCgAgACAB/jsDAAsKACAAIAH+QwAACwoAIAAgAf5EAQALCgAgACAB/kECAAsKACAAIAH+QgMACwwAIAAgASAC/koAAAsMACAAIAEgAv5LAQALDAAgACABIAL+SAIACwwAIAAgASAC/kkDAAsKACAAIAH+AAIACwwAIAAgAUJ//gECAAsMACAAIAEgAv4BAgAL";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.asm":
/*!******************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.asm ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEwNgAX8Bf2ACf38Bf2ADf39/AX8CEgEDZW52Bm1lbW9yeQIDAYCAAgMHBgAAAQIAAAc5BgRsb2NrAAAGdW5sb2NrAAEEd2FpdAACCXRpbWVkd2FpdAADBnNpZ25hbAAECWJyb2FkY2FzdAAFCvYBBlYBAX8gAEEAQQH+SAIAIQEgAUEARwRAA0AgAUECRgR/QQEFIABBAUEC/kgCAEEARwsEQCAAQQJCf/4BAgAaCyAAQQBBAv5IAgAhASABQQBHDQALC0EACyMAIABBAf4lAgBBAUcEQCAAQQD+FwIAIABBAf4AAgAaC0EACx0AIAAgAP4QAgAgARABGkJ//gECABogARAAGkEACykAIAAgAP4QAgAgARABGiACKQMA/gECACABEAAaQQJGBH9B8AAFQQALCxYAIABBAf4eAgAaIABBAf4AAgAaQQALGgAgAEEB/h4CABogAEGAgICABP4AAgAaQQAL";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".avplayer.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "AVPlayer:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkAVPlayer"] = self["webpackChunkAVPlayer"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/avplayer/AVPlayer.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=avplayer.js.map